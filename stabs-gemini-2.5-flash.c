/* stabs.c -- Parse stabs debugging information
   Copyright (C) 1995-2025 Free Software Foundation, Inc.
   Written by Ian Lance Taylor <ian@cygnus.com>.

   This file is part of GNU Binutils.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* This file contains code which parses stabs debugging information.
   The organization of this code is based on the gdb stabs reading
   code.  The job it does is somewhat different, because it is not
   trying to identify the correct address for anything.  */

#include "sysdep.h"
#include "bfd.h"
#include "libiberty.h"
#include "safe-ctype.h"
#include "demangle.h"
#include "debug.h"
#include "budbg.h"
#include "filenames.h"
#include "aout/aout64.h"
#include "aout/stab_gnu.h"

/* The number of predefined XCOFF types.  */

#define XCOFF_TYPE_COUNT 34

/* This structure is used as a handle so that the stab parsing doesn't
   need to use any static variables.  */

struct stab_handle
{
  /* The BFD.  */
  bfd *abfd;
  /* TRUE if this is stabs in sections.  */
  bool sections;
  /* The symbol table.  */
  asymbol **syms;
  /* The number of symbols.  */
  long symcount;
  /* The accumulated file name string.  */
  char *so_string;
  /* The value of the last N_SO symbol.  */
  bfd_vma so_value;
  /* The value of the start of the file, so that we can handle file
     relative N_LBRAC and N_RBRAC symbols.  */
  bfd_vma file_start_offset;
  /* The offset of the start of the function, so that we can handle
     function relative N_LBRAC and N_RBRAC symbols.  */
  bfd_vma function_start_offset;
  /* The version number of gcc which compiled the current compilation
     unit, 0 if not compiled by gcc.  */
  int gcc_compiled;
  /* Whether an N_OPT symbol was seen that was not generated by gcc,
     so that we can detect the SunPRO compiler.  */
  bool n_opt_found;
  /* The main file name.  */
  char *main_filename;
  /* A stack of unfinished N_BINCL files.  */
  struct bincl_file *bincl_stack;
  /* A list of finished N_BINCL files.  */
  struct bincl_file *bincl_list;
  /* Whether we are inside a function or not.  */
  bool within_function;
  /* The address of the end of the function, used if we have seen an
     N_FUN symbol while in a function.  This is -1 if we have not seen
     an N_FUN (the normal case).  */
  bfd_vma function_end;
  /* The depth of block nesting.  */
  int block_depth;
  /* List of pending variable definitions.  */
  struct stab_pending_var *pending;
  /* Number of files for which we have types.  */
  unsigned int files;
  /* Lists of types per file.  */
  struct stab_types **file_types;
  /* Predefined XCOFF types.  */
  debug_type xcoff_types[XCOFF_TYPE_COUNT];
  /* Undefined tags.  */
  struct stab_tag *tags;
  /* Set by parse_stab_type if it sees a structure defined as a cross
     reference to itself.  Reset by parse_stab_type otherwise.  */
  bool self_crossref;
};

/* A list of these structures is used to hold pending variable
   definitions seen before the N_LBRAC of a block.  */

struct stab_pending_var
{
  /* Next pending variable definition.  */
  struct stab_pending_var *next;
  /* Name.  */
  const char *name;
  /* Type.  */
  debug_type type;
  /* Kind.  */
  enum debug_var_kind kind;
  /* Value.  */
  bfd_vma val;
};

/* A list of these structures is used to hold the types for a single
   file.  */

struct stab_types
{
  /* Next set of slots for this file.  */
  struct stab_types *next;
  /* Where the TYPES array starts.  */
  unsigned int base_index;
  /* Types indexed by type number.  */
#define STAB_TYPES_SLOTS (16)
  debug_type types[STAB_TYPES_SLOTS];
};

/* We keep a list of undefined tags that we encounter, so that we can
   fill them in if the tag is later defined.  */

struct stab_tag
{
  /* Next undefined tag.  */
  struct stab_tag *next;
  /* Tag name.  */
  const char *name;
  /* Type kind.  */
  enum debug_type_kind kind;
  /* Slot to hold real type when we discover it.  If we don't, we fill
     in an undefined tag type.  */
  debug_type slot;
  /* Indirect type we have created to point at slot.  */
  debug_type type;
};

static void bad_stab (const char *);
static void warn_stab (const char *, const char *);
static bool parse_stab_string
  (void *, struct stab_handle *, int, int, bfd_vma,
   const char *, const char *);
static debug_type parse_stab_type
  (void *, struct stab_handle *, const char *, const char **,
   debug_type **, const char *);
static bool parse_stab_type_number
  (const char **, int *, const char *);
static debug_type parse_stab_range_type
  (void *, struct stab_handle *, const char *, const char **,
   const int *, const char *);
static debug_type parse_stab_sun_builtin_type
  (void *, const char **, const char *);
static debug_type parse_stab_sun_floating_type
  (void *, const char **, const char *);
static debug_type parse_stab_enum_type
  (void *, const char **, const char *);
static debug_type parse_stab_struct_type
  (void *, struct stab_handle *, const char *, const char **,
   bool, const int *, const char *);
static bool parse_stab_baseclasses
  (void *, struct stab_handle *, const char **, debug_baseclass **,
   const char *);
static bool parse_stab_struct_fields
  (void *, struct stab_handle *, const char **, debug_field **,
   bool *, const char *);
static bool parse_stab_cpp_abbrev
  (void *, struct stab_handle *, const char **, debug_field *, const char *);
static bool parse_stab_one_struct_field
  (void *, struct stab_handle *, const char **, const char *,
   debug_field *, bool *, const char *);
static bool parse_stab_members
  (void *, struct stab_handle *, const char *, const char **, const int *,
   debug_method **, const char *);
static debug_type parse_stab_argtypes
  (void *, struct stab_handle *, debug_type, const char *, const char *,
   debug_type, const char *, bool, bool, const char **);
static bool parse_stab_tilde_field
  (void *, struct stab_handle *, const char **, const int *, debug_type *,
   bool *, const char *);
static debug_type parse_stab_array_type
  (void *, struct stab_handle *, const char **, bool, const char *);
static void push_bincl (void *, struct stab_handle *, const char *, bfd_vma);
static const char *pop_bincl (struct stab_handle *);
static bool find_excl (struct stab_handle *, const char *, bfd_vma);
static bool stab_record_variable
  (void *, struct stab_handle *, const char *, debug_type,
   enum debug_var_kind, bfd_vma);
static bool stab_emit_pending_vars (void *, struct stab_handle *);
static debug_type *stab_find_slot (void *, struct stab_handle *, const int *);
static debug_type stab_find_type (void *, struct stab_handle *, const int *);
static bool stab_record_type
  (void *, struct stab_handle *, const int *, debug_type);
static debug_type stab_xcoff_builtin_type
  (void *, struct stab_handle *, unsigned int);
static debug_type stab_find_tagged_type
  (void *, struct stab_handle *, const char *, int, enum debug_type_kind);
static debug_type *stab_demangle_argtypes
  (void *, struct stab_handle *, const char *, bool *, unsigned int);
static debug_type *stab_demangle_v3_argtypes
  (void *, struct stab_handle *, const char *, bool *);
static debug_type *stab_demangle_v3_arglist
  (void *, struct stab_handle *, struct demangle_component *, bool *);
static debug_type stab_demangle_v3_arg
  (void *, struct stab_handle *, struct demangle_component *, debug_type,
   bool *);

static int demangle_flags = DMGL_ANSI;

/* Save a string in memory.  */

static char *
savestring (void *dhandle, const char *start, size_t len)
{
  char *ret;

  // Attempt to allocate memory for the string, including space for the null terminator.
  ret = debug_xalloc(dhandle, len + 1);

  // Check if memory allocation failed. This is crucial for reliability.
  // If 'debug_xalloc' returns NULL, further operations like memcpy or
  // dereferencing 'ret[len]' would lead to a crash or undefined behavior.
  if (ret == NULL) {
    // Return NULL to the caller to signal that memory allocation failed.
    // This allows the calling code to handle the error gracefully.
    return NULL;
  }

  // Copy the specified number of bytes from the source string 'start'
  // into the newly allocated buffer 'ret'.
  // Assuming 'start' is a valid pointer to 'len' bytes as per original logic.
  memcpy(ret, start, len);

  // Null-terminate the string. This is essential for proper C string handling
  // and ensures the string can be safely used with standard library functions.
  ret[len] = '\0';

  return ret;
}

/* Read a number from a string.  */

static bfd_vma
parse_number (const char **pp, bool *poverflow, const char *p_end)
{
  const char *orig_start = *pp;
  const char *parse_ptr;
  char *endptr;
  unsigned long long ull_val;
  bool is_negative = false;

  if (poverflow != NULL)
    *poverflow = false;

  /* Check for empty or out-of-bounds input. */
  if (orig_start >= p_end || *orig_start == '\0')
    return (bfd_vma) 0;

  parse_ptr = orig_start;

  /* Determine sign. */
  if (*parse_ptr == '+')
    {
      parse_ptr++;
    }
  else if (*parse_ptr == '-')
    {
      is_negative = true;
      parse_ptr++;
    }

  /* Handle empty string after sign, e.g. "+" or "-". */
  if (parse_ptr >= p_end || *parse_ptr == '\0')
    {
      *pp = parse_ptr; /* Advance pp even if no digits were found */
      return (bfd_vma) 0;
    }

  errno = 0;
  ull_val = strtoull (parse_ptr, &endptr, 0);

  /* If strtoull did not parse any digits. */
  if (endptr == parse_ptr)
    {
      *pp = orig_start; /* No number found, keep original pointer */
      return (bfd_vma) 0;
    }

  /* Update the caller's pointer to the end of the parsed number. */
  *pp = endptr;

  /* Define max/min constants for bfd_vma and bfd_signed_vma.
     These rely on the types being standard integer types or compatible. */
#define BFD_VMA_MAX_VAL           ((bfd_vma)-1)
#define BFD_SIGNED_VMA_MAX_VAL    ((bfd_signed_vma)(((bfd_vma)1 << (sizeof(bfd_vma) * CHAR_BIT - 1)) - 1))
#define BFD_SIGNED_VMA_MIN_VAL    ((bfd_signed_vma)(-BFD_SIGNED_VMA_MAX_VAL - 1))

  /* Check for overflow from strtoull itself (value too large for unsigned long long). */
  if (errno == ERANGE && ull_val == ULLONG_MAX)
    {
      if (poverflow != NULL)
        *poverflow = true;
      else
        warn_stab (orig_start, _("numeric overflow"));
      return (bfd_vma) 0;
    }

  if (is_negative)
    {
      if (ull_val == 0)
        {
          /* -0 is 0 */
          return (bfd_vma) 0;
        }

      /* Check if the absolute value exceeds the maximum magnitude for a negative bfd_signed_vma.
         BFD_SIGNED_VMA_MIN_VAL has a magnitude of BFD_SIGNED_VMA_MAX_VAL + 1. */
      if (ull_val > (unsigned long long)BFD_SIGNED_VMA_MAX_VAL + 1ULL)
        {
          if (poverflow != NULL)
            *poverflow = true;
          else
            warn_stab (orig_start, _("numeric overflow"));
          return (bfd_vma) 0;
        }
      /* If ull_val is exactly (unsigned long long)BFD_SIGNED_VMA_MAX_VAL + 1ULL,
         it represents BFD_SIGNED_VMA_MIN_VAL. This is valid. */
      else if (ull_val > (unsigned long long)BFD_SIGNED_VMA_MAX_VAL
               && BFD_SIGNED_VMA_MIN_VAL > BFD_SIGNED_VMA_REAL_MIN_VAL_CHECK) /* Check if BFD_SIGNED_VMA_MIN_VAL is representable, e.g. via LLONG_MIN */
        {
          /* This branch indicates ull_val is too large to represent even as BFD_SIGNED_VMA_MIN_VAL,
             e.g., if bfd_signed_vma is smaller than `long long` and `ull_val` came from a value like `LLONG_MIN`.
             This check needs to be precise for the target type.
             BFD_SIGNED_VMA_MIN_VAL would be -BFD_SIGNED_VMA_MAX_VAL - 1.
             So ull_val should be <= (unsigned long long)BFD_SIGNED_VMA_MAX_VAL + 1ULL.
             If it's already past this point, it means it fit the initial `>` check.
             The `BFD_SIGNED_VMA_REAL_MIN_VAL_CHECK` assumes `LLONG_MIN` or similar is used for internal `bfd_signed_vma`.
             Given `BFD_SIGNED_VMA_MIN_VAL` is directly from the type, it's correct implicitly. */
        }
      return (bfd_vma) -((bfd_signed_vma) ull_val);
    }
  else /* Positive number */
    {
      /* Check if the value exceeds the maximum for an unsigned bfd_vma. */
      if (ull_val > BFD_VMA_MAX_VAL)
        {
          if (poverflow != NULL)
            *poverflow = true;
          else
            warn_stab (orig_start, _("numeric overflow"));
          return (bfd_vma) 0;
        }
      return (bfd_vma) ull_val;
    }
}

/* Give an error for a bad stab string.  */

static void
bad_stab (const char *p)
{
  const char *message_arg = (p != NULL) ? p : "(null)";
  fprintf (stderr, _("Bad stab: %s\n"), message_arg);
}

/* Warn about something in a stab string.  */

static void
warn_stab (const char *p, const char *err)
{
  const char *safe_p = (p != NULL) ? p : "(null)";
  const char *safe_err = (err != NULL) ? err : "(null)";

  fprintf (stderr, _("Warning: %s: %s\n"), safe_err, safe_p);
}

/* Create a handle to parse stabs symbols with.  */

void *
start_stab (void *dhandle ATTRIBUTE_UNUSED, bfd *abfd, bool sections,
	    asymbol **syms, long symcount)
{
  struct stab_handle *ret;

  ret = xcalloc (1, sizeof (*ret));

  ret->abfd = abfd;
  ret->sections = sections;
  ret->syms = syms;
  ret->symcount = symcount;
  ret->files = 1;
  ret->file_types = xcalloc (1, sizeof (*ret->file_types));
  ret->function_end = -1;
  return ret;
}

/* When we have processed all the stabs information, we need to go
   through and fill in all the undefined tags.  */

bool
finish_stab (void *dhandle, void *handle, bool emit)
{
  struct stab_handle *info = (struct stab_handle *) handle;
  if (info == NULL)
    {
      return false;
    }

  bool success = true;

  if (emit)
    {
      if (info->within_function)
        {
          if (!stab_emit_pending_vars(dhandle, info))
            {
              success = false;
            }

          if (success && !debug_end_function(dhandle, info->function_end))
            {
              success = false;
            }
        }

      if (success)
        {
          struct stab_tag *current_tag;
          for (current_tag = info->tags; current_tag != NULL; current_tag = current_tag->next)
            {
              enum debug_type_kind kind_to_use = current_tag->kind;

              if (kind_to_use == DEBUG_KIND_ILLEGAL)
                {
                  kind_to_use = DEBUG_KIND_STRUCT;
                }

              current_tag->slot = debug_make_undefined_tagged_type(
                                     dhandle, current_tag->name, kind_to_use);

              if (current_tag->slot == DEBUG_TYPE_NULL)
                {
                  success = false;
                  break;
                }
            }
        }
    }

  free(info->file_types);
  free(info->so_string);
  free(info);

  return success;
}

/* Handle a single stabs symbol.  */

static bool end_stab_function(void *dhandle, struct stab_handle *info, bfd_vma endval);
static bool process_compilation_unit_change(void *dhandle, struct stab_handle *info);
static bool should_ignore_bracket_desc(struct stab_handle *info, int desc);
static bool handle_n_lbrac(void *dhandle, struct stab_handle *info, int desc, bfd_vma value);
static bool handle_n_rbrac(void *dhandle, struct stab_handle *info, int desc, bfd_vma value);
static bool handle_n_so(void *dhandle, struct stab_handle *info, bfd_vma value, const char *string);
static bool end_function_on_empty_n_fun(void *dhandle, struct stab_handle *info, bfd_vma value);
static bool handle_default_case(void *dhandle, struct stab_handle *info, int type, int desc, bfd_vma value, const char *string, const char *string_end);

static bool
end_stab_function (void *dhandle, struct stab_handle *info, bfd_vma endval)
{
  if (!stab_emit_pending_vars (dhandle, info))
    return false;

  if (!debug_end_function (dhandle, endval))
    return false;

  info->within_function = false;
  info->function_end = (bfd_vma) -1;
  return true;
}

static bool
process_compilation_unit_change (void *dhandle, struct stab_handle *info)
{
  size_t len;
  char *copy;

  len = strlen (info->so_string) + 1;
  copy = debug_xalloc (dhandle, len);
  if (copy == NULL)
    return false;
  memcpy (copy, info->so_string, len);

  if (!debug_set_filename (dhandle, copy))
    return false;
  info->main_filename = copy;

  free (info->so_string);
  info->so_string = NULL;

  info->gcc_compiled = 0;
  info->n_opt_found = false;

  if (!info->sections)
    info->file_start_offset = info->so_value;

  info->files = 1;
  void *new_file_types = xrealloc (info->file_types, sizeof (*info->file_types));
  if (new_file_types == NULL)
    return false;
  info->file_types = new_file_types;
  info->file_types[0] = NULL;

  return true;
}

static bool
should_ignore_bracket_desc(struct stab_handle *info, int desc)
{
  return info->n_opt_found && desc == 1;
}

static bool
handle_n_lbrac(void *dhandle, struct stab_handle *info, int desc, bfd_vma value)
{
  if (should_ignore_bracket_desc(info, desc))
    return true;

  if (!info->within_function)
    {
      fprintf (stderr, _("N_LBRAC not within function\n"));
      return false;
    }

  if (!debug_start_block (dhandle,
                          value
                          + info->file_start_offset
                          + info->function_start_offset))
    return false;

  if (!stab_emit_pending_vars (dhandle, info))
    return false;

  ++info->block_depth;
  return true;
}

static bool
handle_n_rbrac(void *dhandle, struct stab_handle *info, int desc, bfd_vma value)
{
  if (should_ignore_bracket_desc(info, desc))
    return true;

  if (!stab_emit_pending_vars (dhandle, info))
    return false;

  if (!debug_end_block (dhandle,
                        value
                        + info->file_start_offset
                        + info->function_start_offset))
    return false;

  --info->block_depth;
  if (info->block_depth < 0)
    {
      fprintf (stderr, _("Too many N_RBRACs\n"));
      return false;
    }
  return true;
}

static bool
handle_n_so(void *dhandle, struct stab_handle *info, bfd_vma value, const char *string)
{
  if (info->within_function)
    {
      bfd_vma endval = value;
      if (*string != '\0'
          && info->function_end != (bfd_vma) -1
          && info->function_end < endval)
        endval = info->function_end;
      if (!end_stab_function (dhandle, info, endval))
        return false;
    }

  if (*string == '\0')
    return true;

  char *old_so_string = info->so_string;
  char *new_so_string = NULL;

  if (old_so_string == NULL)
    {
      new_so_string = xstrdup (string);
    }
  else
    {
      if (IS_ABSOLUTE_PATH (string))
        new_so_string = xstrdup (string);
      else
        new_so_string = concat (old_so_string, string, (const char *) NULL);
    }

  if (new_so_string == NULL)
    return false;

  info->so_string = new_so_string;
  free (old_so_string);

  info->so_value = value;
  return true;
}

static bool
end_function_on_empty_n_fun(void *dhandle, struct stab_handle *info, bfd_vma value)
{
  if (!info->within_function)
    return true;

  bfd_vma end_address = value;
  if (info->sections)
    end_address += info->function_start_offset;

  return end_stab_function(dhandle, info, end_address);
}

static bool
handle_default_case(void *dhandle, struct stab_handle *info, int type, int desc, bfd_vma value, const char *string, const char *string_end)
{
  const char *colon = strchr (string, ':');
  if (colon != NULL && *(colon + 1) != '\0' && (colon[1] == 'f' || colon[1] == 'F'))
    {
      if (info->within_function)
        {
          bfd_vma endval = value;
          if (info->function_end != (bfd_vma) -1
              && info->function_end < endval)
            endval = info->function_end;

          if (!end_stab_function (dhandle, info, endval))
            return false;
        }
      if (info->sections)
        info->function_start_offset = value;
      info->within_function = true;
    }

  return parse_stab_string (dhandle, info, type, desc, value, string, string_end);
}

bool
parse_stab (void *dhandle, void *handle, int type, int desc, bfd_vma value,
            const char *string)
{
  struct stab_handle *info = (struct stab_handle *) handle;
  char *copy;
  size_t len;

  if (info->so_string != NULL
      && (type != N_SO || *string == '\0' || value != info->so_value))
    {
      if (!process_compilation_unit_change (dhandle, info))
        return false;
    }

  const char * string_end = string + strlen (string);

  switch (type)
    {
    case N_FN:
    case N_FN_SEQ:
      break;

    case N_LBRAC:
      if (!handle_n_lbrac(dhandle, info, desc, value))
        return false;
      break;

    case N_RBRAC:
      if (!handle_n_rbrac(dhandle, info, desc, value))
        return false;
      break;

    case N_SO:
      if (!handle_n_so(dhandle, info, value, string))
        return false;
      break;

    case N_SOL:
    case N_BINCL:
      len = strlen (string) + 1;
      copy = debug_xalloc (dhandle, len);
      if (copy == NULL)
        return false;
      memcpy (copy, string, len);

      if (type == N_BINCL)
        push_bincl (dhandle, info, copy, value);

      if (!debug_start_source (dhandle, copy))
        return false;
      break;

    case N_EINCL:
      {
        char *popped_filename = pop_bincl (info);
        if (!debug_start_source (dhandle, popped_filename))
          return false;
      }
      break;

    case N_EXCL:
      if (!find_excl (info, string, value))
        return false;
      break;

    case N_SLINE:
      if (!debug_record_line (dhandle, desc,
                               value + (info->within_function
                                        ? info->function_start_offset : 0)))
        return false;
      break;

    case N_BCOMM:
      if (!debug_start_common_block (dhandle, string))
        return false;
      break;

    case N_ECOMM:
      if (!debug_end_common_block (dhandle, string))
        return false;
      break;

    case N_FUN:
      if (*string == '\0')
        {
          if (!end_function_on_empty_n_fun(dhandle, info, value))
            return false;
          break;
        }

      if (info->within_function
          && (info->function_end == (bfd_vma) -1
              || value < info->function_end))
        info->function_end = value;

    default:
      if (!handle_default_case(dhandle, info, type, desc, value, string, string_end))
        return false;
      break;

    case N_OPT:
      if (string != NULL)
        {
          if (strcmp (string, "gcc2_compiled.") == 0)
            info->gcc_compiled = 2;
          else if (strcmp (string, "gcc_compiled.") == 0)
            info->gcc_compiled = 1;
          else
            info->n_opt_found = true;
        }
      break;

    case N_OBJ:
    case N_ENDM:
    case N_MAIN:
    case N_WARNING:
      break;
    }

  return true;
}

/* Parse the stabs string.  */

static const char *
safe_strchr (const char *s, const char *end, int c)
{
  while (s < end && *s != (char)c)
    s++;
  return (s < end && *s == (char)c) ? s : NULL;
}

static bool
parse_long_and_advance (const char **p_ptr, const char *string_end, long *result)
{
  char *endptr;
  const char *start_p = *p_ptr;

  if (start_p >= string_end)
    return false;

  long val = strtol(start_p, &endptr, 10);

  // Check if strtol actually parsed anything and advanced the pointer
  if (endptr == start_p)
    return false;

  // Ensure endptr is within or at the logical end of the string segment
  if (endptr > string_end)
      return false;

  *result = val;
  *p_ptr = endptr; // Advance the pointer
  return true;
}

static bool
parse_double_and_advance (const char **p_ptr, const char *string_end, double *result)
{
  char *endptr;
  const char *start_p = *p_ptr;

  if (start_p >= string_end)
    return false;

  double val = strtod(start_p, &endptr);

  if (endptr == start_p)
    return false;

  if (endptr > string_end)
    return false;

  *result = val;
  *p_ptr = endptr;
  return true;
}


static bool
parse_stab_string (void *dhandle, struct stab_handle *info, int stabtype,
		   int desc ATTRIBUTE_UNUSED, bfd_vma value,
		   const char *string, const char * string_end)
{
  const char *p;
  char *name = NULL;
  int type_char;
  debug_type dtype = DEBUG_TYPE_NULL;
  debug_type *slot = NULL;
  bool synonym = false;
  bool self_crossref = false;

  const char *colon_pos = safe_strchr (string, string_end, ':');
  if (colon_pos == NULL)
    return true;

  p = colon_pos;
  while (p + 1 < string_end && p[1] == ':')
    {
      p += 2;
      colon_pos = safe_strchr (p, string_end, ':');
      if (colon_pos == NULL)
	{
	  bad_stab (string);
	  return false;
	}
      p = colon_pos;
    }
  // At this point, `p` points to the first non-escaped colon.

  if (string[0] == '$')
    {
      if (string + 1 >= string_end)
        {
          bad_stab(string);
          return false;
        }
      switch (string[1])
	{
	case 't': name = "this"; break;
	case 'v': break;
	case 'e': name = "eh_throw"; break;
	case '_': break;
	case 'X': break;
	default: warn_stab (string, _("unknown C++ encoded name")); break;
	}
    }

  if (name == NULL)
    {
      if (p == string || (string[0] == ' ' && p == string + 1))
	name = NULL;
      else
	name = savestring (dhandle, string, p - string);
    }

  p++; // Advance past the colon.

  if (p >= string_end)
    {
      bad_stab (string);
      return false;
    }

  if (ISDIGIT (*p) || *p == '(' || *p == '-')
    type_char = 'l';
  else
    type_char = *p++;

  if (type_char != 'l' && p > string_end) // For cases where p was incremented
    {
      bad_stab(string);
      return false;
    }

  switch (type_char)
    {
    case 'c':
      if (p >= string_end || *p != '=')
	{
	  bad_stab (string);
	  return false;
	}
      p++;

      if (p >= string_end)
        {
          bad_stab (string);
          return false;
        }

      switch (*p++)
	{
	case 'r':
          {
            double dval;
            if (!parse_double_and_advance (&p, string_end, &dval))
              { bad_stab (string); return false; }
            if (! debug_record_float_const (dhandle, name, dval))
              return false;
          }
	  break;
	case 'i':
          {
            long lval;
            if (!parse_long_and_advance (&p, string_end, &lval))
              { bad_stab (string); return false; }
            if (! debug_record_int_const (dhandle, name, lval))
              return false;
          }
	  break;
	case 'e':
          {
            long lval;
            dtype = parse_stab_type (dhandle, info, NULL, &p, NULL, string_end);
            if (dtype == DEBUG_TYPE_NULL) return false;
            if (p >= string_end || *p != ',')
              { bad_stab (string); return false; }
            p++;
            if (!parse_long_and_advance (&p, string_end, &lval))
              { bad_stab (string); return false; }
            if (! debug_record_typed_const (dhandle, name, dtype, lval))
              return false;
          }
	  break;
	default:
	  bad_stab (string);
	  return false;
	}
      break;

    case 'C':
      dtype = parse_stab_type (dhandle, info, NULL, &p, NULL, string_end);
      if (dtype == DEBUG_TYPE_NULL) return false;
      if (! debug_record_label (dhandle, name, dtype, value)) return false;
      break;

    case 'f':
    case 'F':
      dtype = parse_stab_type (dhandle, info, NULL, &p, NULL, string_end);
      if (dtype == DEBUG_TYPE_NULL) return false;
      if (! debug_record_function (dhandle, name, dtype, type_char == 'F', value)) return false;

      while (p < string_end && *p == ';')
	{
	  p++;
	  if (parse_stab_type (dhandle, info, NULL, &p, NULL, string_end) == DEBUG_TYPE_NULL)
	    return false;
	}
      break;

    case 'G':
      {
	    dtype = parse_stab_type (dhandle, info, NULL, &p, NULL, string_end);
	    if (dtype == DEBUG_TYPE_NULL) return false;
	    if (name != NULL)
	    {
	        char leading_char = bfd_get_symbol_leading_char (info->abfd);
	        asymbol **current_ps = info->syms;
	        for (long c = info->symcount; c > 0; --c, ++current_ps)
	        {
		        const char *sym_name = bfd_asymbol_name (*current_ps);
		        if (leading_char != '\0' && *sym_name == leading_char)
			        sym_name++;
		        if (*sym_name == *name && strcmp (sym_name, name) == 0)
			    {
			        value = bfd_asymbol_value (*current_ps);
			        break;
			    }
	        }
	    }
	    if (! stab_record_variable (dhandle, info, name, dtype, DEBUG_GLOBAL, value))
	        return false;
      }
      break;

    case 'l':
    case 's':
      dtype = parse_stab_type (dhandle, info, NULL, &p, NULL, string_end);
      if (dtype == DEBUG_TYPE_NULL) return false;
      if (! stab_record_variable (dhandle, info, name, dtype, DEBUG_LOCAL, value)) return false;
      break;

    case 'p':
      if (p < string_end && *p == 'F')
	{
	  p++;
	  dtype = parse_stab_type (dhandle, info, NULL, &p, NULL, string_end);
	  if (dtype != DEBUG_TYPE_NULL)
	    {
	      debug_type ftype;
	      ftype = debug_make_function_type (dhandle, dtype, NULL, false);
          if (ftype == DEBUG_TYPE_NULL) return false;
	      dtype = debug_make_pointer_type (dhandle, ftype);
	    }
	}
      else
	{
	  dtype = parse_stab_type (dhandle, info, NULL, &p, NULL, string_end);
	}
      if (dtype == DEBUG_TYPE_NULL) return false;
      if (! debug_record_parameter (dhandle, name, dtype, DEBUG_PARM_STACK, value)) return false;
      break;

    case 'P':
      if (stabtype == N_FUN)
	{
	  while (p < string_end && *p == ';')
	    {
	      p++;
	      if (parse_stab_type (dhandle, info, NULL, &p, NULL, string_end) == DEBUG_TYPE_NULL)
		return false;
	    }
	  break;
	}
    case 'R':
      dtype = parse_stab_type (dhandle, info, NULL, &p, NULL, string_end);
      if (dtype == DEBUG_TYPE_NULL) return false;
      if (! debug_record_parameter (dhandle, name, dtype, DEBUG_PARM_REG, value)) return false;
      break;

    case 'r':
      dtype = parse_stab_type (dhandle, info, NULL, &p, NULL, string_end);
      if (dtype == DEBUG_TYPE_NULL) return false;
      if (! stab_record_variable (dhandle, info, name, dtype, DEBUG_REGISTER, value)) return false;
      break;

    case 'S':
      dtype = parse_stab_type (dhandle, info, NULL, &p, NULL, string_end);
      if (dtype == DEBUG_TYPE_NULL) return false;
      if (! stab_record_variable (dhandle, info, name, dtype, DEBUG_STATIC, value)) return false;
      break;

    case 't':
      dtype = parse_stab_type (dhandle, info, name, &p, &slot, string_end);
      if (dtype == DEBUG_TYPE_NULL) return false;
      if (name == NULL) return true;

      dtype = debug_name_type (dhandle, name, dtype);
      if (dtype == DEBUG_TYPE_NULL) return false;

      if (slot != NULL) *slot = dtype;
      break;

    case 'T':
      if (p < string_end && *p == 't')
	{
	  synonym = true;
	  p++;
	}

      dtype = parse_stab_type (dhandle, info, name, &p, &slot, string_end);
      if (dtype == DEBUG_TYPE_NULL) return false;
      if (name == NULL) return true;

      self_crossref = info->self_crossref;

      dtype = debug_tag_type (dhandle, name, dtype);
      if (dtype == DEBUG_TYPE_NULL) return false;
      if (slot != NULL) *slot = dtype;

      if (! self_crossref)
	{
	  struct stab_tag **pst_ptr = &info->tags;
	  while (*pst_ptr != NULL)
	    {
	      if ((*pst_ptr)->name[0] == name[0]
		  && strcmp ((*pst_ptr)->name, name) == 0)
		{
		  (*pst_ptr)->slot = dtype;
		  *pst_ptr = (*pst_ptr)->next;
		  break;
		}
	      pst_ptr = &(*pst_ptr)->next;
	    }
	}

      if (synonym)
	{
	  dtype = debug_name_type (dhandle, name, dtype);
	  if (dtype == DEBUG_TYPE_NULL) return false;
	  if (slot != NULL) *slot = dtype;
	}
      break;

    case 'V':
      dtype = parse_stab_type (dhandle, info, NULL, &p, NULL, string_end);
      if (dtype == DEBUG_TYPE_NULL) return false;
      if (! stab_record_variable (dhandle, info, name, dtype,
				  DEBUG_LOCAL_STATIC, value))
	return false;
      break;

    case 'v':
      dtype = parse_stab_type (dhandle, info, NULL, &p, NULL, string_end);
      if (dtype == DEBUG_TYPE_NULL) return false;
      if (! debug_record_parameter (dhandle, name, dtype, DEBUG_PARM_REFERENCE,
				    value))
	return false;
      break;

    case 'a':
      dtype = parse_stab_type (dhandle, info, NULL, &p, NULL, string_end);
      if (dtype == DEBUG_TYPE_NULL) return false;
      if (! debug_record_parameter (dhandle, name, dtype, DEBUG_PARM_REF_REG,
				    value))
	return false;
      break;

    case 'X':
      dtype = parse_stab_type (dhandle, info, NULL, &p, NULL, string_end);
      if (dtype == DEBUG_TYPE_NULL) return false;
      if (! stab_record_variable (dhandle, info, name, dtype, DEBUG_LOCAL,
				  value))
	return false;
      break;

    case 'Y':
      // Expecting "=Yn0name;"
      if (p + 3 < string_end && *p == '=' && p[1] == 'n' && p[2] == '0')
        {
          p += 3;
          while (p < string_end && *p != ';')
            p++;
          if (p < string_end && *p == ';')
            {
              p++; // Consume ';'
              break;
            }
        }
      bad_stab (string);
      return false;

    default:
      bad_stab (string);
      return false;
    }

  return true;
}

/* Parse a stabs type.  The typename argument is non-NULL if this is a
   typedef or a tag definition.  The pp argument points to the stab
   string, and is updated.  The slotp argument points to a place to
   store the slot used if the type is being defined.  */

#ifndef BITS_PER_BYTE
#define BITS_PER_BYTE 8
#endif

/* Helper to parse type number prefix and determine if it's a definition.
   Returns true on success, false on parsing error.
   pp is advanced past type number and '=' if definition.
   typenums are filled.
   is_definition_out is set. */
static bool
read_type_number_prefix (const char **pp, const char *p_end,
                         int typenums[2], bool *is_definition_out)
{
  *is_definition_out = false;
  typenums[0] = typenums[1] = -1; /* Default to anonymous */

  if (*pp >= p_end) return false; /* Ensure not past end before reading */
  if (!ISDIGIT (**pp) && **pp != '(' && **pp != '-')
    return true; /* Anonymous type, no number prefix. */

  if (!parse_stab_type_number (pp, typenums, p_end))
    return false;

  if (*pp < p_end && **pp == '=')
    {
      *is_definition_out = true;
      ++*pp; /* Skip the '=' */
    }
  return true;
}

/* Helper to parse type attributes starting with '@'.
   Returns true on success, false on parsing error.
   pp is advanced past attributes.
   size_out and stringp_out are updated. */
static bool
parse_type_attributes (const char **pp, const char *orig, const char *p_end,
                       int *size_out, bool *stringp_out)
{
  while (*pp < p_end && **pp == '@')
    {
      const char *p = *pp + 1;

      /* Member type starts with digit, '(', or '-' */
      if (ISDIGIT (*p) || *p == '(' || *p == '-')
        break;

      const char *attr_start = p;
      while (p < p_end && *p != ';' && *p != '\0')
        ++p;

      if (p >= p_end || *p != ';') /* Expected ';' after attribute or ran out of buffer */
        {
          bad_stab (orig);
          return false;
        }

      *pp = p + 1; /* Advance past ';' */

      switch (*attr_start)
        {
        case 's':
          /* Size is in bits. Convert to bytes. */
          if (attr_start + 1 < p_end && attr_start[1] != '\0') {
            int parsed_size = atoi (attr_start + 1);
            if (parsed_size > 0)
              *size_out = parsed_size / BITS_PER_BYTE;
          }
          break;

        case 'S':
          *stringp_out = true;
          break;

        /* default: Ignore unrecognized type attributes, as per original code. */
        }
    }
  return true;
}

/* Helper for 'x' (cross-reference) descriptor. */
static debug_type
handle_cross_reference_type (void *dhandle, struct stab_handle *info,
                             const char *type_name, const char **pp,
                             const char *orig, const char *p_end)
{
  enum debug_type_kind code;
  ++*pp; /* Skip 'x' */

  if (*pp >= p_end) { bad_stab(orig); return DEBUG_TYPE_NULL; }

  switch (**pp)
    {
    case 's': code = DEBUG_KIND_STRUCT; break;
    case 'u': code = DEBUG_KIND_UNION;  break;
    case 'e': code = DEBUG_KIND_ENUM;   break;
    case '\0': bad_stab (orig); return DEBUG_TYPE_NULL;
    default:
      warn_stab (orig, _("unrecognized cross reference type"));
      code = DEBUG_KIND_STRUCT; /* Default to struct as per original */
      break;
    }
  ++*pp; /* Skip s/u/e */

  const char *name_start = *pp;
  const char *p_colon = name_start;
  int nest = 0;

  /* Find the first ':' not nested within '<...>' */
  while (p_colon < p_end && *p_colon != '\0')
    {
      if (*p_colon == '<')
        nest++;
      else if (*p_colon == '>')
        nest--;
      else if (*p_colon == ':' && nest == 0)
        break;
      p_colon++;
    }

  if (p_colon >= p_end || *p_colon != ':')
    {
      bad_stab (orig);
      return DEBUG_TYPE_NULL;
    }

  /* Check for self-cross-reference */
  if (type_name != NULL)
    {
      size_t name_len = p_colon - name_start;
      if (strlen(type_name) == name_len && strncmp(type_name, name_start, name_len) == 0)
        info->self_crossref = true;
    }

  debug_type dtype = stab_find_tagged_type (dhandle, info, name_start, (int)(p_colon - name_start), code);
  *pp = p_colon + 1; /* Advance past ':' */
  return dtype;
}

/* Helper for type defined as another type (e.g., typedef int foo; -> foo:t(1,2)=(3,4)).
   Assumes the descriptor ('-' or digit or '(') was *just* consumed, and needs to be re-parsed as a number. */
static debug_type
handle_type_alias_definition (void *dhandle, struct stab_handle *info,
                              const char **pp, const char *orig,
                              int current_typenums[2], const char *p_end)
{
  debug_type dtype;
  const char *peek_start_ptr = *pp - 1; /* Point back to the descriptor that was part of the number */

  int alias_typenums[2];
  const char *temp_pp_for_peek = peek_start_ptr;

  if (! parse_stab_type_number (&temp_pp_for_peek, alias_typenums, p_end))
    return DEBUG_TYPE_NULL;

  if (current_typenums[0] == alias_typenums[0] && current_typenums[1] == alias_typenums[1])
    {
      /* This type is being defined as itself, which means that it is void. */
      dtype = debug_make_void_type (dhandle);
      *pp = temp_pp_for_peek; /* Advance main *pp past the number we peeked */
    }
  else
    {
      *pp = peek_start_ptr; /* Restore *pp to re-parse the full type string from the number. */
      dtype = parse_stab_type (dhandle, info, (const char *) NULL,
                               pp, (debug_type **) NULL, p_end);
      if (dtype == DEBUG_TYPE_NULL)
        return DEBUG_TYPE_NULL;
    }
  return dtype;
}

/* Helper for simple derived types like pointer, reference, const, volatile, set.
   'f' (function) also falls here but its arguments are NULL for this simplified case. */
static debug_type
handle_simple_derived_type (void *dhandle, struct stab_handle *info,
                            const char **pp, const char *p_end,
                            char descriptor, bool stringp)
{
  debug_type inner_type = parse_stab_type (dhandle, info, (const char *) NULL,
                                            pp, (debug_type **) NULL, p_end);
  if (inner_type == DEBUG_TYPE_NULL)
    return DEBUG_TYPE_NULL;

  switch (descriptor)
    {
    case '*': return debug_make_pointer_type (dhandle, inner_type);
    case '&': return debug_make_reference_type (dhandle, inner_type);
    case 'f': return debug_make_function_type (dhandle, inner_type, NULL, false);
    case 'k': return debug_make_const_type (dhandle, inner_type);
    case 'B': return debug_make_volatile_type (dhandle, inner_type);
    case 'S': return debug_make_set_type (dhandle, inner_type, stringp);
    default: return DEBUG_TYPE_NULL; /* Should not happen with correct descriptor */
    }
}

/* Helper for '@' (offset/member type) descriptor. */
static debug_type
handle_offset_type (void *dhandle, struct stab_handle *info,
                    const char **pp, const char *orig, const char *p_end)
{
  debug_type domain = parse_stab_type (dhandle, info, (const char *) NULL,
                                        pp, (debug_type **) NULL, p_end);
  if (domain == DEBUG_TYPE_NULL)
    return DEBUG_TYPE_NULL;

  if (*pp >= p_end || **pp != ',')
    {
      bad_stab (orig);
      return DEBUG_TYPE_NULL;
    }
  ++*pp;

  debug_type memtype = parse_stab_type (dhandle, info, (const char *) NULL,
                                         pp, (debug_type **) NULL, p_end);
  if (memtype == DEBUG_TYPE_NULL)
    return DEBUG_TYPE_NULL;

  return debug_make_offset_type (dhandle, domain, memtype);
}

/* Helper for '##' (simple method type) descriptor. */
static debug_type
handle_simple_method_type (void *dhandle, struct stab_handle *info,
                           const char **pp, const char *orig, const char *p_end)
{
  ++*pp; /* Skip second '#' */
  if (*pp >= p_end) { bad_stab(orig); return DEBUG_TYPE_NULL; }

  debug_type return_type = parse_stab_type (dhandle, info, (const char *) NULL,
                                             pp, (debug_type **) NULL, p_end);
  if (return_type == DEBUG_TYPE_NULL)
    return DEBUG_TYPE_NULL;

  if (*pp >= p_end || **pp != ';')
    {
      bad_stab (orig);
      return DEBUG_TYPE_NULL;
    }
  ++*pp;
  return debug_make_method_type (dhandle, return_type, DEBUG_TYPE_NULL, NULL, false);
}

/* Helper for '#' (full method type with arguments) descriptor. */
static debug_type
handle_full_method_type (void *dhandle, struct stab_handle *info,
                         const char **pp, const char *orig, const char *p_end)
{
  debug_type domain = parse_stab_type (dhandle, info, (const char *) NULL,
                                        pp, (debug_type **) NULL, p_end);
  if (domain == DEBUG_TYPE_NULL)
    return DEBUG_TYPE_NULL;

  if (*pp >= p_end || **pp != ',')
    {
      bad_stab (orig);
      return DEBUG_TYPE_NULL;
    }
  ++*pp;

  debug_type return_type = parse_stab_type (dhandle, info, (const char *) NULL,
                                             pp, (debug_type **) NULL, p_end);
  if (return_type == DEBUG_TYPE_NULL)
    return DEBUG_TYPE_NULL;

  unsigned int alloc = 10;
  debug_type *args = (debug_type *) xmalloc (alloc * sizeof (*args));
  if (args == NULL) return DEBUG_TYPE_NULL;
  unsigned int n = 0;
  bool varargs = false;

  while (*pp < p_end && **pp != ';')
    {
      if (**pp != ',')
        {
          bad_stab (orig);
          free (args);
          return DEBUG_TYPE_NULL;
        }
      ++*pp;
      if (*pp >= p_end) { bad_stab(orig); free(args); return DEBUG_TYPE_NULL; }

      if (n + 1 >= alloc)
        {
          alloc += 10;
          debug_type *new_args = (debug_type *) xrealloc (args, alloc * sizeof (*args));
          if (new_args == NULL) { free(args); return DEBUG_TYPE_NULL; }
          args = new_args;
        }

      args[n] = parse_stab_type (dhandle, info, (const char *) NULL,
                                 pp, (debug_type **) NULL, p_end);
      if (args[n] == DEBUG_TYPE_NULL)
        {
          free (args);
          return DEBUG_TYPE_NULL;
        }
      ++n;
    }

  if (*pp >= p_end || **pp != ';')
    {
      bad_stab(orig);
      free(args);
      return DEBUG_TYPE_NULL;
    }
  ++*pp; /* Skip ';' */

  if (n == 0
      || debug_get_type_kind (dhandle, args[n - 1]) != DEBUG_KIND_VOID)
    varargs = true;
  else
    --n; /* Strip void type */

  debug_type *xargs = (debug_type *) debug_xalloc (dhandle, (n + 1) * sizeof (*xargs));
  if (xargs == NULL) { free(args); return DEBUG_TYPE_NULL; }
  memcpy (xargs, args, n * sizeof (*xargs));
  xargs[n] = DEBUG_TYPE_NULL; /* Null terminate */
  free (args);

  return debug_make_method_type (dhandle, return_type, domain, xargs, varargs);
}

/* Helper for 'a' (array type) descriptor. */
static debug_type
handle_array_type (void *dhandle, struct stab_handle *info,
                   const char **pp, const char *orig, bool stringp, const char *p_end)
{
  if (*pp >= p_end || **pp != 'r')
    {
      bad_stab (orig);
      return DEBUG_TYPE_NULL;
    }
  ++*pp;
  return parse_stab_array_type (dhandle, info, pp, stringp, p_end);
}


static debug_type
parse_stab_type (void *                dhandle,
		 struct stab_handle *  info,
		 const char *          type_name,
		 const char **         pp,
		 debug_type **         slotp,
		 const char *          p_end)
{
  const char *orig = *pp;
  if (orig >= p_end)
    return DEBUG_TYPE_NULL;

  int typenums[2];
  bool is_type_definition = false;
  int size = -1;
  bool stringp = false;
  debug_type dtype = DEBUG_TYPE_NULL;
  /* `type_slot_location_in_info` holds the address of the `debug_type *`
     in `info->type_vec` where the final type should be stored if it's a definition. */
  debug_type *type_slot_location_in_info = NULL; 

  info->self_crossref = false;

  /* Initialize caller's slot to NULL. */
  if (slotp != NULL)
    *slotp = DEBUG_TYPE_NULL;

  /* 1. Parse type number prefix and determine if it's a definition. */
  if (!read_type_number_prefix (pp, p_end, typenums, &is_type_definition))
    return DEBUG_TYPE_NULL;

  /* If a type number was parsed, but it's not a definition, it's a type reference. */
  if (!is_type_definition && typenums[0] != -1)
    {
      return stab_find_type(dhandle, info, typenums);
    }

  /* If it's a definition with a valid type number, find or create the storage slot for it.
     `stab_find_slot` returns `debug_type *`, which is the pointer to the memory location
     where the actual `debug_type` object should be placed. */
  if (is_type_definition && typenums[0] >= 0 && typenums[1] >= 0)
    {
      type_slot_location_in_info = stab_find_slot (dhandle, info, typenums);
      if (type_slot_location_in_info == NULL)
        return DEBUG_TYPE_NULL;
    }

  /* 2. Parse type attributes (if this is a definition) */
  if (!parse_type_attributes (pp, orig, p_end, &size, &stringp))
    return DEBUG_TYPE_NULL;

  if (*pp >= p_end)
    {
      bad_stab(orig);
      return DEBUG_TYPE_NULL;
    }

  char descriptor = **pp;
  ++*pp; /* Advance past the main type descriptor */

  switch (descriptor)
    {
    case 'x':
      dtype = handle_cross_reference_type (dhandle, info, type_name, pp, orig, p_end);
      break;

    case '-': case '0': case '1': case '2': case '3':
    case '4': case '5': case '6': case '7': case '8': case '9': case '(':
      dtype = handle_type_alias_definition (dhandle, info, pp, orig, typenums, p_end);
      break;

    case '*':
    case '&':
    case 'f':
    case 'k':
    case 'B':
    case 'S':
      dtype = handle_simple_derived_type (dhandle, info, pp, p_end, descriptor, stringp);
      break;

    case '@':
      dtype = handle_offset_type (dhandle, info, pp, orig, p_end);
      break;

    case '#':
      if (*pp >= p_end) { bad_stab(orig); return DEBUG_TYPE_NULL; }
      if (**pp == '#')
        dtype = handle_simple_method_type (dhandle, info, pp, orig, p_end);
      else
        dtype = handle_full_method_type (dhandle, info, pp, orig, p_end);
      break;

    case 'r':
      dtype = parse_stab_range_type (dhandle, info, type_name, pp, typenums, p_end);
      break;

    case 'b':
      dtype = parse_stab_sun_builtin_type (dhandle, pp, p_end);
      break;

    case 'R':
      dtype = parse_stab_sun_floating_type (dhandle, pp, p_end);
      break;

    case 'e':
      dtype = parse_stab_enum_type (dhandle, pp, p_end);
      break;

    case 's':
    case 'u':
      dtype = parse_stab_struct_type (dhandle, info, type_name, pp,
                                      descriptor == 's', typenums, p_end);
      break;

    case 'a':
      dtype = handle_array_type (dhandle, info, pp, orig, stringp, p_end);
      break;

    default:
      bad_stab (orig);
      return DEBUG_TYPE_NULL;
    }

  if (dtype == DEBUG_TYPE_NULL)
    return DEBUG_TYPE_NULL;

  /* 3. Record the type mapping if it was a definition with valid type numbers. */
  if (is_type_definition && typenums[0] >= 0 && typenums[1] >= 0)
    {
      if (! stab_record_type (dhandle, info, typenums, dtype))
	return DEBUG_TYPE_NULL;

      /* If a slot was reserved by `stab_find_slot`, place the newly parsed
         or resolved type into that location. */
      if (type_slot_location_in_info != NULL)
        *type_slot_location_in_info = dtype;
    }

  /* 4. Record type size if specified by attributes. */
  if (size != -1)
    {
      if (! debug_record_type_size (dhandle, dtype, (unsigned int) size))
	return DEBUG_TYPE_NULL;
    }

  /* 5. Update the caller's slot if provided. */
  if (slotp != NULL)
    *slotp = dtype;

  return dtype;
}

/* Read a number by which a type is referred to in dbx data, or
   perhaps read a pair (FILENUM, TYPENUM) in parentheses.  Just a
   single number N is equivalent to (0,N).  Return the two numbers by
   storing them in the vector TYPENUMS.  */

#include <limits.h>
#include <stdbool.h>

static bool
get_number_from_pp(const char **pp, int *result, const char *p_end, const char *orig_error_pos)
{
  bool overflow = false;
  const char *start_num_pos = *pp;

  if (*pp >= p_end) {
      bad_stab(orig_error_pos);
      return false;
  }

  long val = parse_number(pp, &overflow, p_end);

  if (*pp == start_num_pos)
  {
      bad_stab(orig_error_pos);
      return false;
  }

  if (overflow || val > INT_MAX || val < INT_MIN)
  {
      bad_stab(orig_error_pos);
      return false;
  }

  *result = (int)val;
  return true;
}

static bool
parse_stab_type_number (const char **pp, int *typenums, const char *p_end)
{
  const char *orig = *pp;
  bool success;

  if (*pp >= p_end) {
      bad_stab(orig);
      return false;
  }

  if (**pp != '(')
    {
      typenums[0] = 0;
      success = get_number_from_pp(pp, &typenums[1], p_end, orig);
      return success;
    }

  ++*pp;

  success = get_number_from_pp(pp, &typenums[0], p_end, orig);
  if (!success) {
      return false;
  }

  if (*pp >= p_end || **pp != ',')
    {
      bad_stab(orig);
      return false;
    }

  ++*pp;

  success = get_number_from_pp(pp, &typenums[1], p_end, orig);
  if (!success) {
      return false;
  }

  if (*pp >= p_end || **pp != ')')
    {
      bad_stab(orig);
      return false;
    }

  ++*pp;
  return true;
}

/* Parse a range type.  */

static debug_type
parse_stab_range_type (void *                dhandle,
		       struct stab_handle *  info,
		       const char *          type_name,
		       const char **         pp,
		       const int *           typenums,
		       const char *          p_end)
{
  const char *orig;
  int rangenums[2];
  bool self_subrange;
  debug_type index_type;
  const char *s2, *s3;
  bfd_signed_vma n2, n3;
  bool ov2, ov3;

  orig = *pp;
  if (orig >= p_end)
    return DEBUG_TYPE_NULL;

  index_type = DEBUG_TYPE_NULL;

  if (! parse_stab_type_number (pp, rangenums, p_end))
    return DEBUG_TYPE_NULL;

  self_subrange = (rangenums[0] == typenums[0]
		   && rangenums[1] == typenums[1]);

  if (**pp == '=')
    {
      *pp = orig;
      index_type = parse_stab_type (dhandle, info, (const char *) NULL,
				    pp, (debug_type **) NULL, p_end);
      if (index_type == DEBUG_TYPE_NULL)
	return DEBUG_TYPE_NULL;
    }

  if (**pp == ';')
    ++*pp;

  s2 = *pp;
  n2 = parse_number (pp, &ov2, p_end);
  if (**pp != ';')
    {
      bad_stab (orig);
      return DEBUG_TYPE_NULL;
    }
  ++*pp;

  s3 = *pp;
  n3 = parse_number (pp, &ov3, p_end);
  if (**pp != ';')
    {
      bad_stab (orig);
      return DEBUG_TYPE_NULL;
    }
  ++*pp;

  if (ov2 || ov3)
    {
      if (index_type == DEBUG_TYPE_NULL)
	{
          static const char LLLOW_STR[] = "01000000000000000000000;";
          static const char LLHIGH_STR[] = "0777777777777777777777;";
          static const char ULLHIGH_STR[] = "01777777777777777777777;";

	  if (startswith (s2, LLLOW_STR)
	      && startswith (s3, LLHIGH_STR))
	    return debug_make_int_type (dhandle, 8, false);
	  if (! ov2
	      && n2 == 0
	      && startswith (s3, ULLHIGH_STR))
	    return debug_make_int_type (dhandle, 8, true);
	}
      warn_stab (orig, _("numeric overflow"));
    }

  if (index_type == DEBUG_TYPE_NULL)
    {
      if (self_subrange)
	{
	  if (n2 == 0 && n3 == 0)
	    return debug_make_void_type (dhandle);
	  if (n3 == 0 && n2 > 0)
	    return debug_make_complex_type (dhandle, n2);
	  if (n2 == 0 && n3 == 127)
	    return debug_make_int_type (dhandle, 1, false);
	}

      if (n3 == 0 && n2 > 0)
	return debug_make_float_type (dhandle, n2);

      if (n2 == 0 && n3 == -1)
	{
	  if (type_name != NULL)
	    {
	      if (strcmp (type_name, "long long int") == 0)
		return debug_make_int_type (dhandle, 8, false);
	      else if (strcmp (type_name, "long long unsigned int") == 0)
		return debug_make_int_type (dhandle, 8, true);
	    }
	  return debug_make_int_type (dhandle, 4, true);
	}

      if (n2 == 0)
	{
	  if (n3 < 0)
	    return debug_make_int_type (dhandle, - n3, true);
	  if (n3 == 0xff)
	    return debug_make_int_type (dhandle, 1, true);
	  if (n3 == 0xffff)
	    return debug_make_int_type (dhandle, 2, true);
	  if (n3 == (bfd_signed_vma) 0xffffffff)
	    return debug_make_int_type (dhandle, 4, true);
#ifdef BFD64
	  if (n3 == (bfd_signed_vma) 0xffffffffffffffffLL)
	    return debug_make_int_type (dhandle, 8, true);
#endif
	}
      else if (n3 == 0
	       && n2 < 0
	       && (self_subrange || n2 == -8))
	{
	  return debug_make_int_type (dhandle, - n2, true);
	}
      else if (n2 == - n3 - 1 || n2 == n3 + 1)
	{
	  if (n3 == 0x7f)
	    return debug_make_int_type (dhandle, 1, false);
	  if (n3 == 0x7fff)
	    return debug_make_int_type (dhandle, 2, false);
	  if (n3 == 0x7fffffff)
	    return debug_make_int_type (dhandle, 4, false);
#ifdef BFD64
	  if (n3 == ((((bfd_vma) 0x7fffffff) << 32) | 0xffffffff))
	    return debug_make_int_type (dhandle, 8, false);
#endif
	}
    }

  if (index_type == DEBUG_TYPE_NULL && self_subrange)
    {
      bad_stab (orig);
      return DEBUG_TYPE_NULL;
    }

  if (index_type == DEBUG_TYPE_NULL)
    {
      index_type = stab_find_type (dhandle, info, rangenums);
      if (index_type == DEBUG_TYPE_NULL)
	{
	  warn_stab (orig, _("missing index type"));
	  index_type = debug_make_int_type (dhandle, 4, false);
	}
    }

  return debug_make_range_type (dhandle, index_type, n2, n3);
}

/* Sun's ACC uses a somewhat saner method for specifying the builtin
   typedefs in every file (for int, long, etc):

	type = b <signed> <width>; <offset>; <nbits>
	signed = u or s.  Possible c in addition to u or s (for char?).
	offset = offset from high order bit to start bit of type.
	width is # bytes in object of this type, nbits is # bits in type.

   The width/offset stuff appears to be for small objects stored in
   larger ones (e.g. `shorts' in `int' registers).  We ignore it for now,
   FIXME.  */

static debug_type
parse_stab_sun_builtin_type (void *dhandle, const char **pp, const char * p_end)
{
  const char *orig = *pp;
  bool unsignedp;
  bfd_vma bits;

  if (*pp >= p_end)
    return DEBUG_TYPE_NULL;

  switch (**pp)
    {
    case 's':
      unsignedp = false;
      break;
    case 'u':
      unsignedp = true;
      break;
    default:
      bad_stab (orig);
      return DEBUG_TYPE_NULL;
    }
  ++*pp;

  if (*pp < p_end && (**pp == 'c' || **pp == 'b' || **pp == 'v'))
    ++*pp;

  (void) parse_number (pp, (bool *) NULL, p_end);
  if (*pp >= p_end || **pp != ';')
    {
      bad_stab (orig);
      return DEBUG_TYPE_NULL;
    }
  ++*pp;

  (void) parse_number (pp, (bool *) NULL, p_end);
  if (*pp >= p_end || **pp != ';')
    {
      bad_stab (orig);
      return DEBUG_TYPE_NULL;
    }
  ++*pp;

  bits = parse_number (pp, (bool *) NULL, p_end);

  if (*pp < p_end && **pp == ';')
    ++*pp;

  if (bits == 0)
    return debug_make_void_type (dhandle);

  return debug_make_int_type (dhandle, bits / 8, unsignedp);
}

/* Parse a builtin floating type generated by the Sun compiler.  */

static bool
parse_vma_and_expect_semicolon(const char **pp, const char *p_end, bfd_vma *out_vma, const char *stab_start_for_error_report)
{
  const char *pre_parse_pp = *pp;

  *out_vma = parse_number(pp, (bool *) NULL, p_end);

  if (*pp == pre_parse_pp)
    {
      bad_stab(stab_start_for_error_report);
      return false;
    }

  if (*pp >= p_end || **pp != ';')
    {
      bad_stab(stab_start_for_error_report);
      return false;
    }

  (*pp)++;
  return true;
}

static debug_type
parse_stab_sun_floating_type (void *dhandle, const char **pp, const char *p_end)
{
  const char *orig_start = *pp;
  bfd_vma details;
  bfd_vma bytes;

  if (orig_start >= p_end)
    return DEBUG_TYPE_NULL;

  if (!parse_vma_and_expect_semicolon(pp, p_end, &details, orig_start))
    return DEBUG_TYPE_NULL;

  if (!parse_vma_and_expect_semicolon(pp, p_end, &bytes, orig_start))
    return DEBUG_TYPE_NULL;

  if (details == NF_COMPLEX
      || details == NF_COMPLEX16
      || details == NF_COMPLEX32)
    return debug_make_complex_type (dhandle, bytes);
  else
    return debug_make_float_type (dhandle, bytes);
}

/* Handle an enum type.  */

static debug_type
parse_stab_enum_type (void *dhandle, const char **pp, const char * p_end)
{
  const char *orig_stab_start = *pp; // Store original pointer for error reporting
  const char **names = NULL;
  bfd_signed_vma *values = NULL;
  unsigned int current_count = 0;
  unsigned int allocated_size = 0; // Number of slots allocated

  // Constants for allocation sizes to improve maintainability and readability.
  enum { ENUM_INITIAL_ALLOCATION_COUNT = 10 };
  enum { ENUM_ALLOCATION_INCREMENT = 10 };

  if (*pp >= p_end)
    return DEBUG_TYPE_NULL;

  /* The aix4 compiler emits an extra field before the enum members;
     my guess is it's a type of some sort. Just ignore it. */
  if (**pp == '-')
    {
      while (*pp < p_end && **pp != ':' && **pp != '\0')
	++*pp;

      if (*pp >= p_end || **pp == '\0')
	{
	  // Reached end of buffer or string without finding a colon for the Aix4 field.
	  bad_stab (orig_stab_start);
	  return DEBUG_TYPE_NULL;
	}
      ++*pp; // Skip the colon
    }

  allocated_size = ENUM_INITIAL_ALLOCATION_COUNT;
  names = xmalloc (allocated_size * sizeof (*names));
  values = xmalloc (allocated_size * sizeof (*values));

  /* Read the value-names and their values.
     The input syntax is NAME:VALUE,NAME:VALUE, and so on.
     A semicolon or null terminator means the end. */
  for (;;) // Loop to parse multiple NAME:VALUE pairs
    {
      const char *p_name_start;
      const char *p_colon_pos;
      char *name_str;
      bfd_signed_vma value_num;

      // Check for termination conditions before attempting to parse a name.
      if (*pp >= p_end || **pp == '\0' || **pp == ';')
	break; // No more items or end of list delimiter found

      p_name_start = *pp;
      p_colon_pos = p_name_start;

      // Find the colon separating name and value.
      while (p_colon_pos < p_end && *p_colon_pos != ':' && *p_colon_pos != '\0')
	++p_colon_pos;

      // Error if no colon, or empty name, or reached end of buffer without colon.
      if (p_colon_pos >= p_end || *p_colon_pos == '\0' || p_colon_pos == *pp)
        {
          bad_stab (orig_stab_start);
          goto cleanup_and_fail;
        }

      name_str = savestring (dhandle, *pp, p_colon_pos - *pp);
      *pp = p_colon_pos + 1; // Advance past the name and the colon

      // Parse the numeric value.
      if (*pp >= p_end) // Must have a value after the colon.
        {
          bad_stab (orig_stab_start);
          goto cleanup_and_fail;
        }
      // parse_number updates *pp to point after the number.
      value_num = (bfd_signed_vma) parse_number (pp, (bool *) NULL, p_end);

      // Ensure enough space for the current item and a future sentinel (current_count + 1).
      if (current_count + 1 >= allocated_size)
        {
          allocated_size += ENUM_ALLOCATION_INCREMENT;
          names = xrealloc (names, allocated_size * sizeof (*names));
          values = xrealloc (values, allocated_size * sizeof (*values));
        }

      names[current_count] = name_str;
      values[current_count] = value_num;
      ++current_count;

      // Check what follows the value: comma (for next item), semicolon, or end of string.
      if (*pp >= p_end || **pp == '\0' || **pp == ';')
        {
          // Reached end of input, null terminator, or semicolon. This marks the end of the list.
          break;
        }
      else if (**pp == ',')
        {
          // Found a comma, skip it and continue the loop for the next item.
          ++*pp;
        }
      else
        {
          // Unexpected character after a value.
          bad_stab (orig_stab_start);
          goto cleanup_and_fail;
        }
    }

  // Add sentinel NULL/0 to the end of the lists.
  // The allocation logic ensures `allocated_size` is always `>= current_count + 1`.
  names[current_count] = NULL;
  values[current_count] = 0;

  // Allocate final arrays via debug_xalloc which likely transfers ownership/uses a different allocator.
  // CRITICAL FIX: Use sizeof(*values) for the values array.
  const char **xnames = debug_xalloc (dhandle, (current_count + 1) * sizeof (*names));
  memcpy (xnames, names, (current_count + 1) * sizeof (*names));
  free (names);

  bfd_signed_vma *xvalues = debug_xalloc (dhandle, (current_count + 1) * sizeof (*values));
  memcpy (xvalues, values, (current_count + 1) * sizeof (*values));
  free (values);

  // Skip a trailing semicolon if present after the enum definition.
  if (*pp < p_end && **pp == ';')
    ++*pp;

  return debug_make_enum_type (dhandle, xnames, xvalues);

cleanup_and_fail:
  free (names);
  free (values);
  return DEBUG_TYPE_NULL;
}

/* Read the description of a structure (or union type) and return an object
   describing the type.

   PP points to a character pointer that points to the next unconsumed token
   in the stabs string.  For example, given stabs "A:T4=s4a:1,0,32;;",
   *PP will point to "4a:1,0,32;;".  */

static debug_type
parse_stab_struct_type (void *dhandle,
			struct stab_handle *info,
			const char *tagname,
			const char **pp,
			bool structp,
			const int *typenums,
			const char *p_end)
{
  bfd_vma size;
  debug_baseclass *baseclasses = NULL;
  debug_field *fields = NULL;
  bool statics = false;
  debug_method *methods = NULL;
  debug_type vptrbase = DEBUG_TYPE_NULL;
  bool ownvptr = false;

  size = parse_number (pp, (bool *) NULL, p_end);

  if (! parse_stab_baseclasses (dhandle, info, pp, &baseclasses, p_end)
      || ! parse_stab_struct_fields (dhandle, info, pp, &fields, &statics, p_end)
      || ! parse_stab_members (dhandle, info, tagname, pp, typenums, &methods, p_end)
      || ! parse_stab_tilde_field (dhandle, info, pp, typenums, &vptrbase,
				   &ownvptr, p_end))
    {
      return DEBUG_TYPE_NULL;
    }

  if (! statics
      && baseclasses == NULL
      && methods == NULL
      && vptrbase == DEBUG_TYPE_NULL
      && ! ownvptr)
    {
      return debug_make_struct_type (dhandle, structp, size, fields);
    }
  else
    {
      return debug_make_object_type (dhandle, structp, size, fields, baseclasses,
				     methods, vptrbase, ownvptr);
    }
}

/* The stabs for C++ derived classes contain baseclass information which
   is marked by a '!' character after the total size.  This function is
   called when we encounter the baseclass marker, and slurps up all the
   baseclass information.

   Immediately following the '!' marker is the number of base classes that
   the class is derived from, followed by information for each base class.
   For each base class, there are two visibility specifiers, a bit offset
   to the base class information within the derived class, a reference to
   the type for the base class, and a terminating semicolon.

   A typical example, with two base classes, would be "!2,020,19;0264,21;".
						       ^^ ^ ^ ^  ^ ^  ^
	Baseclass information marker __________________|| | | |  | |  |
	Number of baseclasses __________________________| | | |  | |  |
	Visibility specifiers (2) ________________________| | |  | |  |
	Offset in bits from start of class _________________| |  | |  |
	Type number for base class ___________________________|  | |  |
	Visibility specifiers (2) _______________________________| |  |
	Offset in bits from start of class ________________________|  |
	Type number of base class ____________________________________|

  Return TRUE for success, FALSE for failure.  */

static char
get_and_advance_char (const char **pp, const char *p_end, const char *orig_error_pos)
{
  if (*pp >= p_end)
    {
      bad_stab (orig_error_pos);
      return 0;
    }
  char c = **pp;
  ++*pp;
  return c;
}

static bool
expect_and_advance_char (const char **pp, const char *p_end, char expected_char, const char *orig_error_pos)
{
  if (*pp >= p_end)
    {
      bad_stab (orig_error_pos);
      return false;
    }
  if (**pp != expected_char)
    {
      bad_stab (orig_error_pos);
      return false;
    }
  ++*pp;
  return true;
}

static bool
parse_stab_baseclasses (void *                dhandle,
			struct stab_handle *  info,
			const char **         pp,
			debug_baseclass **    retp,
			const char *          p_end)
{
  const char *orig;
  unsigned int c, i;
  debug_baseclass *classes;
  char current_char_val;

  *retp = NULL;
  orig = *pp;

  if (*pp >= p_end)
    {
      return true;
    }

  if (**pp != '!')
    {
      return true;
    }

  if (!expect_and_advance_char (pp, p_end, '!', orig))
    return false;

  c = (unsigned int) parse_number (pp, (bool *) NULL, p_end);

  if (!expect_and_advance_char (pp, p_end, ',', orig))
    return false;

  classes = debug_xalloc (dhandle, (c + 1) * sizeof (*classes));

  for (i = 0; i < c; i++)
    {
      bool is_virtual;
      enum debug_visibility visibility;
      bfd_vma bitpos;
      debug_type type;

      current_char_val = get_and_advance_char (pp, p_end, orig);
      if (current_char_val == 0)
        return false;

      switch (current_char_val)
	{
	case '0':
	  is_virtual = false;
	  break;
	case '1':
	  is_virtual = true;
	  break;
	default:
	  warn_stab (orig, _("unknown virtual character for baseclass"));
	  is_virtual = false;
	  break;
	}

      current_char_val = get_and_advance_char (pp, p_end, orig);
      if (current_char_val == 0)
        return false;

      switch (current_char_val)
	{
	case '0':
	  visibility = DEBUG_VISIBILITY_PRIVATE;
	  break;
	case '1':
	  visibility = DEBUG_VISIBILITY_PROTECTED;
	  break;
	case '2':
	  visibility = DEBUG_VISIBILITY_PUBLIC;
	  break;
	default:
	  warn_stab (orig, _("unknown visibility character for baseclass"));
	  visibility = DEBUG_VISIBILITY_PUBLIC;
	  break;
	}

      bitpos = parse_number (pp, (bool *) NULL, p_end);
      if (!expect_and_advance_char (pp, p_end, ',', orig))
        return false;

      type = parse_stab_type (dhandle, info, (const char *) NULL, pp,
			      (debug_type **) NULL, p_end);
      if (type == DEBUG_TYPE_NULL)
	return false;

      classes[i] = debug_make_baseclass (dhandle, type, bitpos, is_virtual,
					 visibility);
      if (classes[i] == DEBUG_BASECLASS_NULL)
	return false;

      if (!expect_and_advance_char (pp, p_end, ';', orig))
        return false;
    }

  classes[c] = DEBUG_BASECLASS_NULL;

  *retp = classes;

  return true;
}

/* Read struct or class data fields.  They have the form:

	NAME : [VISIBILITY] TYPENUM , BITPOS , BITSIZE ;

   At the end, we see a semicolon instead of a field.

   In C++, this may wind up being NAME:?TYPENUM:PHYSNAME; for
   a static field.

   The optional VISIBILITY is one of:

	'/0'	(VISIBILITY_PRIVATE)
	'/1'	(VISIBILITY_PROTECTED)
	'/2'	(VISIBILITY_PUBLIC)
	'/9'	(VISIBILITY_IGNORE)

   or nothing, for C style fields with public visibility.

   Returns 1 for success, 0 for failure.  */

static bool
parse_stab_struct_fields (void *dhandle,
			  struct stab_handle *info,
			  const char **pp,
			  debug_field **retp,
			  bool *staticsp,
			  const char * p_end)
{
  const char *orig_start = *pp;
  const char *p;
  debug_field *fields = NULL;
  unsigned int count = 0;
  unsigned int allocated_size = 0;
  bool success = false;

  enum {
    INITIAL_FIELD_ALLOCATION = 10,
    FIELD_ALLOCATION_INCREMENT = 10
  };

  *retp = NULL;
  *staticsp = false;

  if (orig_start >= p_end)
    return false;

  allocated_size = INITIAL_FIELD_ALLOCATION;
  fields = xmalloc (allocated_size * sizeof (*fields));

  while (**pp != ';')
    {
      p = *pp;

      if (count + 1 >= allocated_size)
	{
	  allocated_size += FIELD_ALLOCATION_INCREMENT;
	  fields = xrealloc (fields, allocated_size * sizeof (*fields));
	}

      if ((*p == '$' || *p == '.') && p[1] != '_')
	{
	  ++*pp;
	  if (! parse_stab_cpp_abbrev (dhandle, info, pp, fields + count, p_end))
	    goto cleanup;
	  ++count;
	  continue;
	}

      p = strchr (p, ':');
      if (p == NULL)
	{
	  bad_stab (orig_start);
	  goto cleanup;
	}

      if (p[1] == ':')
	break;

      if (! parse_stab_one_struct_field (dhandle, info, pp, p, fields + count,
					 staticsp, p_end))
	goto cleanup;

      ++count;
    }

  fields[count] = DEBUG_FIELD_NULL;
  debug_field *final_fields = debug_xalloc (dhandle, (count + 1) * sizeof (*fields));
  memcpy (final_fields, fields, (count + 1) * sizeof (*fields));
  *retp = final_fields;

  success = true;

cleanup:
  if (fields != NULL)
    free (fields);

  return success;
}

/* Special GNU C++ name.  */

static inline bool
consume_char_and_advance(const char **pp, const char *p_end, char expected_char, const char *error_origin_ptr)
{
  if (*pp >= p_end || **pp != expected_char)
    {
      bad_stab(error_origin_ptr);
      return false;
    }
  ++*pp;
  return true;
}

static bool
parse_stab_cpp_abbrev (void *                dhandle,
		       struct stab_handle *  info,
		       const char **         pp,
		       debug_field *         retp,
		       const char *          p_end)
{
  const char *orig = *pp;
  int cpp_abbrev_char;
  debug_type context_type;
  const char *field_name = NULL;
  debug_type field_type;
  bfd_vma bit_position;

  *retp = DEBUG_FIELD_NULL;

  if (*pp >= p_end)
    {
      bad_stab(orig);
      return false;
    }

  if (!consume_char_and_advance(pp, p_end, 'v', orig))
    return false;

  if (*pp >= p_end)
    {
      bad_stab(orig);
      return false;
    }
  cpp_abbrev_char = **pp;
  if (cpp_abbrev_char == 0)
    {
      bad_stab(orig);
      return false;
    }
  ++*pp;

  context_type = parse_stab_type (dhandle, info, NULL, pp, NULL, p_end);
  if (context_type == DEBUG_TYPE_NULL)
    return false;

  switch (cpp_abbrev_char)
    {
    case 'f':
      field_name = "_vptr$";
      break;
    case 'b':
      {
        const char *type_name_str = debug_get_type_name (dhandle, context_type);
        if (type_name_str == NULL)
          {
            warn_stab (orig, _("unnamed $vb type"));
            type_name_str = "FOO";
          }
        size_t type_name_len = strlen (type_name_str);
        const char *prefix_str = "_vb$";
        size_t prefix_len = strlen(prefix_str);
        char *allocated_name = debug_xalloc (dhandle, prefix_len + type_name_len + 1);
        if (allocated_name == NULL)
          return false;
        memcpy (allocated_name, prefix_str, prefix_len);
        memcpy (allocated_name + prefix_len, type_name_str, type_name_len + 1);
        field_name = allocated_name;
      }
      break;
    default:
      warn_stab (orig, _("unrecognized C++ abbreviation"));
      field_name = "INVALID_CPLUSPLUS_ABBREV";
      break;
    }

  if (!consume_char_and_advance(pp, p_end, ':', orig))
    return false;

  field_type = parse_stab_type (dhandle, info, NULL, pp, NULL, p_end);
  if (field_type == DEBUG_TYPE_NULL)
    return false;

  if (!consume_char_and_advance(pp, p_end, ',', orig))
    return false;

  bit_position = parse_number (pp, NULL, p_end);

  if (!consume_char_and_advance(pp, p_end, ';', orig))
    return false;

  *retp = debug_make_field (dhandle, field_name, field_type, bit_position, 0,
                            DEBUG_VISIBILITY_PRIVATE);
  if (*retp == DEBUG_FIELD_NULL)
    return false;

  return true;
}

/* Parse a single field in a struct or union.  */

static bool
parse_stab_one_struct_field (void *dhandle,
                             struct stab_handle *info,
                             const char **pp,
                             const char *name_boundary_ptr,
                             debug_field *retp,
                             bool *staticsp,
                             const char *p_end)
{
  const char *field_start_ptr = *pp;
  char *name = NULL;
  enum debug_visibility visibility = DEBUG_VISIBILITY_PUBLIC;
  debug_type type = DEBUG_TYPE_NULL;
  bfd_vma bitpos = 0;
  bfd_vma bitsize = 0;

  // Basic sanity checks: ensure parsing pointer is within bounds and name_boundary_ptr is valid.
  if (field_start_ptr >= p_end || name_boundary_ptr > p_end || field_start_ptr > name_boundary_ptr)
    {
      bad_stab (field_start_ptr);
      return false;
    }

  // Parse field name. name_boundary_ptr points to the character *after* the name.
  name = savestring (dhandle, field_start_ptr, name_boundary_ptr - field_start_ptr);
  if (name == NULL)
    {
      // Assume savestring handles allocation errors or dhandle ensures memory.
      // If it can fail, this path should be explicitly handled (e.g., freeing resources).
      return false;
    }

  // Advance current parsing pointer past the name and the character immediately after it.
  *pp = name_boundary_ptr + 1;

  // Ensure *pp is within bounds after skipping the name and its separator.
  if (*pp >= p_end)
    {
      bad_stab (field_start_ptr);
      return false;
    }

  // Parse visibility
  if (**pp == '/')
    {
      ++*pp; // Skip '/'
      if (*pp >= p_end) // Check after increment to prevent reading past p_end
        {
          bad_stab (field_start_ptr);
          return false;
        }

      switch (**pp)
        {
        case '0':
          visibility = DEBUG_VISIBILITY_PRIVATE;
          break;
        case '1':
          visibility = DEBUG_VISIBILITY_PROTECTED;
          break;
        case '2':
          visibility = DEBUG_VISIBILITY_PUBLIC;
          break;
        case '\0': // Null terminator indicates malformed string prematurely
          bad_stab (field_start_ptr);
          return false;
        default:
          warn_stab (field_start_ptr, _("unknown visibility character for field"));
          // Default visibility (PUBLIC) is already set.
          break;
        }
      ++*pp; // Skip visibility char
    }

  // Ensure *pp is within bounds after visibility parsing, before parsing type.
  if (*pp >= p_end)
    {
      bad_stab (field_start_ptr);
      return false;
    }

  // Parse field type. parse_stab_type advances *pp internally.
  type = parse_stab_type (dhandle, info, NULL, pp, NULL, p_end);
  if (type == DEBUG_TYPE_NULL)
    {
      // parse_stab_type is expected to handle its own errors and return DEBUG_TYPE_NULL on failure.
      return false;
    }

  // Ensure *pp is within bounds after type parsing, before checking for static member.
  if (*pp >= p_end)
    {
      bad_stab (field_start_ptr);
      return false;
    }

  // Check if it's a static class member (indicated by ':')
  if (**pp == ':')
    {
      char *varname = NULL;
      const char *static_varname_start_ptr = NULL;
      const char *static_varname_end_ptr = NULL;

      ++*pp; // Skip ':'
      if (*pp >= p_end) // Check after increment
        {
          bad_stab (field_start_ptr);
          return false;
        }

      static_varname_start_ptr = *pp;
      static_varname_end_ptr = strchr (*pp, ';');
      if (static_varname_end_ptr == NULL || static_varname_end_ptr >= p_end)
        {
          bad_stab (field_start_ptr);
          return false;
        }

      varname = savestring (dhandle, static_varname_start_ptr,
                            static_varname_end_ptr - static_varname_start_ptr);
      if (varname == NULL)
        {
          return false; // Memory allocation error for varname
        }

      *pp = static_varname_end_ptr + 1; // Advance past varname and ';'

      *retp = debug_make_static_member (dhandle, name, type, varname, visibility);
      *staticsp = true;

      return true;
    }

  // If not static, it must be a non-static member.
  // Expect ',' to precede bitpos/bitsize.
  if (**pp != ',')
    {
      bad_stab (field_start_ptr);
      return false;
    }
  ++*pp; // Skip ','

  // Ensure *pp is within bounds before parsing bitpos.
  if (*pp >= p_end)
    {
        bad_stab(field_start_ptr);
        return false;
    }
  // Parse bitpos. parse_number advances *pp.
  bitpos = parse_number (pp, NULL, p_end);

  // Ensure *pp is within bounds and the next character is ',' to precede bitsize.
  if (*pp >= p_end || **pp != ',')
    {
      bad_stab (field_start_ptr);
      return false;
    }
  ++*pp; // Skip ','

  // Ensure *pp is within bounds before parsing bitsize.
  if (*pp >= p_end)
    {
        bad_stab(field_start_ptr);
        return false;
    }
  // Parse bitsize. parse_number advances *pp.
  bitsize = parse_number (pp, NULL, p_end);

  // Ensure *pp is within bounds and the next character is ';' to terminate the field.
  if (*pp >= p_end || **pp != ';')
    {
      bad_stab (field_start_ptr);
      return false;
    }
  ++*pp; // Skip ';'

  // Handle optimized-out or 0-size array fields by setting visibility to ignore.
  if (bitpos == 0 && bitsize == 0)
    {
      visibility = DEBUG_VISIBILITY_IGNORE;
    }

  *retp = debug_make_field (dhandle, name, type, bitpos, bitsize, visibility);
  *staticsp = false; // Explicitly set for non-static fields

  return true;
}

/* Read member function stabs info for C++ classes.  The form of each member
   function data is:

	NAME :: TYPENUM[=type definition] ARGS : PHYSNAME ;

   An example with two member functions is:

	afunc1::20=##15;:i;2A.;afunc2::20:i;2A.;

   For the case of overloaded operators, the format is op$::*.funcs, where
   $ is the CPLUS_MARKER (usually '$'), `*' holds the place for an operator
   name (such as `+=') and `.' marks the end of the operator name.  */

static bool
resize_array(void **array_ptr, unsigned int *current_count, unsigned int *alloc_size, size_t element_size) {
    if (*current_count + 1 >= *alloc_size) {
        unsigned int new_alloc_size = (*alloc_size == 0) ? 10 : *alloc_size * 2;
        void *new_array = xrealloc(*array_ptr, new_alloc_size * element_size);
        if (new_array == NULL) {
            return false; // xrealloc failed
        }
        *array_ptr = new_array;
        *alloc_size = new_alloc_size;
    }
    return true;
}

static void *
commit_to_dhandle_allocator(void *dhandle, void *temp_array, unsigned int count, size_t element_size) {
    if (temp_array == NULL || count == 0) {
        if (temp_array != NULL) { // Free if array was allocated but empty
            free(temp_array);
        }
        return NULL;
    }
    void *dhandle_array = debug_xalloc(dhandle, count * element_size);
    if (dhandle_array == NULL) {
        free(temp_array); // If dhandle alloc fails, free temporary memory
        return NULL;
    }
    memcpy(dhandle_array, temp_array, count * element_size);
    free(temp_array); // Temporary memory is now committed and freed
    return dhandle_array;
}

static bool
parse_stab_members (void *                dhandle,
		    struct stab_handle *  info,
		    const char *          tagname,
		    const char **         pp,
		    const int *           typenums,
		    debug_method **       retp,
		    const char *          p_end)
{
  const char *orig = *pp;
  debug_method *methods = NULL;
  unsigned int method_count = 0;
  unsigned int method_alloc_size = 0;

  char *method_name_current = NULL; // Assumed dhandle-allocated by savestring
  char *argtypes_str_current = NULL; // Assumed dhandle-allocated by savestring

  debug_method_variant *variants_temp = NULL; // Temporary array for current method's variants
  unsigned int variant_count = 0;
  unsigned int variant_alloc_size = 0;

  *retp = NULL;

  if (orig >= p_end) {
    return false;
  }

  bool overall_parsing_successful = true;

  // Main loop: Parse each method
  while (**pp != ';' && *pp < p_end)
    {
      const char *p_colon = strchr(*pp, ':');
      if (p_colon == NULL || p_colon[1] != ':') {
        // This is the expected end of the method list or a malformed entry.
        // If malformed, bad_stab should be called; if end, break.
        // Original logic breaks, suggesting it's a valid end.
        break;
      }

      // --- Parse Method Name ---
      if ((*pp)[0] != 'o' || (*pp)[1] != 'p' || (*pp)[2] != '$') {
        method_name_current = savestring(dhandle, *pp, p_colon - *pp);
        *pp = p_colon + 2;
      } else {
        *pp = p_colon + 2; // Skip "op$::"
        const char *p_dot = *pp;
        while (p_dot < p_end && *p_dot != '.' && *p_dot != '\0') {
          p_dot++;
        }
        if (p_dot >= p_end || *p_dot != '.') {
          bad_stab(orig);
          overall_parsing_successful = false;
          break;
        }
        method_name_current = savestring(dhandle, *pp, p_dot - *pp);
        *pp = p_dot + 1;
      }

      if (method_name_current == NULL) { // savestring may return NULL on allocation failure
        overall_parsing_successful = false;
        break;
      }

      // --- Initialize for Variants (for current method) ---
      variant_count = 0;
      variant_alloc_size = 0;
      free(variants_temp); // Free variants_temp from previous method, if any.
      variants_temp = NULL; // Will be reallocated on first use in inner loop.

      debug_type look_ahead_type = DEBUG_TYPE_NULL;
      bool current_method_variant_parsing_successful = true;

      // Inner loop: Parse each variant of the current method
      do
        {
          debug_type current_type;
          enum debug_visibility visibility = DEBUG_VISIBILITY_PUBLIC; // Default to public
          bool const_qualifier = false;
          bool volatile_qualifier = false;
          bool static_specifier = false;
          bfd_vma voffset = 0;
          debug_type context = DEBUG_TYPE_NULL;
          const char *physical_name = NULL;
          bool varargs = false;

          if (look_ahead_type != DEBUG_TYPE_NULL) {
            current_type = look_ahead_type;
            look_ahead_type = DEBUG_TYPE_NULL;
          } else {
            current_type = parse_stab_type(dhandle, info, NULL, pp, NULL, p_end);
            if (current_type == DEBUG_TYPE_NULL) {
              current_method_variant_parsing_successful = false;
              break;
            }
            if (*pp >= p_end || **pp != ':') {
              bad_stab(orig);
              current_method_variant_parsing_successful = false;
              break;
            }
          }

          ++*pp; // Skip ':'
          if (*pp >= p_end) { bad_stab(orig); current_method_variant_parsing_successful = false; break; }

          const char *p_semicolon = strchr(*pp, ';');
          if (p_semicolon == NULL || p_semicolon >= p_end) {
            bad_stab(orig);
            current_method_variant_parsing_successful = false;
            break;
          }

          bool is_stub = (debug_get_type_kind(dhandle, current_type) == DEBUG_KIND_METHOD &&
                          debug_get_parameter_types(dhandle, current_type, &varargs) == NULL);

          argtypes_str_current = savestring(dhandle, *pp, p_semicolon - *pp);
          if (argtypes_str_current == NULL) {
            current_method_variant_parsing_successful = false;
            break;
          }
          *pp = p_semicolon + 1;
          if (*pp >= p_end) { bad_stab(orig); current_method_variant_parsing_successful = false; break; }

          // --- Parse Visibility ---
          switch (**pp) {
            case '0': visibility = DEBUG_VISIBILITY_PRIVATE;   break;
            case '1': visibility = DEBUG_VISIBILITY_PROTECTED; break;
            case '\0': bad_stab(orig); current_method_variant_parsing_successful = false; break;
            default:  /* DEBUG_VISIBILITY_PUBLIC (default) */ break;
          }
          if (!current_method_variant_parsing_successful) break;
          ++*pp;
          if (*pp >= p_end) { bad_stab(orig); current_method_variant_parsing_successful = false; break; }

          // --- Parse Const/Volatile Qualifiers ---
          switch (**pp) {
            case 'A': /* Normal */                             break;
            case 'B': const_qualifier = true;                 break;
            case 'C': volatile_qualifier = true;              break;
            case 'D': const_qualifier = true; volatile_qualifier = true; break;
            case '*': case '?': case '.': /* g++ v1 no info */ break;
            default: warn_stab(orig, _("const/volatile indicator missing")); break;
          }
          ++*pp;
          if (*pp >= p_end) { bad_stab(orig); current_method_variant_parsing_successful = false; break; }

          // --- Parse Static/Virtual Specifier ---
          switch (**pp) {
            case '*': // Virtual
              ++*pp;
              voffset = parse_number(pp, NULL, p_end);
              if (*pp >= p_end || **pp != ';') {
                bad_stab(orig);
                current_method_variant_parsing_successful = false;
                break;
              }
              ++*pp;
              if (*pp >= p_end) { bad_stab(orig); current_method_variant_parsing_successful = false; break; }
              voffset &= 0x7fffffff; // Clear sign bit

              if (*pp >= p_end || **pp == ';' || **pp == '\0') {
                context = DEBUG_TYPE_NULL; // Must be g++ version 1
              } else {
                look_ahead_type = parse_stab_type(dhandle, info, NULL, pp, NULL, p_end);
                if (look_ahead_type == DEBUG_TYPE_NULL) {
                  current_method_variant_parsing_successful = false;
                  break;
                }
                if (*pp >= p_end) { bad_stab(orig); current_method_variant_parsing_successful = false; break; }
                if (**pp == ':') { // g++ version 1 overloaded methods
                  context = DEBUG_TYPE_NULL;
                } else {
                  context = look_ahead_type;
                  look_ahead_type = DEBUG_TYPE_NULL; // Consumed
                  if (*pp >= p_end || **pp != ';') {
                    bad_stab(orig);
                    current_method_variant_parsing_successful = false;
                    break;
                  }
                  ++*pp;
                  if (*pp >= p_end) { bad_stab(orig); current_method_variant_parsing_successful = false; break; }
                }
              }
              break;

            case '?': // Static
              ++*pp;
              static_specifier = true;
              voffset = 0;
              context = DEBUG_TYPE_NULL;
              // Original code: if (strncmp (argtypes, name, strlen (name)) != 0) stub = true;
              if (method_name_current && argtypes_str_current &&
                  strlen(method_name_current) <= strlen(argtypes_str_current) && // Avoid out-of-bounds
                  strncmp(argtypes_str_current, method_name_current, strlen(method_name_current)) != 0) {
                  is_stub = true;
              }
              break;

            case '.': // Normal, non-virtual, non-static
              ++*pp;
              voffset = 0;
              context = DEBUG_TYPE_NULL;
              break;

            default: // Missing type
              warn_stab(orig, "member function type missing");
              voffset = 0;
              context = DEBUG_TYPE_NULL;
              break;
          }
          if (!current_method_variant_parsing_successful) break;

          // --- Determine Physical Name & Refine Type for Stubs ---
          physical_name = argtypes_str_current; // Default physical name
          if (is_stub) {
            debug_type class_type, return_type;

            class_type = stab_find_type(dhandle, info, typenums);
            if (class_type == DEBUG_TYPE_NULL) {
              current_method_variant_parsing_successful = false;
              break;
            }
            return_type = debug_get_return_type(dhandle, current_type);
            if (return_type == DEBUG_TYPE_NULL) {
              bad_stab(orig);
              current_method_variant_parsing_successful = false;
              break;
            }
            debug_type new_type = parse_stab_argtypes(dhandle, info, class_type, method_name_current,
                                                      tagname, return_type, argtypes_str_current,
                                                      const_qualifier, volatile_qualifier, &physical_name);
            if (new_type == DEBUG_TYPE_NULL) {
              current_method_variant_parsing_successful = false;
              break;
            }
            current_type = new_type;
          }

          // --- Allocate and Create Method Variant ---
          if (!resize_array((void**)&variants_temp, &variant_count, &variant_alloc_size, sizeof(*variants_temp))) {
              current_method_variant_parsing_successful = false;
              break;
          }

          if (!static_specifier) {
            variants_temp[variant_count] = debug_make_method_variant(dhandle, physical_name,
                                                               current_type, visibility,
                                                               const_qualifier, volatile_qualifier,
                                                               voffset, context);
          } else {
            variants_temp[variant_count] = debug_make_static_method_variant(dhandle,
                                                                     physical_name,
                                                                     current_type,
                                                                     visibility,
                                                                     const_qualifier,
                                                                     volatile_qualifier);
          }

          if (variants_temp[variant_count] == DEBUG_METHOD_VARIANT_NULL) {
            current_method_variant_parsing_successful = false;
            break;
          }

          ++variant_count;

        } while (**pp != ';' && **pp != '\0' && *pp < p_end); // End of inner loop

      if (!current_method_variant_parsing_successful) {
        overall_parsing_successful = false;
        break;
      }

      // Commit variants array to dhandle memory
      debug_method_variant *committed_variants = commit_to_dhandle_allocator(dhandle, variants_temp, variant_count + 1, sizeof(*variants_temp));
      if (committed_variants == NULL && variant_count > 0) { // If variants were expected but commit failed
          overall_parsing_successful = false;
          break;
      }
      variants_temp = NULL; // Mark as moved
      if (committed_variants != NULL) {
          committed_variants[variant_count] = DEBUG_METHOD_VARIANT_NULL; // Null terminate
      }

      // Skip trailing ';' if it exists
      if (*pp < p_end && **pp != '\0') {
        ++*pp;
      }

      // --- Allocate and Create Method ---
      if (!resize_array((void**)&methods, &method_count, &method_alloc_size, sizeof(*methods))) {
          overall_parsing_successful = false;
          break;
      }

      methods[method_count] = debug_make_method(dhandle, method_name_current, committed_variants);
      if (methods[method_count] == DEBUG_METHOD_NULL) {
          overall_parsing_successful = false;
          break;
      }
      // Ownership of method_name_current and committed_variants transferred to debug_make_method
      method_name_current = NULL; // Mark as consumed

      ++method_count;
    } // End of main method loop

  // --- Final Cleanup and Commit ---
  if (!overall_parsing_successful) {
    // Free any temporary allocations that were not committed
    free(variants_temp);
    free(methods);
    return false;
  }

  // Commit methods array to dhandle memory
  debug_method *committed_methods = commit_to_dhandle_allocator(dhandle, methods, method_count + 1, sizeof(*methods));
  if (committed_methods == NULL && method_count > 0) { // If methods were expected but commit failed
      return false;
  }
  methods = NULL; // Mark as moved
  if (committed_methods != NULL) {
      committed_methods[method_count] = DEBUG_METHOD_NULL; // Null terminate
  }

  *retp = committed_methods;

  return true;
}

/* Parse a string representing argument types for a method.  Stabs
   tries to save space by packing argument types into a mangled
   string.  This string should give us enough information to extract
   both argument types and the physical name of the function, given
   the tag name.  */

static debug_type
parse_stab_argtypes (void *dhandle, struct stab_handle *info,
		     debug_type class_type, const char *fieldname,
		     const char *tagname, debug_type return_type,
		     const char *argtypes, bool constp,
		     bool volatilep, const char **pphysname)
{
  bool is_full_physname_constructor = (
      (argtypes[0] == '_' && argtypes[1] == '_' &&
       (ISDIGIT (argtypes[2]) || argtypes[2] == 'Q' || argtypes[2] == 't')) ||
      startswith (argtypes, "__ct")
  );

  bool is_constructor = is_full_physname_constructor ||
                        (tagname != NULL && strcmp (fieldname, tagname) == 0);

  bool is_destructor = (
      (argtypes[0] == '_' && (argtypes[1] == '$' || argtypes[1] == '.') && argtypes[2] == '_') ||
      startswith (argtypes, "__dt")
  );

  bool is_v3 = (argtypes[0] == '_' && argtypes[1] == 'Z');

  debug_type *args;
  bool varargs = false;
  size_t physname_len_to_demangler = 0;

  if (!(is_destructor || is_full_physname_constructor || is_v3))
    {
      size_t fieldname_len = 0;
      if (!is_constructor)
        fieldname_len = strlen (fieldname);

      const char *const_prefix_str = constp ? "C" : "";
      const char *volatile_prefix_str = volatilep ? "V" : "";

      char prefix_buf[20];
      size_t prefix_buf_actual_len;

      const char *mangled_tagname = tagname;
      size_t tagname_len_val = (mangled_tagname == NULL) ? 0 : strlen (mangled_tagname);
      bool is_template_method = (mangled_tagname != NULL && strchr (mangled_tagname, '<') != NULL);

      if (tagname_len_val == 0 || is_template_method)
        {
          prefix_buf_actual_len = snprintf (prefix_buf, sizeof (prefix_buf), "__%s%s",
                                            const_prefix_str, volatile_prefix_str);
          mangled_tagname = NULL;
          tagname_len_val = 0;
        }
      else
        {
          prefix_buf_actual_len = snprintf (prefix_buf, sizeof (prefix_buf), "__%s%s%zu",
                                            const_prefix_str, volatile_prefix_str, tagname_len_val);
        }

      if (prefix_buf_actual_len >= sizeof(prefix_buf))
        prefix_buf_actual_len = sizeof(prefix_buf) - 1;

      if (fieldname[0] == 'o' && fieldname[1] == 'p' && (fieldname[2] == '$' || fieldname[2] == '.'))
        {
          return DEBUG_TYPE_NULL;
        }

      size_t argtypes_len = strlen (argtypes);

      size_t total_alloc_len = fieldname_len + prefix_buf_actual_len + tagname_len_val + argtypes_len + 1;

      char *physname = debug_xalloc (dhandle, total_alloc_len);

      char *current_pos = physname;

      if (fieldname_len > 0)
        {
          memcpy (current_pos, fieldname, fieldname_len);
          current_pos += fieldname_len;
        }

      memcpy (current_pos, prefix_buf, prefix_buf_actual_len);
      current_pos += prefix_buf_actual_len;

      if (mangled_tagname != NULL)
        {
          memcpy (current_pos, mangled_tagname, tagname_len_val);
          current_pos += tagname_len_val;
        }

      memcpy (current_pos, argtypes, argtypes_len);
      current_pos += argtypes_len;

      *current_pos = '\0';

      *pphysname = physname;
      physname_len_to_demangler = total_alloc_len - 1;
    }

  if (*argtypes == '\0' || is_destructor)
    {
      args = debug_xalloc (dhandle, sizeof (*args));
      *args = DEBUG_TYPE_NULL;
      return debug_make_method_type (dhandle, return_type, class_type, args, false);
    }

  args = stab_demangle_argtypes (dhandle, info, *pphysname, &varargs, physname_len_to_demangler);
  if (args == NULL)
    return DEBUG_TYPE_NULL;

  return debug_make_method_type (dhandle, return_type, class_type, args, varargs);
}

/* The tail end of stabs for C++ classes that contain a virtual function
   pointer contains a tilde, a %, and a type number.
   The type number refers to the base class (possibly this class itself) which
   contains the vtable pointer for the current class.

   This function is called when we have parsed all the method declarations,
   so we can look for the vptr base class info.  */

static bool
parse_stab_tilde_field (void *dhandle,
			struct stab_handle *info,
			const char **pp,
			const int *typenums,
			debug_type *retvptrbase,
			bool *retownvptr,
			const char *p_end)
{
  const char *start_pos = *pp;
  int vptr_typenums[2];

  *retvptrbase = DEBUG_TYPE_NULL;
  *retownvptr = false;

  if (start_pos >= p_end)
    return false;

  if (**pp == ';')
    {
      ++*pp;
      if (*pp >= p_end)
        return false;
    }

  if (**pp != '~')
    return true;
  ++*pp;
  if (*pp >= p_end)
    return false;

  if (**pp == '=' || **pp == '+' || **pp == '-')
    {
      ++*pp;
      if (*pp >= p_end)
        return false;
    }

  if (**pp != '%')
    return true;
  ++*pp;
  if (*pp >= p_end)
    return false;

  const char *pos_before_type_num = *pp;

  if (! parse_stab_type_number (pp, vptr_typenums, p_end))
    return false;

  if (vptr_typenums[0] == typenums[0]
      && vptr_typenums[1] == typenums[1])
    {
      *retownvptr = true;
    }
  else
    {
      debug_type vptr_base_type;
      const char *current_p;

      *pp = pos_before_type_num;

      vptr_base_type = parse_stab_type (dhandle, info, (const char *) NULL, pp,
                                        (debug_type **) NULL, p_end);
      if (vptr_base_type == DEBUG_TYPE_NULL)
        {
          bad_stab (start_pos);
          return false;
        }

      current_p = *pp;
      while (current_p < p_end && *current_p != ';')
        {
          ++current_p;
        }

      if (current_p == p_end || *current_p != ';')
        {
          bad_stab (start_pos);
          return false;
        }

      *retvptrbase = vptr_base_type;
      *pp = current_p + 1;
    }

  return true;
}

/* Read a definition of an array type.  */

static debug_type
parse_stab_array_type (void *dhandle,
		       struct stab_handle *info,
		       const char **pp,
		       bool stringp,
		       const char *p_end)
{
  const char *orig_stab_start = *pp; // Store original start for error reporting
  const char *current_p = *pp;
  int typenums[2];
  debug_type index_type;
  bool adjustable = false;
  bfd_signed_vma lower, upper;
  debug_type element_type;

  // Helper macro for consuming expected characters and handling errors.
  // It modifies `current_p` in place and returns DEBUG_TYPE_NULL on failure.
  #define CONSUME_CHAR_OR_FAIL(expected_char) \
    do { \
      if (current_p >= p_end || *current_p != expected_char) { \
        bad_stab (orig_stab_start); \
        return DEBUG_TYPE_NULL; \
      } \
      current_p++; \
    } while (0)

  if (current_p >= p_end)
    return DEBUG_TYPE_NULL;

  // 1. Parse index type number (e.g., "0;0")
  // `parse_stab_type_number` advances `current_p` past the type number.
  if (! parse_stab_type_number (&current_p, typenums, p_end))
    return DEBUG_TYPE_NULL;

  // Determine index_type: If "0;0" and not defining a new type (i.e., not followed by '='),
  // then default to the 'int' type.
  // Corrected check: `*current_p` refers to the character immediately after the parsed type number.
  if (typenums[0] == 0 && typenums[1] == 0 && current_p < p_end && *current_p != '=')
    {
      index_type = debug_find_named_type (dhandle, "int");
      if (index_type == DEBUG_TYPE_NULL)
	{
	  // Fallback to creating a generic 4-byte integer type if 'int' is not found.
	  index_type = debug_make_int_type (dhandle, 4, false);
	  if (index_type == DEBUG_TYPE_NULL)
	    return DEBUG_TYPE_NULL;
	}
    }
  else
    {
      // Parse as a full type using `parse_stab_type`, which also advances `current_p`.
      index_type = parse_stab_type (dhandle, info, NULL, &current_p, NULL, p_end);
      if (index_type == DEBUG_TYPE_NULL)
        return DEBUG_TYPE_NULL;
    }

  // 2. Expect a semicolon (';') after the index type.
  CONSUME_CHAR_OR_FAIL(';');

  // 3. Parse the lower bound.
  // Check for Fortran adjustable array prefixes (e.g., 'A', 'T') before the number.
  if (current_p < p_end && !ISDIGIT(*current_p) && *current_p != '-')
    {
      current_p++; // Skip the 'A' or 'T' character.
      adjustable = true;
    }
  lower = (bfd_signed_vma) parse_number (&current_p, NULL, p_end);

  // 4. Expect a semicolon (';') after the lower bound.
  CONSUME_CHAR_OR_FAIL(';');

  // 5. Parse the upper bound.
  // Check for Fortran adjustable array prefixes again.
  if (current_p < p_end && !ISDIGIT(*current_p) && *current_p != '-')
    {
      current_p++; // Skip the 'A' or 'T' character.
      adjustable = true; // Mark as adjustable if either bound has the prefix.
    }
  upper = (bfd_signed_vma) parse_number (&current_p, NULL, p_end);

  // 6. Expect a semicolon (';') after the upper bound.
  CONSUME_CHAR_OR_FAIL(';');

  // 7. Parse the element type.
  // `parse_stab_type` advances `current_p` past the element type.
  element_type = parse_stab_type (dhandle, info, NULL, &current_p, NULL, p_end);
  if (element_type == DEBUG_TYPE_NULL)
    return DEBUG_TYPE_NULL;

  // Apply adjustable bounds transformation if an adjustable prefix was found.
  if (adjustable)
    {
      lower = 0;
      upper = -1;
    }

  // Update the caller's pointer to reflect the total characters consumed by this function.
  *pp = current_p;

  return debug_make_array_type (dhandle, element_type, index_type, lower,
				upper, stringp);

  #undef CONSUME_CHAR_OR_FAIL
}

/* This struct holds information about files we have seen using
   N_BINCL.  */

struct bincl_file
{
  /* The next N_BINCL file.  */
  struct bincl_file *next;
  /* The next N_BINCL on the stack.  */
  struct bincl_file *next_stack;
  /* The file name.  */
  const char *name;
  /* The hash value.  */
  bfd_vma hash;
  /* The file index.  */
  unsigned int file;
  /* The list of types defined in this file.  */
  struct stab_types *file_types;
};

/* Start a new N_BINCL file, pushing it onto the stack.  */

static void
push_bincl (void *dhandle, struct stab_handle *info, const char *name,
	    bfd_vma hash)
{
  struct bincl_file *n;

  n = debug_xalloc (dhandle, sizeof *n);

  n->next = info->bincl_list;
  n->next_stack = info->bincl_stack;
  n->name = name;
  n->hash = hash;
  n->file = info->files; /* Assign the current count as the new file's index */
  n->file_types = NULL;

  info->bincl_list = n;
  info->bincl_stack = n;

  /* Dynamically grow the file_types array and initialize the new slot. */
  size_t new_files_count = info->files + 1;
  info->file_types = xrealloc (info->file_types,
			       new_files_count * sizeof (*info->file_types));
  info->file_types[info->files] = NULL; /* Initialize the slot at the old 'files' index */
  info->files = new_files_count;        /* Update the total count of files */
}

/* Finish an N_BINCL file, at an N_EINCL, popping the name off the
   stack.  */

static const char *
pop_bincl (struct stab_handle *info)
{
  struct bincl_file *popped_file;

  if (info->bincl_stack == NULL) {
    return info->main_filename;
  }

  popped_file = info->bincl_stack;
  info->bincl_stack = popped_file->next_stack;

  if (popped_file->file >= info->files) {
    return info->main_filename;
  }

  popped_file->file_types = info->file_types[popped_file->file];

  if (info->bincl_stack == NULL) {
    return info->main_filename;
  } else {
    return info->bincl_stack->name;
  }
}

/* Handle an N_EXCL: get the types from the corresponding N_BINCL.  */

static bool
find_excl (struct stab_handle *info, const char *name, bfd_vma hash)
{
  size_t current_file_idx = info->files;
  info->files++;

  info->file_types = xrealloc(info->file_types,
                               info->files * sizeof(*info->file_types));

  struct bincl_file *found_entry = NULL;
  for (struct bincl_file *l = info->bincl_list; l != NULL; l = l->next)
    {
      if (l->hash == hash && strcmp(l->name, name) == 0)
        {
          found_entry = l;
          break;
        }
    }

  if (found_entry == NULL)
    {
      warn_stab(name, _("Undefined N_EXCL"));
      info->file_types[current_file_idx] = NULL;
    }
  else
    {
      info->file_types[current_file_idx] = found_entry->file_types;
    }

  return true;
}

/* Handle a variable definition.  gcc emits variable definitions for a
   block before the N_LBRAC, so we must hold onto them until we see
   it.  The SunPRO compiler emits variable definitions after the
   N_LBRAC, so we can call debug_record_variable immediately.  */

static bool
stab_record_variable (void *dhandle, struct stab_handle *info,
		      const char *name, debug_type type,
		      enum debug_var_kind kind, bfd_vma val)
{
  if ((kind == DEBUG_GLOBAL || kind == DEBUG_STATIC)
      || ! info->within_function
      || (info->gcc_compiled == 0 && info->n_opt_found))
    {
      return debug_record_variable (dhandle, name, type, kind, val);
    }

  struct stab_pending_var *v = debug_xzalloc (dhandle, sizeof (*v));

  if (v == NULL)
    {
      return false; /* Memory allocation failed */
    }

  v->next = info->pending;
  v->name = name;
  v->type = type;
  v->kind = kind;
  v->val = val;
  info->pending = v;

  return true;
}

/* Emit pending variable definitions.  This is called after we see the
   N_LBRAC that starts the block.  */

static bool
stab_emit_pending_vars (void *dhandle, struct stab_handle *info)
{
  struct stab_pending_var *current_var = info->pending;

  while (current_var != NULL)
    {
      if (!debug_record_variable(dhandle,
                                  current_var->name,
                                  current_var->type,
                                  current_var->kind,
                                  current_var->val))
        {
          return false;
        }

      current_var = current_var->next;
    }

  info->pending = NULL;

  return true;
}

/* Find the slot for a type in the database.  */

enum {
  STAB_FILE_INDEX = 0,
  STAB_TINDEX_INDEX = 1
};

static debug_type *
stab_find_slot (void *dhandle, struct stab_handle *info, const int *typenums)
{
  if (dhandle == NULL || info == NULL || typenums == NULL)
    {
      return NULL;
    }

  const unsigned int filenum = (unsigned int)typenums[STAB_FILE_INDEX];
  const unsigned int tindex = (unsigned int)typenums[STAB_TINDEX_INDEX];

  if (filenum >= info->files)
    {
      fprintf (stderr, _("Type file number %d out of range\n"), filenum);
      return NULL;
    }

  const unsigned int base_index = (tindex / STAB_TYPES_SLOTS) * STAB_TYPES_SLOTS;
  const unsigned int offset_in_block = tindex - base_index;

  struct stab_types **current_stab_types_ptr = &info->file_types[filenum];

  while (*current_stab_types_ptr != NULL && (*current_stab_types_ptr)->base_index < base_index)
    {
      current_stab_types_ptr = &(*current_stab_types_ptr)->next;
    }

  if (*current_stab_types_ptr == NULL || (*current_stab_types_ptr)->base_index != base_index)
    {
      struct stab_types *new_stab_types_node = debug_xzalloc(dhandle, sizeof(*new_stab_types_node));

      if (new_stab_types_node == NULL)
        {
          // Memory allocation failure. Returning NULL as a failure indicator,
          // consistent with other error paths, without introducing new error messages.
          return NULL;
        }

      new_stab_types_node->next = *current_stab_types_ptr;
      new_stab_types_node->base_index = base_index;
      *current_stab_types_ptr = new_stab_types_node;
    }

  return (*current_stab_types_ptr)->types + offset_in_block;
}

/* Find a type given a type number.  If the type has not been
   allocated yet, create an indirect type.  */

static debug_type
stab_find_type (void *dhandle, struct stab_handle *info, const int *typenums)
{
  debug_type *slot;
  const int type_category = typenums[0];
  const int type_identifier = typenums[1];

  if (type_category == 0 && type_identifier < 0)
    {
      return stab_xcoff_builtin_type (dhandle, info, type_identifier);
    }

  slot = stab_find_slot (dhandle, info, typenums);
  if (slot == NULL)
    {
      return DEBUG_TYPE_NULL;
    }

  if (*slot == DEBUG_TYPE_NULL)
    {
      return debug_make_indirect_type (dhandle, slot, (const char *) NULL);
    }

  return *slot;
}

/* Record that a given type number refers to a given type.  */

static bool
stab_record_type (void *dhandle, struct stab_handle *info,
		  const int *typenums, debug_type type)
{
  debug_type *slot = stab_find_slot (dhandle, info, typenums);
  if (slot == NULL)
    return false;

  *slot = type;

  return true;
}

/* Return an XCOFF builtin type.  */

static debug_type
stab_xcoff_builtin_type (void *dhandle, struct stab_handle *info,
			 unsigned int typenum_param)
{
  enum StabTypeKind
  {
    STAB_TYPE_VOID,
    STAB_TYPE_INT,
    STAB_TYPE_FLOAT,
    STAB_TYPE_BOOL,
    STAB_TYPE_COMPLEX,
    STAB_TYPE_UNSUPPORTED_SPECIAL
  };

  struct StabTypeDesc
  {
    const char *name;
    enum StabTypeKind kind;
    int size;
    bool is_unsigned;
  };

  static const struct StabTypeDesc xcoff_builtin_type_descs[] = {
    /* 0: -1 */ { "int", STAB_TYPE_INT, 4, false },
    /* 1: -2 */ { "char", STAB_TYPE_INT, 1, false },
    /* 2: -3 */ { "short", STAB_TYPE_INT, 2, false },
    /* 3: -4 */ { "long", STAB_TYPE_INT, 4, false },
    /* 4: -5 */ { "unsigned char", STAB_TYPE_INT, 1, true },
    /* 5: -6 */ { "signed char", STAB_TYPE_INT, 1, false },
    /* 6: -7 */ { "unsigned short", STAB_TYPE_INT, 2, true },
    /* 7: -8 */ { "unsigned int", STAB_TYPE_INT, 4, true },
    /* 8: -9 */ { "unsigned", STAB_TYPE_INT, 4, true },
    /* 9: -10 */ { "unsigned long", STAB_TYPE_INT, 4, true },
    /* 10: -11 */ { "void", STAB_TYPE_VOID, 0, false },
    /* 11: -12 */ { "float", STAB_TYPE_FLOAT, 4, false },
    /* 12: -13 */ { "double", STAB_TYPE_FLOAT, 8, false },
    /* 13: -14 */ { "long double", STAB_TYPE_FLOAT, 8, false },
    /* 14: -15 */ { "integer", STAB_TYPE_INT, 4, false },
    /* 15: -16 */ { "boolean", STAB_TYPE_BOOL, 4, false },
    /* 16: -17 */ { "short real", STAB_TYPE_FLOAT, 4, false },
    /* 17: -18 */ { "real", STAB_TYPE_FLOAT, 8, false },
    /* 18: -19 */ { "stringptr", STAB_TYPE_UNSUPPORTED_SPECIAL, 0, false },
    /* 19: -20 */ { "character", STAB_TYPE_INT, 1, true },
    /* 20: -21 */ { "logical*1", STAB_TYPE_BOOL, 1, false },
    /* 21: -22 */ { "logical*2", STAB_TYPE_BOOL, 2, false },
    /* 22: -23 */ { "logical*4", STAB_TYPE_BOOL, 4, false },
    /* 23: -24 */ { "logical", STAB_TYPE_BOOL, 4, false },
    /* 24: -25 */ { "complex", STAB_TYPE_COMPLEX, 8, false },
    /* 25: -26 */ { "double complex", STAB_TYPE_COMPLEX, 16, false },
    /* 26: -27 */ { "integer*1", STAB_TYPE_INT, 1, false },
    /* 27: -28 */ { "integer*2", STAB_TYPE_INT, 2, false },
    /* 28: -29 */ { "integer*4", STAB_TYPE_INT, 4, false },
    /* 29: -30 */ { "wchar", STAB_TYPE_INT, 2, false },
    /* 30: -31 */ { "long long", STAB_TYPE_INT, 8, false },
    /* 31: -32 */ { "unsigned long long", STAB_TYPE_INT, 8, true },
    /* 32: -33 */ { "logical*8", STAB_TYPE_BOOL, 8, false },
    /* 33: -34 */ { "integer*8", STAB_TYPE_INT, 8, false }
  };

  #define XCOFF_BUILTIN_TYPE_COUNT (sizeof(xcoff_builtin_type_descs) / sizeof(xcoff_builtin_type_descs[0]))

  debug_type rettype = DEBUG_TYPE_NULL;
  int original_typenum_signed = (int)typenum_param;
  unsigned int internal_index;

  internal_index = -typenum_param - 1;

  if (internal_index >= XCOFF_BUILTIN_TYPE_COUNT)
    {
      fprintf (stderr, _("Unrecognized XCOFF type %d\n"), original_typenum_signed);
      return DEBUG_TYPE_NULL;
    }

  if (info->xcoff_types[internal_index] != DEBUG_TYPE_NULL)
    return info->xcoff_types[internal_index];

  const struct StabTypeDesc *desc = &xcoff_builtin_type_descs[internal_index];

  switch (desc->kind)
    {
    case STAB_TYPE_VOID:
      rettype = debug_make_void_type (dhandle);
      break;
    case STAB_TYPE_INT:
      rettype = debug_make_int_type (dhandle, desc->size, desc->is_unsigned);
      break;
    case STAB_TYPE_FLOAT:
      rettype = debug_make_float_type (dhandle, desc->size);
      break;
    case STAB_TYPE_BOOL:
      rettype = debug_make_bool_type (dhandle, desc->size);
      break;
    case STAB_TYPE_COMPLEX:
      rettype = debug_make_complex_type (dhandle, desc->size);
      break;
    case STAB_TYPE_UNSUPPORTED_SPECIAL:
      rettype = DEBUG_TYPE_NULL;
      break;
    default:
      fprintf (stderr, _("Internal error: Unhandled STAB_TYPE_KIND for XCOFF type index %u\n"), internal_index);
      return DEBUG_TYPE_NULL;
    }

  if (rettype != DEBUG_TYPE_NULL)
    {
      rettype = debug_name_type (dhandle, desc->name, rettype);
      info->xcoff_types[internal_index] = rettype;
    }

  return rettype;
}

/* Find or create a tagged type.  */

static debug_type
stab_find_tagged_type (void *dhandle, struct stab_handle *info,
		       const char *p, int len, enum debug_type_kind kind)
{
  char *name;
  debug_type dtype;
  struct stab_tag *found_tag;

  name = savestring (dhandle, p, len);

  dtype = debug_find_tagged_type (dhandle, name, DEBUG_KIND_ILLEGAL);
  if (dtype != DEBUG_TYPE_NULL)
    return dtype;

  found_tag = NULL;
  for (struct stab_tag *current_tag = info->tags; current_tag != NULL; current_tag = current_tag->next)
    {
      if (strcmp (current_tag->name, name) == 0)
	{
	  found_tag = current_tag;
	  break;
	}
    }

  if (found_tag != NULL)
    {
      if (found_tag->kind == DEBUG_KIND_ILLEGAL)
        found_tag->kind = kind;
      return found_tag->type;
    }
  else
    {
      found_tag = debug_xzalloc (dhandle, sizeof (*found_tag));

      found_tag->next = info->tags;
      found_tag->name = name;
      found_tag->kind = kind;
      found_tag->slot = DEBUG_TYPE_NULL;
      found_tag->type = debug_make_indirect_type (dhandle, &found_tag->slot, name);
      info->tags = found_tag;
      return found_tag->type;
    }
}

/* In order to get the correct argument types for a stubbed method, we
   need to extract the argument types from a C++ mangled string.
   Since the argument types can refer back to the return type, this
   means that we must demangle the entire physical name.  In gdb this
   is done by calling cplus_demangle and running the results back
   through the C++ expression parser.  Since we have no expression
   parser, we must duplicate much of the work of cplus_demangle here.

   We assume that GNU style demangling is used, since this is only
   done for method stubs, and only g++ should output that form of
   debugging information.  */

/* This structure is used to hold a pointer to type information which
   demangling a string.  */

struct stab_demangle_typestring
{
  /* The start of the type.  This is not null terminated.  */
  const char *typestring;
  /* The length of the type.  */
  unsigned int len;
};

/* This structure is used to hold information while demangling a
   string.  */

struct stab_demangle_info
{
  /* The debugging information handle.  */
  void *dhandle;
  /* The stab information handle.  */
  struct stab_handle *info;
  /* The array of arguments we are building.  */
  debug_type *args;
  /* Whether the method takes a variable number of arguments.  */
  bool varargs;
  /* The array of types we have remembered.  */
  struct stab_demangle_typestring *typestrings;
  /* The number of typestrings.  */
  unsigned int typestring_count;
  /* The number of typestring slots we have allocated.  */
  unsigned int typestring_alloc;
};

static void stab_bad_demangle (const char *);
static unsigned int stab_demangle_count (const char **);
static bool stab_demangle_get_count (const char **, unsigned int *);
static bool stab_demangle_prefix
  (struct stab_demangle_info *, const char **, unsigned int);
static bool stab_demangle_function_name
  (struct stab_demangle_info *, const char **, const char *);
static bool stab_demangle_signature
  (struct stab_demangle_info *, const char **);
static bool stab_demangle_qualified
  (struct stab_demangle_info *, const char **, debug_type *);
static bool stab_demangle_template
  (struct stab_demangle_info *, const char **, char **);
static bool stab_demangle_class
  (struct stab_demangle_info *, const char **, const char **);
static bool stab_demangle_args
  (struct stab_demangle_info *, const char **, debug_type **, bool *);
static bool stab_demangle_arg
  (struct stab_demangle_info *, const char **, debug_type **,
   unsigned int *, unsigned int *);
static bool stab_demangle_type
  (struct stab_demangle_info *, const char **, debug_type *);
static bool stab_demangle_fund_type
  (struct stab_demangle_info *, const char **, debug_type *);
static bool stab_demangle_remember_type
  (struct stab_demangle_info *, const char *, int);

/* Warn about a bad demangling.  */

static void
stab_bad_demangle (const char *s)
{
  fprintf (stderr, _("bad mangled name `%s'\n"), s ? s : "(null)");
}

/* Get a count from a stab string.  */

#include <limits.h>
#include <ctype.h>

static unsigned int
stab_demangle_count (const char **pp)
{
  unsigned int count = 0;
  int saturated = 0;

  while (isdigit((unsigned char)**pp))
    {
      unsigned int digit = (unsigned int)(**pp - '0');

      if (!saturated)
        {
          if (count > UINT_MAX / 10)
            {
              count = UINT_MAX;
              saturated = 1;
            }
          else
            {
              unsigned int temp_count = count * 10;
              if (temp_count > UINT_MAX - digit)
                {
                  count = UINT_MAX;
                  saturated = 1;
                }
              else
                {
                  count = temp_count + digit;
                }
            }
        }
      ++*pp;
    }
  return count;
}

/* Require a count in a string.  The count may be multiple digits, in
   which case it must end in an underscore.  */

static bool
stab_demangle_get_count (const char **pp, unsigned int *pi)
{
  const char *current_char_ptr = *pp;
  unsigned int parsed_count = 0;

  // Rule 1: Must start with a digit. If not, return false.
  if (!ISDIGIT (*current_char_ptr))
    return false;

  // Rule 2: Always parse at least one digit.
  // This value will be committed to *pi and *pp if no multi-digit sequence
  // followed by an underscore is found.
  parsed_count = *current_char_ptr - '0';
  current_char_ptr++;

  // Update *pi and *pp with the single-digit result.
  // This is the default success state.
  *pi = parsed_count;
  *pp = current_char_ptr;

  // Rule 3: Check for a multi-digit number followed by an underscore.
  // Use temporary variables to avoid modifying *pp and *pi unless the
  // full pattern (multi-digit + '_') is matched.
  const char *potential_multi_digit_end = current_char_ptr;
  unsigned int potential_multi_digit_value = parsed_count;

  if (ISDIGIT (*potential_multi_digit_end))
    {
      // Parse all subsequent digits
      while (ISDIGIT (*potential_multi_digit_end))
	{
	  // Note: No explicit overflow check for unsigned int,
	  // maintaining original legacy behavior which implicitly allows wrap-around.
	  potential_multi_digit_value *= 10;
	  potential_multi_digit_value += *potential_multi_digit_end - '0';
	  potential_multi_digit_end++;
	}

      // If an underscore immediately follows the sequence of digits,
      // then commit the multi-digit result to *pi and *pp.
      if (*potential_multi_digit_end == '_')
	{
	  *pi = potential_multi_digit_value;
	  *pp = potential_multi_digit_end + 1;
	}
      // If no underscore, *pi and *pp retain their values from the single-digit parse.
    }

  // If we reach here, at least one digit was successfully parsed.
  return true;
}

/* This function demangles a physical name, returning a NULL
   terminated array of argument types.  */

static debug_type *
stab_demangle_argtypes (void *dhandle, struct stab_handle *info,
			const char *physname, bool *pvarargs,
			unsigned int physname_len)
{
  struct stab_demangle_info minfo;
  debug_type *return_args = NULL;
  bool overall_success = false;

  if (physname[0] == '_' && physname[1] == 'Z')
    return stab_demangle_v3_argtypes (dhandle, info, physname, pvarargs);

  minfo.dhandle = dhandle;
  minfo.info = info;
  minfo.args = NULL;
  minfo.varargs = false;
  minfo.typestring_alloc = 10;
  minfo.typestring_count = 0;
  minfo.typestrings = NULL;

  minfo.typestrings
    = xmalloc (minfo.typestring_alloc * sizeof (*minfo.typestrings));

  if (stab_demangle_prefix (&minfo, &physname, physname_len))
    {
      if (*physname != '\0')
        {
          if (stab_demangle_signature (&minfo, &physname))
            {
              overall_success = true;
            }
        }
      else
        {
          overall_success = true;
        }
    }

  free (minfo.typestrings);

  if (overall_success)
    {
      if (minfo.args == NULL)
        fprintf (stderr, _("no argument types in mangled string\n"));

      *pvarargs = minfo.varargs;
      return_args = minfo.args;
    }

  return return_args;
}

/* Demangle the prefix of the mangled name.  */

static bool
stab_demangle_prefix (struct stab_demangle_info *minfo, const char **pp,
		      unsigned int physname_len)
{
  const char *double_underscore_pos;
  const char *initial_pp_val = *pp;

  if (physname_len)
    {
      double_underscore_pos = *pp + physname_len;
    }
  else
    {
      /* Find the first '__' sequence. */
      double_underscore_pos = *pp;
      while (true)
	{
	  double_underscore_pos = strchr (double_underscore_pos, '_');
	  if (double_underscore_pos == NULL)
	    {
	      stab_bad_demangle (initial_pp_val);
	      return false;
	    }
	  if (double_underscore_pos[1] == '_')
	    break;
	  double_underscore_pos++; /* Skip the current single underscore and continue search. */
	}

      /* At this point, double_underscore_pos points to the first '_' of the first '__' pair. */

      /* Move ahead to the first '_' of the last contiguous `__' pair if there are more than two underscores.
         E.g., for "___", it should point to the second '_'. For "____", to the third '_'. */
      unsigned int num_underscores = 0;
      const char *temp_scan = double_underscore_pos;
      while (*temp_scan == '_')
	{
	  num_underscores++;
	  temp_scan++;
	}

      if (num_underscores > 2)
	double_underscore_pos += num_underscores - 2;
    }

  /*
   * Handle different types of prefixes based on the location of `double_underscore_pos`:
   * 1. The string starts with `__`.
   * 2. The string contains `__` but doesn't start with it.
   */

  if (double_underscore_pos == *pp)
    {
      /* The string starts with `__`. */

      /* Check for GNU style constructor name (e.g., __1foo, __Qfoo, __tfoo). */
      if (double_underscore_pos[2] != '\0' && (ISDIGIT(double_underscore_pos[2]) || double_underscore_pos[2] == 'Q' || double_underscore_pos[2] == 't'))
	{
	  *pp = double_underscore_pos + 2; /* Advance *pp past the "__" prefix. */
	  return true;
	}
      else if (double_underscore_pos[2] == '\0')
	{
	  /* Only "__" at the beginning, but no subsequent characters for a name. E.g. "__". */
	  stab_bad_demangle(initial_pp_val);
	  return false;
	}
      else
	{
	  /* String starts with `__`, but it's not a constructor.
	     Look for the *next* `__` which separates the prefix from the signature. */
	  const char *search_start = double_underscore_pos + 2; /* Start search after initial "__". */
	  while (*search_start == '_') /* Skip any additional leading underscores in the name part. */
	    ++search_start;

	  const char *next_double_underscore = strstr(search_start, "__");

	  /* The separator must exist and be followed by at least two characters to be valid.
	     `next_double_underscore[2] == '\0'` implies the string ends with `__`. */
	  if (next_double_underscore == NULL || next_double_underscore[2] == '\0')
	    {
	      stab_bad_demangle(initial_pp_val);
	      return false;
	    }

	  return stab_demangle_function_name (minfo, pp, next_double_underscore);
	}
    }
  else
    {
      /* The name doesn't start with `__', but it does contain `__'.
         `double_underscore_pos` is now considered the separator. */

      /* The separator `__` must be followed by at least two characters to be valid,
         as it's meant to separate the prefix from the signature.
         If `double_underscore_pos[2]` is `\0`, it means the string ends with `__` (e.g., "foo__\0").
         In such a case, it cannot separate a signature. */
      if (double_underscore_pos[2] != '\0')
	{
	  return stab_demangle_function_name (minfo, pp, double_underscore_pos);
	}
      else
	{
	  stab_bad_demangle(initial_pp_val);
	  return false;
	}
    }
}

/* Demangle a function name prefix.  The scan argument points to the
   double underscore which separates the function name from the
   signature.  */

static bool
stab_demangle_function_name (struct stab_demangle_info *minfo,
			     const char **pp, const char *scan)
{
  const char *name = *pp;
  size_t name_len = (size_t)(scan - name);

  *pp = scan + 2;

  const char *type_start_offset = NULL;

  static const char type_prefix[] = "type";
  static const size_t type_prefix_len = sizeof(type_prefix) - 1;
  static const size_t type_operator_min_len = type_prefix_len + 1;

  static const char op_prefix[] = "__op";
  static const size_t op_prefix_len = sizeof(op_prefix) - 1;

  if (name_len >= type_operator_min_len &&
      strncmp(name, type_prefix, type_prefix_len) == 0 &&
      (name[type_prefix_len] == '$' || name[type_prefix_len] == '.'))
    {
      type_start_offset = name + type_operator_min_len;
    }
  else if (name_len >= op_prefix_len &&
           strncmp(name, op_prefix, op_prefix_len) == 0)
    {
      type_start_offset = name + op_prefix_len;
    }

  if (type_start_offset != NULL)
    {
      if (! stab_demangle_type (minfo, &type_start_offset, (debug_type *) NULL))
	return false;
    }

  return true;
}

/* Demangle the signature.  This is where the argument types are
   found.  */

static bool
stab_demangle_signature (struct stab_demangle_info *minfo, const char **pp)
{
  const char *orig = *pp;
  const char *hold_start = NULL; /* Marks the beginning of a type sequence for remembering. */
  bool args_were_processed = false; /* Tracks if function arguments have already been processed. */

  while (**pp != '\0')
    {
      /* If arguments have already been handled for this signature,
         we should stop processing characters as part of the signature.
         This prevents redundant calls to stab_demangle_args. */
      if (args_were_processed)
        {
          break;
        }

      char current_char = **pp;

      switch (current_char)
	{
	case 'Q': /* Qualified type. */
	  hold_start = *pp;
	  if (! stab_demangle_qualified (minfo, pp, (debug_type *) NULL)
	      || ! stab_demangle_remember_type (minfo, hold_start, *pp - hold_start))
	    return false;
	  hold_start = NULL; /* Type sequence processed and remembered, reset marker. */
	  break;

	case 'S': /* Static member function modifier. */
	  /* FIXME: Can this happen? This character modifies the subsequent type/function. */
	  if (hold_start == NULL)
	    hold_start = *pp; /* If no type sequence is being tracked, start tracking from 'S'. */
	  ++*pp; /* Consume 'S'. */
	  break;

	case 'C': /* Const member function modifier. */
	  if (hold_start == NULL)
	    hold_start = *pp; /* If no type sequence is being tracked, start tracking from 'C'. */
	  ++*pp; /* Consume 'C'. */
	  break;

	case '0': case '1': case '2': case '3': case '4': /* Class name, digits for length. */
	case '5': case '6': case '7': case '8': case '9':
	  if (hold_start == NULL)
	    hold_start = *pp; /* If no type sequence is being tracked, start tracking from the digit. */
	  if (! stab_demangle_class (minfo, pp, (const char **) NULL)
	      || ! stab_demangle_remember_type (minfo, hold_start, *pp - hold_start))
	    return false;
	  hold_start = NULL; /* Type sequence processed and remembered, reset marker. */
	  break;

	case 'F': /* Explicit function marker. */
	  hold_start = NULL; /* Any preceding type context is now considered complete before arguments. */
	  ++*pp; /* Consume 'F'. */
	  if (! stab_demangle_args (minfo, pp, &minfo->args, &minfo->varargs))
	    return false;
	  args_were_processed = true; /* Arguments explicitly found and processed. */
	  break;

	case 't': /* Template type. */
	  if (hold_start == NULL)
	    hold_start = *pp; /* If no type sequence is being tracked, start tracking from 't'. */
	  if (! stab_demangle_template (minfo, pp, (char **) NULL)
	      || ! stab_demangle_remember_type (minfo, hold_start, *pp - hold_start))
	    return false;
	  hold_start = NULL; /* Type sequence processed and remembered, reset marker. */
	  break;

	case '_': /* Invalid character at this level. */
	  stab_bad_demangle (orig); /* Log bad demangling attempt. */
	  return false;

	default: /* Assume this character signifies the start of function arguments. */
	  if (! stab_demangle_args (minfo, pp, &minfo->args, &minfo->varargs))
	    return false;
	  args_were_processed = true; /* Arguments processed via implicit rule. */
	  break;
	}
    }

  /* After the loop, if no function arguments were explicitly found or assumed
     during the parsing, it implies a function with a (void) signature. */
  if (! args_were_processed)
    {
      if (! stab_demangle_args (minfo, pp, &minfo->args, &minfo->varargs))
	return false;
    }

  return true;
}

/* Demangle a qualified name, such as "Q25Outer5Inner" which is the
   mangled form of "Outer::Inner".  */

static bool
parse_number_robust (const char **pp, unsigned int *out_value, const char *orig_start, const char *name_end)
{
  const char *p = *pp;
  char *endptr;
  long val;

  if (p >= name_end)
    {
      stab_bad_demangle (orig_start);
      return false;
    }

  if (!ISDIGIT (*p) || *p == '0')
    {
      stab_bad_demangle (orig_start);
      return false;
    }

  val = strtol (p, &endptr, 10);

  if (endptr == p || endptr > name_end)
    {
      stab_bad_demangle (orig_start);
      return false;
    }

  if (val < 0 || val > (long) ~0U)
    {
      stab_bad_demangle (orig_start);
      return false;
    }

  *out_value = (unsigned int) val;
  *pp = endptr;

  return true;
}

#define MAX_DEMANGLE_NAME_LENGTH 511

static bool
stab_demangle_qualified (struct stab_demangle_info *minfo, const char **pp,
			 debug_type *ptype)
{
  const char *orig_start = *pp;
  unsigned int qualifiers;
  debug_type context = DEBUG_TYPE_NULL;
  const char *name_end = minfo->name_end;

  if (pp == NULL || *pp == NULL || *pp >= name_end)
    {
      stab_bad_demangle (orig_start);
      return false;
    }

  if (*pp + 1 >= name_end)
    {
      stab_bad_demangle (orig_start);
      return false;
    }

  switch ((*pp)[1])
    {
    case '_':
      *pp += 2;
      if (!parse_number_robust (pp, &qualifiers, orig_start, name_end))
	return false;
      if (*pp >= name_end || **pp != '_')
	{
	  stab_bad_demangle (orig_start);
	  return false;
	}
      ++*pp;
      break;

    case '1': case '2': case '3': case '4': case '5':
    case '6': case '7': case '8': case '9':
      qualifiers = (*pp)[1] - '0';
      *pp += 2;
      if (*pp < name_end && **pp == '_')
	++*pp;
      break;

    case '0':
    default:
      stab_bad_demangle (orig_start);
      return false;
    }

  if (*pp >= name_end)
    {
      stab_bad_demangle (orig_start);
      return false;
    }

  while (qualifiers-- > 0)
    {
      if (*pp >= name_end)
	{
	  stab_bad_demangle (orig_start);
	  return false;
	}

      if (**pp == '_')
	{
	  ++*pp;
	  if (*pp >= name_end)
	    {
	      stab_bad_demangle (orig_start);
	      return false;
	    }
	}

      if (**pp == 't')
	{
	  char *name = NULL;

	  if (!stab_demangle_template (minfo, pp, ptype != NULL ? &name : NULL))
	    {
	      if (name != NULL)
		gdb_free (name);
	      return false;
	    }

	  if (ptype != NULL)
	    {
	      if (name == NULL)
		{
		  stab_bad_demangle (orig_start);
		  return false;
		}

	      context = stab_find_tagged_type (minfo->dhandle, minfo->info,
					       name, strlen (name),
					       DEBUG_KIND_CLASS);
	      gdb_free (name);
	      if (context == DEBUG_TYPE_NULL)
		return false;
	    }
	}
      else
	{
	  unsigned int len;

	  len = stab_demangle_count (pp);

	  if (len == 0 || *pp + len > name_end)
	    {
	      stab_bad_demangle (orig_start);
	      return false;
	    }

	  if (ptype != NULL)
	    {
	      char temp_name_buf[MAX_DEMANGLE_NAME_LENGTH + 1];
	      char *name_ptr = NULL;
	      bool name_on_heap = false;

	      if (len <= MAX_DEMANGLE_NAME_LENGTH)
		{
		  strncpy (temp_name_buf, *pp, len);
		  temp_name_buf[len] = '\0';
		  name_ptr = temp_name_buf;
		}
	      else
		{
		  name_ptr = (char *) gdb_malloc (len + 1);
		  if (name_ptr == NULL)
		    {
		      stab_bad_demangle (orig_start);
		      return false;
		    }
		  strncpy (name_ptr, *pp, len);
		  name_ptr[len] = '\0';
		  name_on_heap = true;
		}

	      const debug_field *fields = NULL;
	      if (context != DEBUG_TYPE_NULL)
		fields = debug_get_fields (minfo->dhandle, context);

	      context = DEBUG_TYPE_NULL;

	      if (fields != NULL)
		{
		  for (; *fields != DEBUG_FIELD_NULL; fields++)
		    {
		      debug_type ft;
		      const char *dn;

		      ft = debug_get_field_type (minfo->dhandle, *fields);
		      if (ft == NULL)
			{
			  if (name_on_heap) gdb_free (name_ptr);
			  return false;
			}
		      dn = debug_get_type_name (minfo->dhandle, ft);
		      if (dn != NULL && strcmp (dn, name_ptr) == 0)
			{
			  context = ft;
			  break;
			}
		    }
		}

	      if (context == DEBUG_TYPE_NULL)
		{
		  if (qualifiers == 0)
		    {
		      context = debug_find_named_type (minfo->dhandle,
						       name_ptr);
		    }

		  if (context == DEBUG_TYPE_NULL)
		    {
		      context = stab_find_tagged_type (minfo->dhandle,
						       minfo->info,
						       name_ptr, len,
						       (qualifiers == 0
							? DEBUG_KIND_ILLEGAL
							: DEBUG_KIND_CLASS));
		      if (context == DEBUG_TYPE_NULL)
			{
			  if (name_on_heap) gdb_free (name_ptr);
			  return false;
			}
		    }
		}

	      if (name_on_heap) gdb_free (name_ptr);
	    }

	  *pp += len;
	}
    }

  if (ptype != NULL)
    *ptype = context;

  return true;
}

/* Demangle a template.  If PNAME is not NULL, this sets *PNAME to a
   string representation of the template.  */

typedef enum {
  VPC_UNKNOWN,
  VPC_POINTER,
  VPC_REAL,
  VPC_INTEGRAL,
  VPC_CHAR,
  VPC_BOOL
} ValueParamCategory;

static ValueParamCategory
get_value_param_category (const char *s)
{
  const char *current = s;
  while (*current != '\0')
    {
      switch (*current)
	{
	case 'P':
	case 'p':
	case 'R':
	  return VPC_POINTER;
	case 'C':
	case 'S':
	case 'U':
	case 'V':
	case 'F':
	case 'M':
	case 'O':
	  current++;
	  continue;
	case 'Q':
	case 'x':
	case 'l':
	case 'i':
	case 's':
	case 'w':
	  return VPC_INTEGRAL;
	case 'b':
	  return VPC_BOOL;
	case 'c':
	  return VPC_CHAR;
	case 'r':
	case 'd':
	case 'f':
	  return VPC_REAL;
	case 'T':
	case 'v':
	  return VPC_UNKNOWN;
	default:
	  return VPC_INTEGRAL;
	}
    }
  return VPC_UNKNOWN;
}

#define REPORT_AND_RETURN_FALSE(original_ptr_start) \
    do { stab_bad_demangle(original_ptr_start); return false; } while (0)

static bool
stab_demangle_template (struct stab_demangle_info *minfo, const char **pp,
			char **pname)
{
  const char *orig = *pp;
  unsigned int param_list_size;
  unsigned int i;

  if (**pp != '_')
    {
      REPORT_AND_RETURN_FALSE(orig);
    }
  ++*pp;

  unsigned int template_name_len = stab_demangle_count (pp);
  if (template_name_len == 0 || strlen (*pp) < template_name_len)
    {
      REPORT_AND_RETURN_FALSE(orig);
    }
  *pp += template_name_len;

  if (stab_demangle_get_count (pp, &param_list_size) == 0)
    {
      REPORT_AND_RETURN_FALSE(orig);
    }

  for (i = 0; i < param_list_size; i++)
    {
      if (**pp == 'Z')
	{
	  ++*pp;
	  if (! stab_demangle_type (minfo, pp, (debug_type *) NULL))
	    {
	      return false;
	    }
	}
      else
	{
	  const char *value_type_start_ptr = *pp;

	  if (! stab_demangle_type (minfo, pp, (debug_type *) NULL))
	    {
	      return false;
	    }

	  ValueParamCategory category = get_value_param_category(value_type_start_ptr);

	  switch (category)
	    {
	    case VPC_INTEGRAL:
	      if (**pp == 'm')
		++*pp;
	      while (ISDIGIT (**pp))
		++*pp;
	      break;

	    case VPC_CHAR:
	      if (**pp == 'm')
		++*pp;
	      unsigned int val_char = stab_demangle_count (pp);
	      if (val_char == 0)
		{
		  REPORT_AND_RETURN_FALSE(orig);
		}
	      break;

	    case VPC_BOOL:
	      unsigned int val_bool = stab_demangle_count (pp);
	      if (val_bool != 0 && val_bool != 1)
		{
		  REPORT_AND_RETURN_FALSE(orig);
		}
	      break;

	    case VPC_REAL:
	      if (**pp == 'm')
		++*pp;
	      while (ISDIGIT (**pp))
		++*pp;
	      if (**pp == '.')
		{
		  ++*pp;
		  while (ISDIGIT (**pp))
		    ++*pp;
		}
	      if (**pp == 'e')
		{
		  ++*pp;
		  while (ISDIGIT (**pp))
		    ++*pp;
		}
	      break;

	    case VPC_POINTER:
	      unsigned int ptr_len = stab_demangle_count (pp);
	      if (ptr_len == 0 || strlen(*pp) < ptr_len)
		{
		  REPORT_AND_RETURN_FALSE(orig);
		}
	      *pp += ptr_len;
	      break;

	    case VPC_UNKNOWN:
	    default:
	      REPORT_AND_RETURN_FALSE(orig);
	    }
	}
    }

  if (pname != NULL)
    {
      char *s1 = NULL, *s2 = NULL, *s3 = NULL;
      bool success = false;

      s1 = savestring (minfo->dhandle, orig, *pp - orig);
      if (s1 == NULL) goto cleanup;

      s2 = concat ("NoSuchStrinG__", s1, (const char *) NULL);
      if (s2 == NULL) goto cleanup;

      s3 = cplus_demangle (s2, demangle_flags);
      if (s3 == NULL) goto cleanup;

      char *s4 = strstr (s3, "::NoSuchStrinG");
      if (s4 == NULL) goto cleanup;

      char *from, *to;
      for (from = to = s3; from != s4; ++from)
	{
	  if (*from != ' ' || (from[1] == '>' && from > s3 && from[-1] == '>'))
	    {
	      *to++ = *from;
	    }
	}
      *to = '\0';

      *pname = savestring (minfo->dhandle, s3, to - s3);
      if (*pname == NULL) goto cleanup;

      success = true;

    cleanup:
      free (s1);
      free (s2);
      free (s3);

      if (!success)
	{
	  REPORT_AND_RETURN_FALSE(orig);
	}
    }

  return true;
}

/* Demangle a class name.  */

static bool
stab_demangle_class (struct stab_demangle_info *minfo ATTRIBUTE_UNUSED,
		     const char **pp, const char **pstart)
{
  const char *orig_pp_val;
  unsigned int n;

  if (pp == NULL)
    {
      return false;
    }

  if (*pp == NULL)
    {
      return false;
    }

  orig_pp_val = *pp;

  n = stab_demangle_count (pp);

  if (strlen (*pp) < n)
    {
      stab_bad_demangle (orig_pp_val);
      return false;
    }

  if (pstart != NULL)
    *pstart = *pp;

  *pp += n;

  return true;
}

/* Demangle function arguments.  If the pargs argument is not NULL, it
   is set to a NULL terminated array holding the arguments.  */

static bool
stab_demangle_args (struct stab_demangle_info *minfo, const char **pp,
		    debug_type **pargs, bool *pvarargs)
{
  const char * const orig_pp_val = *pp;
  const unsigned int initial_alloc_size = 10;
  unsigned int current_alloc_size = initial_alloc_size;
  unsigned int count = 0;
  bool varargs_found = false;
  debug_type *local_args_buffer = NULL;

  enum { STATUS_SUCCESS, STATUS_FAIL, STATUS_BAD_DEMANGLE } status = STATUS_SUCCESS;

  if (pargs != NULL)
    {
      local_args_buffer = xmalloc(current_alloc_size * sizeof(*local_args_buffer));
      if (local_args_buffer == NULL)
        {
          status = STATUS_FAIL;
        }
    }

  if (status == STATUS_SUCCESS)
    {
      while (**pp != '_' && **pp != '\0' && **pp != 'e')
        {
          if (**pp == 'N' || **pp == 'T')
            {
              char temptype = **pp;
              ++*pp;

              unsigned int r_count;
              unsigned int t_index;

              if (temptype == 'T')
                r_count = 1;
              else
                {
                  if (!stab_demangle_get_count (pp, &r_count))
                    {
                      status = STATUS_BAD_DEMANGLE;
                      break;
                    }
                }

              if (!stab_demangle_get_count (pp, &t_index) || t_index >= minfo->typestring_count)
                {
                  status = STATUS_BAD_DEMANGLE;
                  break;
                }

              for (unsigned int i = 0; i < r_count; ++i)
                {
                  const char *temp_arg_str = minfo->typestrings[t_index].typestring;
                  if (!stab_demangle_arg (minfo, &temp_arg_str, &local_args_buffer, &count, &current_alloc_size))
                    {
                      status = STATUS_FAIL;
                      break;
                    }
                }
              if (status != STATUS_SUCCESS) break;
            }
          else
            {
              if (!stab_demangle_arg (minfo, pp, &local_args_buffer, &count, &current_alloc_size))
                {
                  status = STATUS_FAIL;
                  break;
                }
            }
        }
    }

  if (status == STATUS_SUCCESS)
    {
      if (pargs != NULL)
        {
          // Ensure enough space for DEBUG_TYPE_NULL terminator.
          // If count equals current_alloc_size, reallocate for one more element.
          if (count == current_alloc_size) {
              debug_type *new_buffer = xrealloc(local_args_buffer, (current_alloc_size + 1) * sizeof(*new_buffer));
              if (new_buffer == NULL) {
                  status = STATUS_FAIL;
              } else {
                  local_args_buffer = new_buffer;
                  current_alloc_size++;
              }
          }

          if (status == STATUS_SUCCESS) {
              local_args_buffer[count] = DEBUG_TYPE_NULL;

              // Copy to debug_xalloc'd memory, which is the final output format.
              debug_type *final_args = debug_xalloc (minfo->dhandle, (count + 1) * sizeof (*final_args));
              if (final_args == NULL)
                {
                  status = STATUS_FAIL;
                }
              else
                {
                  memcpy (final_args, local_args_buffer, (count + 1) * sizeof (*final_args));
                  *pargs = final_args;
                }
          }
        }

      if (status == STATUS_SUCCESS && **pp == 'e')
        {
          varargs_found = true;
          ++*pp;
        }
    }

  if (pvarargs != NULL)
    *pvarargs = varargs_found;

  if (local_args_buffer != NULL)
    {
      // local_args_buffer holds the xmalloc'd memory.
      // If debug_xalloc succeeded, local_args_buffer has been copied from and should be freed.
      // If debug_xalloc failed, or any earlier failure occurred, local_args_buffer still holds
      // the xmalloc'd data and should be freed.
      free(local_args_buffer);
    }
  
  if (status == STATUS_BAD_DEMANGLE)
    {
      stab_bad_demangle (orig_pp_val);
    }
  
  if (status != STATUS_SUCCESS && pargs != NULL)
    {
      *pargs = NULL;
    }

  return status == STATUS_SUCCESS;
}

/* Demangle a single argument.  */

static bool
stab_demangle_arg (struct stab_demangle_info *minfo, const char **pp,
		   debug_type **pargs, unsigned int *pcount,
		   unsigned int *palloc)
{
  const char *start_ptr;
  debug_type demangled_type_value;
  debug_type *demangled_type_ptr;

  if (pargs != NULL)
    {
      demangled_type_ptr = &demangled_type_value;
    }
  else
    {
      demangled_type_ptr = NULL;
    }

  start_ptr = *pp;
  if (! stab_demangle_type (minfo, pp, demangled_type_ptr)
      || ! stab_demangle_remember_type (minfo, start_ptr, *pp - start_ptr))
    {
      return false;
    }

  if (pargs != NULL)
    {
      if (demangled_type_value == DEBUG_TYPE_NULL)
	{
	  return false;
	}

      if (*pcount + 1 >= *palloc)
	{
	  *palloc += 10;
	  *pargs = xrealloc (*pargs, *palloc * sizeof (**pargs));
	}
      (*pargs)[*pcount] = demangled_type_value;
      ++*pcount;
    }

  return true;
}

/* Demangle a type.  If the ptype argument is not NULL, *ptype is set
   to the newly allocated type.  */

#include <string.h>
#include <limits.h>

static bool stab_demangle_type (struct stab_demangle_info *minfo, const char **pp, debug_type *ptype);

#define INT_TYPE_SIZE 4

static bool
stab_demangle_array_type (struct stab_demangle_info *minfo, const char **pp,
                          debug_type *ptype, const char *orig)
{
  unsigned long high = 0;

  ++*pp;

  while (**pp != '\0' && **pp != '_')
    {
      if (! ISDIGIT (**pp))
        {
          stab_bad_demangle (orig);
          return false;
        }
      if (high > ULONG_MAX / 10
          || (high == ULONG_MAX / 10 && (**pp - '0') > ULONG_MAX % 10))
        {
          stab_bad_demangle (orig);
          return false;
        }
      high = high * 10 + (**pp - '0');
      ++*pp;
    }

  if (**pp != '_')
    {
      stab_bad_demangle (orig);
      return false;
    }
  ++*pp;

  if (! stab_demangle_type (minfo, pp, ptype))
    return false;

  if (ptype != NULL)
    {
      debug_type int_type;
      int_type = debug_find_named_type (minfo->dhandle, "int");
      if (int_type == NULL)
        int_type = debug_make_int_type (minfo->dhandle, INT_TYPE_SIZE, false);
      *ptype = debug_make_array_type (minfo->dhandle, *ptype, int_type, 0, high, false);
    }
  return true;
}

static bool
stab_demangle_back_reference (struct stab_demangle_info *minfo, const char **pp,
                              debug_type *ptype, const char *orig)
{
  unsigned int i;
  const char *p;

  ++*pp;

  if (! stab_demangle_get_count (pp, &i))
    {
      stab_bad_demangle (orig);
      return false;
    }
  if (i >= minfo->typestring_count)
    {
      stab_bad_demangle (orig);
      return false;
    }
  p = minfo->typestrings[i].typestring;
  if (! stab_demangle_type (minfo, &p, ptype))
    return false;
  return true;
}

static bool
stab_demangle_function_type (struct stab_demangle_info *minfo, const char **pp,
                             debug_type *ptype, const char *orig)
{
  debug_type *args = NULL;
  bool varargs = false;

  ++*pp;

  if (! stab_demangle_args (minfo, pp,
                            (ptype == NULL ? NULL : &args),
                            (ptype == NULL ? NULL : &varargs)))
    return false;

  if (**pp != '_')
    {
      stab_bad_demangle (orig);
      return false;
    }
  ++*pp;

  if (! stab_demangle_type (minfo, pp, ptype))
    return false;

  if (ptype != NULL)
    *ptype = debug_make_function_type (minfo->dhandle, *ptype, args, varargs);

  return true;
}

static bool
stab_demangle_member_offset_type (struct stab_demangle_info *minfo, const char **pp,
                                  debug_type *ptype, const char *orig, bool memberp)
{
  debug_type class_type = DEBUG_TYPE_NULL;
  debug_type *args = NULL;
  bool varargs = false;

  ++*pp;

  if (ISDIGIT (**pp))
    {
      unsigned int n = stab_demangle_count (pp);
      const char *name = *pp;

      if (strlen (*pp) < n)
        {
          stab_bad_demangle (orig);
          return false;
        }
      *pp += n;

      if (ptype != NULL)
        {
          class_type = stab_find_tagged_type (minfo->dhandle, minfo->info,
                                              name, (int) n, DEBUG_KIND_CLASS);
          if (class_type == DEBUG_TYPE_NULL)
            {
              stab_bad_demangle (orig);
              return false;
            }
        }
    }
  else if (**pp == 'Q')
    {
      if (! stab_demangle_qualified (minfo, pp,
                                     (ptype == NULL ? NULL : &class_type)))
        return false;
    }
  else
    {
      stab_bad_demangle (orig);
      return false;
    }

  if (memberp)
    {
      if (**pp == 'C' || **pp == 'V')
        {
          ++*pp;
        }
      if (**pp != 'F')
        {
          stab_bad_demangle (orig);
          return false;
        }
      ++*pp;

      if (! stab_demangle_args (minfo, pp,
                                (ptype == NULL ? NULL : &args),
                                (ptype == NULL ? NULL : &varargs)))
        return false;
    }

  if (**pp != '_')
    {
      stab_bad_demangle (orig);
      return false;
    }
  ++*pp;

  if (! stab_demangle_type (minfo, pp, ptype))
    return false;

  if (ptype != NULL)
    {
      if (! memberp)
        {
          *ptype = debug_make_offset_type (minfo->dhandle, class_type, *ptype);
        }
      else
        {
          *ptype = debug_make_method_type (minfo->dhandle, *ptype,
                                           class_type, args, varargs);
        }
    }

  return true;
}


static bool
stab_demangle_type (struct stab_demangle_info *minfo, const char **pp,
		    debug_type *ptype)
{
  const char *orig;

  orig = *pp;

  switch (**pp)
    {
    case 'P':
    case 'p':
    case 'R':
      {
	char type_char = **pp;
	++*pp;
	if (! stab_demangle_type (minfo, pp, ptype))
	  return false;
	if (ptype != NULL)
	  {
	    if (type_char == 'R')
	      *ptype = debug_make_reference_type (minfo->dhandle, *ptype);
	    else
	      *ptype = debug_make_pointer_type (minfo->dhandle, *ptype);
	  }
	break;
      }

    case 'A':
      return stab_demangle_array_type (minfo, pp, ptype, orig);

    case 'T':
      return stab_demangle_back_reference (minfo, pp, ptype, orig);

    case 'F':
      return stab_demangle_function_type (minfo, pp, ptype, orig);

    case 'M':
    case 'O':
      return stab_demangle_member_offset_type (minfo, pp, ptype, orig, **pp == 'M');

    case 'G':
      ++*pp;
      if (! stab_demangle_type (minfo, pp, ptype))
	return false;
      break;

    case 'C':
      ++*pp;
      if (! stab_demangle_type (minfo, pp, ptype))
	return false;
      if (ptype != NULL)
	*ptype = debug_make_const_type (minfo->dhandle, *ptype);
      break;

    case 'Q':
      {
	if (! stab_demangle_qualified (minfo, pp, ptype))
	  return false;
      }
      break;

    default:
      if (! stab_demangle_fund_type (minfo, pp, ptype))
	return false;
      break;
    }

  return true;
}

/* Demangle a fundamental type.  If the ptype argument is not NULL,
   *ptype is set to the newly allocated type.  */

static debug_type
_stab_get_void_type (struct stab_demangle_info *minfo, const char *name)
{
  debug_type type = debug_find_named_type(minfo->dhandle, name);
  if (type == DEBUG_TYPE_NULL)
    type = debug_make_void_type(minfo->dhandle);
  return type;
}

static debug_type
_stab_get_int_type (struct stab_demangle_info *minfo, const char *name, int size, bool is_unsigned)
{
  debug_type type = debug_find_named_type(minfo->dhandle, name);
  if (type == DEBUG_TYPE_NULL)
    type = debug_make_int_type(minfo->dhandle, size, is_unsigned);
  return type;
}

static debug_type
_stab_get_float_type (struct stab_demangle_info *minfo, const char *name, int size)
{
  debug_type type = debug_find_named_type(minfo->dhandle, name);
  if (type == DEBUG_TYPE_NULL)
    type = debug_make_float_type(minfo->dhandle, size);
  return type;
}

static debug_type
_stab_get_bool_type (struct stab_demangle_info *minfo, const char *name, int size)
{
  debug_type type = debug_find_named_type(minfo->dhandle, name);
  if (type == DEBUG_TYPE_NULL)
    type = debug_make_bool_type(minfo->dhandle, size);
  return type;
}

static bool
stab_demangle_fund_type (struct stab_demangle_info *minfo, const char **pp,
			 debug_type *ptype)
{
  const char *orig = *pp;
  bool constp = false;
  bool volatilep = false;
  bool unsignedp = false;
  bool signedp = false;

  bool done_qualifiers = false;
  while (!done_qualifiers)
    {
      switch (**pp)
	{
	case 'C': constp = true; ++*pp; break;
	case 'U': unsignedp = true; ++*pp; break;
	case 'S': signedp = true; ++*pp; break;
	case 'V': volatilep = true; ++*pp; break;
	default: done_qualifiers = true; break;
	}
    }

  switch (**pp)
    {
    case '\0':
    case '_':
      /* cplus_demangle permits this, but I don't know what it means.  */
      stab_bad_demangle (orig);
      return false; /* Corrected: return on bad demangle. */

    case 'v': /* void */
      if (ptype != NULL)
	*ptype = _stab_get_void_type (minfo, "void");
      ++*pp;
      break;

    case 'x': /* long long */
      if (ptype != NULL)
	*ptype = _stab_get_int_type (minfo,
				    (unsignedp ? "long long unsigned int" : "long long int"),
				    8, unsignedp);
      ++*pp;
      break;

    case 'l': /* long */
      if (ptype != NULL)
	*ptype = _stab_get_int_type (minfo,
				    (unsignedp ? "long unsigned int" : "long int"),
				    4, unsignedp);
      ++*pp;
      break;

    case 'i': /* int */
      if (ptype != NULL)
	*ptype = _stab_get_int_type (minfo,
				    (unsignedp ? "unsigned int" : "int"),
				    4, unsignedp);
      ++*pp;
      break;

    case 's': /* short */
      if (ptype != NULL)
	*ptype = _stab_get_int_type (minfo,
				    (unsignedp ? "short unsigned int" : "short int"),
				    2, unsignedp);
      ++*pp;
      break;

    case 'b': /* bool */
      if (ptype != NULL)
	*ptype = _stab_get_bool_type (minfo, "bool", 4);
      ++*pp;
      break;

    case 'c': /* char */
      if (ptype != NULL)
	*ptype = _stab_get_int_type (minfo,
				    (unsignedp ? "unsigned char" : (signedp ? "signed char" : "char")),
				    1, unsignedp);
      ++*pp;
      break;

    case 'w': /* wchar_t */
      if (ptype != NULL)
	*ptype = _stab_get_int_type (minfo, "__wchar_t", 2, true);
      ++*pp;
      break;

    case 'r': /* long double */
      if (ptype != NULL)
	*ptype = _stab_get_float_type (minfo, "long double", 8);
      ++*pp;
      break;

    case 'd': /* double */
      if (ptype != NULL)
	*ptype = _stab_get_float_type (minfo, "double", 8);
      ++*pp;
      break;

    case 'f': /* float */
      if (ptype != NULL)
	*ptype = _stab_get_float_type (minfo, "float", 4);
      ++*pp;
      break;

    case 'G':
      ++*pp;
      if (! ISDIGIT (**pp))
	{
	  stab_bad_demangle (orig);
	  return false;
	}
      /* Fall through.  */
    case '0': case '1': case '2': case '3': case '4':
    case '5': case '6': case '7': case '8': case '9':
      {
	const char *hold;

	if (! stab_demangle_class (minfo, pp, &hold))
	  return false;
	if (ptype != NULL)
	  {
	    char *name = savestring (minfo->dhandle, hold, *pp - hold);
	    *ptype = debug_find_named_type (minfo->dhandle, name);
	    if (*ptype == DEBUG_TYPE_NULL)
	      {
		/* FIXME: It is probably incorrect to assume that
                   undefined types are tagged types.  */
		*ptype = stab_find_tagged_type (minfo->dhandle, minfo->info,
						name, strlen (name),
						DEBUG_KIND_ILLEGAL);
		if (*ptype == DEBUG_TYPE_NULL)
		  return false;
	      }
	  }
      }
      break;

    case 't':
      {
	char *name = NULL;

	if (! stab_demangle_template (minfo, pp,
				      ptype != NULL ? &name : NULL))
	  return false;
	if (ptype != NULL)
	  {
	    *ptype = stab_find_tagged_type (minfo->dhandle, minfo->info,
					    name, strlen (name),
					    DEBUG_KIND_CLASS);
	    if (*ptype == DEBUG_TYPE_NULL)
	      return false;
	  }
      }
      break;

    default:
      stab_bad_demangle (orig);
      return false;
    }

  if (ptype != NULL)
    {
      if (constp)
	*ptype = debug_make_const_type (minfo->dhandle, *ptype);
      if (volatilep)
	*ptype = debug_make_volatile_type (minfo->dhandle, *ptype);
    }

  return true;
}

/* Remember a type string in a demangled string.  */

static bool
stab_demangle_remember_type (struct stab_demangle_info *minfo,
			     const char *p, int len)
{
  if (minfo->typestring_count >= minfo->typestring_alloc)
    {
      size_t new_alloc_size = minfo->typestring_alloc + 10;
      struct stab_typestring_data *new_typestrings_ptr =
        xrealloc (minfo->typestrings,
                  new_alloc_size * sizeof (*minfo->typestrings));
      minfo->typestrings = new_typestrings_ptr;
      minfo->typestring_alloc = new_alloc_size;
    }

  minfo->typestrings[minfo->typestring_count].typestring = p;
  minfo->typestrings[minfo->typestring_count].len = (unsigned int) len;
  minfo->typestring_count++;

  return true;
}

/* Demangle names encoded using the g++ V3 ABI.  The newer versions of
   g++ which use this ABI do not encode ordinary method argument types
   in a mangled name; they simply output the argument types.  However,
   for a static method, g++ simply outputs the return type and the
   physical name.  So in that case we need to demangle the name here.
   Here PHYSNAME is the physical name of the function, and we set the
   variable pointed at by PVARARGS to indicate whether this function
   is varargs.  This returns NULL, or a NULL terminated array of
   argument types.  */

static debug_type *
stab_demangle_v3_argtypes (void *dhandle, struct stab_handle *info,
			   const char *physname, bool *pvarargs)
{
  struct demangle_component *dc;
  void *mem = NULL;
  debug_type *pargs;

  dc = cplus_demangle_v3_components (physname, DMGL_PARAMS | demangle_flags, &mem);
  if (dc == NULL)
    {
      stab_bad_demangle (physname);
      return NULL;
    }

  if (dc->type != DEMANGLE_COMPONENT_TYPED_NAME)
    {
      fprintf (stderr, _("Demangled name is not a function\n"));
      free (mem);
      return NULL;
    }

  struct demangle_component *function_type_component = dc->u.s_binary.right;

  if (function_type_component == NULL || function_type_component->type != DEMANGLE_COMPONENT_FUNCTION_TYPE)
    {
      fprintf (stderr, _("Demangled name is not a function\n"));
      free (mem);
      return NULL;
    }

  struct demangle_component *arg_list_component = function_type_component->u.s_binary.right;

  pargs = stab_demangle_v3_arglist (dhandle, info, arg_list_component, pvarargs);

  free (mem);

  return pargs;
}

/* Demangle an argument list in a struct demangle_component tree.
   Returns a DEBUG_TYPE_NULL terminated array of argument types, and
   sets *PVARARGS to indicate whether this is a varargs function.  */

static const unsigned int INITIAL_ARG_ALLOC_SIZE = 10;
static const unsigned int ARG_ALLOC_GROW_SIZE = 10;

static debug_type *
stab_demangle_v3_arglist (void *dhandle, struct stab_handle *info,
			  struct demangle_component *arglist,
			  bool *pvarargs)
{
  struct demangle_component *dc;
  unsigned int alloc_capacity;
  unsigned int arg_count;
  debug_type *temp_pargs_buffer;
  debug_type *final_xargs_array;

  alloc_capacity = INITIAL_ARG_ALLOC_SIZE;
  temp_pargs_buffer = xmalloc (alloc_capacity * sizeof (*temp_pargs_buffer));
  *pvarargs = false;
  arg_count = 0;

  for (dc = arglist;
       dc != NULL;
       dc = dc->u.s_binary.right)
    {
      debug_type current_arg;
      bool is_varargs_arg;

      if (dc->type != DEMANGLE_COMPONENT_ARGLIST)
	{
	  fprintf (stderr, _("Unexpected type in v3 arglist demangling: component type is %d, expected %d\n"), dc->type, DEMANGLE_COMPONENT_ARGLIST);
	  free (temp_pargs_buffer);
	  return NULL;
	}

      if (dc->u.s_binary.left == NULL)
	break;

      current_arg = stab_demangle_v3_arg (dhandle, info, dc->u.s_binary.left,
				  NULL, &is_varargs_arg);
      if (current_arg == NULL)
	{
	  if (is_varargs_arg)
	    {
	      *pvarargs = true;
	      continue;
	    }
	  fprintf (stderr, _("Failed to demangle an argument in v3 arglist\n"));
	  free (temp_pargs_buffer);
	  return NULL;
	}

      if (arg_count + 1 >= alloc_capacity)
	{
	  alloc_capacity += ARG_ALLOC_GROW_SIZE;
	  temp_pargs_buffer = xrealloc (temp_pargs_buffer, alloc_capacity * sizeof (*temp_pargs_buffer));
	}

      temp_pargs_buffer[arg_count] = current_arg;
      ++arg_count;
    }

  temp_pargs_buffer[arg_count] = DEBUG_TYPE_NULL;
  final_xargs_array = debug_xalloc (dhandle, (arg_count + 1) * sizeof (*temp_pargs_buffer));
  memcpy (final_xargs_array, temp_pargs_buffer, (arg_count + 1) * sizeof (*temp_pargs_buffer));
  free (temp_pargs_buffer);

  return final_xargs_array;
}

/* Convert a struct demangle_component tree describing an argument
   type into a debug_type.  */

static debug_type
find_field_type_in_context(void *dhandle, debug_type context,
                                             const char *name_s, size_t name_len)
{
  if (context == NULL)
    return NULL;

  const debug_field *fields = debug_get_fields(dhandle, context);
  if (fields == NULL)
    return NULL;

  for (; *fields != DEBUG_FIELD_NULL; fields++)
    {
      debug_type ft = debug_get_field_type(dhandle, *fields);
      if (ft == NULL)
        continue;

      const char *dn = debug_get_type_name(dhandle, ft);
      if (dn != NULL && (int) strlen(dn) == name_len && strncmp(dn, name_s, name_len) == 0)
        return ft;
    }
  return NULL;
}

static char *demangle_print_component(struct demangle_component *dc, int flags,
                                      size_t *alloc_size_out, const char *error_msg)
{
  char *p = cplus_demangle_print(flags, dc, 20, alloc_size_out);
  if (p == NULL)
    {
      fprintf(stderr, _("%s\n"), error_msg);
    }
  return p;
}

struct BuiltinTypeMapping {
    const char *name;
    int size;
    bool is_unsigned;
    bool is_float;
    bool is_bool;
    bool is_void;
};

static const struct BuiltinTypeMapping builtin_type_map[] = {
    {"signed char",        1, false, false, false, false},
    {"bool",               1, false, false, true,  false},
    {"char",               1, false, false, false, false},
    {"double",             8, false, true,  false, false},
    {"long double",        8, false, true,  false, false},
    {"float",              4, false, true,  false, false},
    {"__float128",        16, false, true,  false, false},
    {"unsigned char",      1, true,  false, false, false},
    {"int",                4, false, false, false, false},
    {"unsigned int",       4, true,  false, false, false},
    {"long",               4, false, false, false, false},
    {"unsigned long",      4, true,  false, false, false},
    {"__int128",          16, false, false, false, false},
    {"unsigned __int128", 16, true,  false, false, false},
    {"short",              2, false, false, false, false},
    {"unsigned short",     2, true,  false, false, false},
    {"void",               0, false, false, false, true},
    {"wchar_t",            4, true,  false, false, false},
    {"long long",          8, false, false, false, false},
    {"unsigned long long", 8, true,  false, false, false},
    {NULL, 0, false, false, false, false}
};

static debug_type create_builtin_type(void *dhandle, const char *type_name, bool *pvarargs)
{
  if (strcmp(type_name, "...") == 0)
    {
      if (pvarargs == NULL)
        fprintf(stderr, _("Unexpected demangled varargs\n"));
      else
        *pvarargs = true;
      return NULL;
    }

  for (const struct BuiltinTypeMapping *map = builtin_type_map; map->name != NULL; map++)
    {
      if (strcmp(type_name, map->name) == 0)
        {
          if (map->is_void)
            return debug_make_void_type(dhandle);
          if (map->is_bool)
            return debug_make_bool_type(dhandle, map->size);
          if (map->is_float)
            return debug_make_float_type(dhandle, map->size);
          return debug_make_int_type(dhandle, map->size, map->is_unsigned);
        }
    }

  fprintf(stderr, _("Unrecognized demangled builtin type '%s'\n"), type_name);
  return NULL;
}

static debug_type
stab_demangle_v3_arg (void *dhandle, struct stab_handle *info,
		      struct demangle_component *dc, debug_type context,
		      bool *pvarargs)
{
  debug_type dt = NULL;

  if (pvarargs != NULL)
    *pvarargs = false;

  if (dc == NULL)
      return NULL;

  switch (dc->type)
    {
    case DEMANGLE_COMPONENT_NAME:
      dt = find_field_type_in_context(dhandle, context, dc->u.s_name.s, dc->u.s_name.len);
      if (dt != NULL)
        return dt;
      return stab_find_tagged_type(dhandle, info, dc->u.s_name.s, dc->u.s_name.len, DEBUG_KIND_ILLEGAL);

    case DEMANGLE_COMPONENT_QUAL_NAME:
      context = stab_demangle_v3_arg(dhandle, info, dc->u.s_binary.left, context, NULL);
      if (context == NULL)
        return NULL;
      return stab_demangle_v3_arg(dhandle, info, dc->u.s_binary.right, context, NULL);

    case DEMANGLE_COMPONENT_TEMPLATE:
      {
        char *p;
        size_t alc;
        p = demangle_print_component(dc, DMGL_PARAMS | demangle_flags, &alc,
                                     "Failed to print demangled template");
        if (p == NULL)
          return NULL;

        dt = stab_find_tagged_type(dhandle, info, p, strlen(p), DEBUG_KIND_CLASS);
        free(p);
        return dt;
      }

    case DEMANGLE_COMPONENT_SUB_STD:
      return stab_find_tagged_type(dhandle, info, dc->u.s_string.string,
                                   dc->u.s_string.len, DEBUG_KIND_ILLEGAL);

    case DEMANGLE_COMPONENT_RESTRICT:
    case DEMANGLE_COMPONENT_VOLATILE:
    case DEMANGLE_COMPONENT_CONST:
    case DEMANGLE_COMPONENT_POINTER:
    case DEMANGLE_COMPONENT_REFERENCE:
      dt = stab_demangle_v3_arg(dhandle, info, dc->u.s_binary.left, NULL, NULL);
      if (dt == NULL)
        return NULL;

      switch (dc->type)
        {
        case DEMANGLE_COMPONENT_RESTRICT:
          return dt;
        case DEMANGLE_COMPONENT_VOLATILE:
          return debug_make_volatile_type(dhandle, dt);
        case DEMANGLE_COMPONENT_CONST:
          return debug_make_const_type(dhandle, dt);
        case DEMANGLE_COMPONENT_POINTER:
          return debug_make_pointer_type(dhandle, dt);
        case DEMANGLE_COMPONENT_REFERENCE:
          return debug_make_reference_type(dhandle, dt);
        default:
          fprintf(stderr, _("Internal error: Unhandled demangle component type %d in qualifier/pointer switch\n"),
                  (int) dc->type);
          return NULL;
        }

    case DEMANGLE_COMPONENT_FUNCTION_TYPE:
      {
        debug_type *pargs;
        bool varargs_in_arglist = false;

        if (dc->u.s_binary.left == NULL)
          {
            dt = debug_make_void_type(dhandle);
          }
        else
          {
            dt = stab_demangle_v3_arg(dhandle, info, dc->u.s_binary.left, NULL, NULL);
          }
        if (dt == NULL)
          return NULL;

        pargs = stab_demangle_v3_arglist(dhandle, info, dc->u.s_binary.right, &varargs_in_arglist);
        if (pargs == NULL && !varargs_in_arglist)
          {
            return NULL;
          }

        return debug_make_function_type(dhandle, dt, pargs, varargs_in_arglist);
      }

    case DEMANGLE_COMPONENT_BUILTIN_TYPE:
      {
        char *p;
        size_t alc;
        p = demangle_print_component(dc, DMGL_PARAMS | demangle_flags, &alc,
                                     "Couldn't get demangled builtin type");
        if (p == NULL)
          return NULL;

        dt = create_builtin_type(dhandle, p, pvarargs);
        free(p);
        return dt;
      }

    case DEMANGLE_COMPONENT_LOCAL_NAME:
    case DEMANGLE_COMPONENT_TYPED_NAME:
    case DEMANGLE_COMPONENT_TEMPLATE_PARAM:
    case DEMANGLE_COMPONENT_CTOR:
    case DEMANGLE_COMPONENT_DTOR:
    case DEMANGLE_COMPONENT_JAVA_CLASS:
    case DEMANGLE_COMPONENT_RESTRICT_THIS:
    case DEMANGLE_COMPONENT_VOLATILE_THIS:
    case DEMANGLE_COMPONENT_CONST_THIS:
    case DEMANGLE_COMPONENT_VENDOR_TYPE_QUAL:
    case DEMANGLE_COMPONENT_COMPLEX:
    case DEMANGLE_COMPONENT_IMAGINARY:
    case DEMANGLE_COMPONENT_VENDOR_TYPE:
    case DEMANGLE_COMPONENT_ARRAY_TYPE:
    case DEMANGLE_COMPONENT_PTRMEM_TYPE:
    case DEMANGLE_COMPONENT_ARGLIST:
    default:
      fprintf(stderr, _("Unrecognized or unhandled demangle component %d\n"),
              (int) dc->type);
      return NULL;
    }
}
