/* stabs.c -- Parse stabs debugging information
   Copyright (C) 1995-2025 Free Software Foundation, Inc.
   Written by Ian Lance Taylor <ian@cygnus.com>.

   This file is part of GNU Binutils.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* This file contains code which parses stabs debugging information.
   The organization of this code is based on the gdb stabs reading
   code.  The job it does is somewhat different, because it is not
   trying to identify the correct address for anything.  */

#include "sysdep.h"
#include "bfd.h"
#include "libiberty.h"
#include "safe-ctype.h"
#include "demangle.h"
#include "debug.h"
#include "budbg.h"
#include "filenames.h"
#include "aout/aout64.h"
#include "aout/stab_gnu.h"

/* The number of predefined XCOFF types.  */

#define XCOFF_TYPE_COUNT 34

/* This structure is used as a handle so that the stab parsing doesn't
   need to use any static variables.  */

struct stab_handle
{
  /* The BFD.  */
  bfd *abfd;
  /* TRUE if this is stabs in sections.  */
  bool sections;
  /* The symbol table.  */
  asymbol **syms;
  /* The number of symbols.  */
  long symcount;
  /* The accumulated file name string.  */
  char *so_string;
  /* The value of the last N_SO symbol.  */
  bfd_vma so_value;
  /* The value of the start of the file, so that we can handle file
     relative N_LBRAC and N_RBRAC symbols.  */
  bfd_vma file_start_offset;
  /* The offset of the start of the function, so that we can handle
     function relative N_LBRAC and N_RBRAC symbols.  */
  bfd_vma function_start_offset;
  /* The version number of gcc which compiled the current compilation
     unit, 0 if not compiled by gcc.  */
  int gcc_compiled;
  /* Whether an N_OPT symbol was seen that was not generated by gcc,
     so that we can detect the SunPRO compiler.  */
  bool n_opt_found;
  /* The main file name.  */
  char *main_filename;
  /* A stack of unfinished N_BINCL files.  */
  struct bincl_file *bincl_stack;
  /* A list of finished N_BINCL files.  */
  struct bincl_file *bincl_list;
  /* Whether we are inside a function or not.  */
  bool within_function;
  /* The address of the end of the function, used if we have seen an
     N_FUN symbol while in a function.  This is -1 if we have not seen
     an N_FUN (the normal case).  */
  bfd_vma function_end;
  /* The depth of block nesting.  */
  int block_depth;
  /* List of pending variable definitions.  */
  struct stab_pending_var *pending;
  /* Number of files for which we have types.  */
  unsigned int files;
  /* Lists of types per file.  */
  struct stab_types **file_types;
  /* Predefined XCOFF types.  */
  debug_type xcoff_types[XCOFF_TYPE_COUNT];
  /* Undefined tags.  */
  struct stab_tag *tags;
  /* Set by parse_stab_type if it sees a structure defined as a cross
     reference to itself.  Reset by parse_stab_type otherwise.  */
  bool self_crossref;
};

/* A list of these structures is used to hold pending variable
   definitions seen before the N_LBRAC of a block.  */

struct stab_pending_var
{
  /* Next pending variable definition.  */
  struct stab_pending_var *next;
  /* Name.  */
  const char *name;
  /* Type.  */
  debug_type type;
  /* Kind.  */
  enum debug_var_kind kind;
  /* Value.  */
  bfd_vma val;
};

/* A list of these structures is used to hold the types for a single
   file.  */

struct stab_types
{
  /* Next set of slots for this file.  */
  struct stab_types *next;
  /* Where the TYPES array starts.  */
  unsigned int base_index;
  /* Types indexed by type number.  */
#define STAB_TYPES_SLOTS (16)
  debug_type types[STAB_TYPES_SLOTS];
};

/* We keep a list of undefined tags that we encounter, so that we can
   fill them in if the tag is later defined.  */

struct stab_tag
{
  /* Next undefined tag.  */
  struct stab_tag *next;
  /* Tag name.  */
  const char *name;
  /* Type kind.  */
  enum debug_type_kind kind;
  /* Slot to hold real type when we discover it.  If we don't, we fill
     in an undefined tag type.  */
  debug_type slot;
  /* Indirect type we have created to point at slot.  */
  debug_type type;
};

static void bad_stab (const char *);
static void warn_stab (const char *, const char *);
static bool parse_stab_string
  (void *, struct stab_handle *, int, int, bfd_vma,
   const char *, const char *);
static debug_type parse_stab_type
  (void *, struct stab_handle *, const char *, const char **,
   debug_type **, const char *);
static bool parse_stab_type_number
  (const char **, int *, const char *);
static debug_type parse_stab_range_type
  (void *, struct stab_handle *, const char *, const char **,
   const int *, const char *);
static debug_type parse_stab_sun_builtin_type
  (void *, const char **, const char *);
static debug_type parse_stab_sun_floating_type
  (void *, const char **, const char *);
static debug_type parse_stab_enum_type
  (void *, const char **, const char *);
static debug_type parse_stab_struct_type
  (void *, struct stab_handle *, const char *, const char **,
   bool, const int *, const char *);
static bool parse_stab_baseclasses
  (void *, struct stab_handle *, const char **, debug_baseclass **,
   const char *);
static bool parse_stab_struct_fields
  (void *, struct stab_handle *, const char **, debug_field **,
   bool *, const char *);
static bool parse_stab_cpp_abbrev
  (void *, struct stab_handle *, const char **, debug_field *, const char *);
static bool parse_stab_one_struct_field
  (void *, struct stab_handle *, const char **, const char *,
   debug_field *, bool *, const char *);
static bool parse_stab_members
  (void *, struct stab_handle *, const char *, const char **, const int *,
   debug_method **, const char *);
static debug_type parse_stab_argtypes
  (void *, struct stab_handle *, debug_type, const char *, const char *,
   debug_type, const char *, bool, bool, const char **);
static bool parse_stab_tilde_field
  (void *, struct stab_handle *, const char **, const int *, debug_type *,
   bool *, const char *);
static debug_type parse_stab_array_type
  (void *, struct stab_handle *, const char **, bool, const char *);
static void push_bincl (void *, struct stab_handle *, const char *, bfd_vma);
static const char *pop_bincl (struct stab_handle *);
static bool find_excl (struct stab_handle *, const char *, bfd_vma);
static bool stab_record_variable
  (void *, struct stab_handle *, const char *, debug_type,
   enum debug_var_kind, bfd_vma);
static bool stab_emit_pending_vars (void *, struct stab_handle *);
static debug_type *stab_find_slot (void *, struct stab_handle *, const int *);
static debug_type stab_find_type (void *, struct stab_handle *, const int *);
static bool stab_record_type
  (void *, struct stab_handle *, const int *, debug_type);
static debug_type stab_xcoff_builtin_type
  (void *, struct stab_handle *, unsigned int);
static debug_type stab_find_tagged_type
  (void *, struct stab_handle *, const char *, int, enum debug_type_kind);
static debug_type *stab_demangle_argtypes
  (void *, struct stab_handle *, const char *, bool *, unsigned int);
static debug_type *stab_demangle_v3_argtypes
  (void *, struct stab_handle *, const char *, bool *);
static debug_type *stab_demangle_v3_arglist
  (void *, struct stab_handle *, struct demangle_component *, bool *);
static debug_type stab_demangle_v3_arg
  (void *, struct stab_handle *, struct demangle_component *, debug_type,
   bool *);

static int demangle_flags = DMGL_ANSI;

/* Save a string in memory.  */

static char *
savestring (void *dhandle, const char *start, size_t len)
{
  char *ret;

  ret = debug_xalloc (dhandle, len + 1);
  memcpy (ret, start, len);
  ret[len] = '\0';
  return ret;
}

/* Read a number from a string.  */

static void set_overflow(bool *poverflow, const char *orig)
{
  if (poverflow != NULL)
    *poverflow = true;
  else
    warn_stab(orig, _("numeric overflow"));
}

static bool is_valid_input(const char **pp, const char *p_end)
{
  if (*pp >= p_end)
    return false;
  if (**pp == 0)
    return false;
  return true;
}

static bfd_vma handle_strtoul_result(unsigned long ul, const char *orig)
{
  if (*orig == '-')
    return (bfd_vma)(bfd_signed_vma)(long)ul;
  return (bfd_vma)ul;
}

static int parse_sign(const char **p, bool *neg)
{
  *neg = false;
  if (**p == '+')
  {
    (*p)++;
    return 1;
  }
  if (**p == '-')
  {
    *neg = true;
    (*p)++;
    return 1;
  }
  return 0;
}

static int parse_base(const char **p)
{
  if (**p != '0')
    return 10;
  
  if ((*p)[1] == 'x' || (*p)[1] == 'X')
  {
    *p += 2;
    return 16;
  }
  
  (*p)++;
  return 8;
}

static int char_to_digit(int c)
{
  if (ISDIGIT(c))
    return c - '0';
  if (ISUPPER(c))
    return c - 'A';
  if (ISLOWER(c))
    return c - 'a';
  return -1;
}

static bool accumulate_digit(bfd_vma *v, int d, bfd_vma over, bfd_vma lastdig)
{
  if (*v > over || (*v == over && (bfd_vma)d > lastdig))
    return false;
  
  *v = *v * over + d;
  return true;
}

static bfd_vma parse_large_number(const char *orig, const char **pp, bool *poverflow)
{
  const char *p = orig;
  bool neg;
  bfd_vma v = 0;
  
  parse_sign(&p, &neg);
  int base = parse_base(&p);
  
  bfd_vma over = ((bfd_vma)(bfd_signed_vma)-1) / (bfd_vma)base;
  bfd_vma lastdig = ((bfd_vma)(bfd_signed_vma)-1) % (bfd_vma)base;
  
  while (1)
  {
    int d = char_to_digit(*p);
    if (d < 0 || d >= base)
      break;
    
    if (!accumulate_digit(&v, d, over, lastdig))
    {
      set_overflow(poverflow, orig);
      return 0;
    }
    p++;
  }
  
  if (neg)
    v = -v;
  
  return v;
}

static bfd_vma parse_number(const char **pp, bool *poverflow, const char *p_end)
{
  unsigned long ul;
  const char *orig;
  
  if (poverflow != NULL)
    *poverflow = false;
  
  orig = *pp;
  if (!is_valid_input(&orig, p_end))
    return (bfd_vma)0;
  
  errno = 0;
  ul = strtoul(*pp, (char **)pp, 0);
  if (ul + 1 != 0 || errno == 0)
    return handle_strtoul_result(ul, orig);
  
  if (sizeof(bfd_vma) > sizeof(unsigned long))
    return parse_large_number(orig, pp, poverflow);
  
  set_overflow(poverflow, orig);
  return 0;
}

/* Give an error for a bad stab string.  */

static void
bad_stab (const char *p)
{
  fprintf (stderr, _("Bad stab: %s\n"), p);
}

/* Warn about something in a stab string.  */

static void
warn_stab (const char *p, const char *err)
{
  fprintf (stderr, _("Warning: %s: %s\n"), err, p);
}

/* Create a handle to parse stabs symbols with.  */

void *
start_stab (void *dhandle ATTRIBUTE_UNUSED, bfd *abfd, bool sections,
	    asymbol **syms, long symcount)
{
  struct stab_handle *ret;

  ret = xmalloc (sizeof (*ret));
  memset (ret, 0, sizeof (*ret));
  ret->abfd = abfd;
  ret->sections = sections;
  ret->syms = syms;
  ret->symcount = symcount;
  ret->files = 1;
  ret->file_types = xmalloc (sizeof (*ret->file_types));
  ret->file_types[0] = NULL;
  ret->function_end = -1;
  return ret;
}

/* When we have processed all the stabs information, we need to go
   through and fill in all the undefined tags.  */

bool
finish_stab (void *dhandle, void *handle, bool emit)
{
  struct stab_handle *info = (struct stab_handle *) handle;
  bool ret = true;

  if (emit)
    {
      ret = process_pending_function(dhandle, info);
      if (ret)
        ret = create_undefined_tags(dhandle, info);
    }

  cleanup_stab_handle(info);
  return ret;
}

static bool
process_pending_function(void *dhandle, struct stab_handle *info)
{
  if (!info->within_function)
    return true;
    
  return stab_emit_pending_vars(dhandle, info) && 
         debug_end_function(dhandle, info->function_end);
}

static bool
create_undefined_tags(void *dhandle, struct stab_handle *info)
{
  struct stab_tag *st;
  
  for (st = info->tags; st != NULL; st = st->next)
    {
      if (!create_single_undefined_tag(dhandle, st))
        return false;
    }
  return true;
}

static bool
create_single_undefined_tag(void *dhandle, struct stab_tag *st)
{
  enum debug_type_kind kind = determine_tag_kind(st->kind);
  st->slot = debug_make_undefined_tagged_type(dhandle, st->name, kind);
  return st->slot != DEBUG_TYPE_NULL;
}

static enum debug_type_kind
determine_tag_kind(enum debug_type_kind kind)
{
  return (kind == DEBUG_KIND_ILLEGAL) ? DEBUG_KIND_STRUCT : kind;
}

static void
cleanup_stab_handle(struct stab_handle *info)
{
  free(info->file_types);
  free(info->so_string);
  free(info);
}

/* Handle a single stabs symbol.  */

bool
handle_so_string(void *dhandle, struct stab_handle *info)
{
  size_t len = strlen(info->so_string) + 1;
  char *copy = debug_xalloc(dhandle, len);
  memcpy(copy, info->so_string, len);
  
  if (!debug_set_filename(dhandle, copy))
    return false;
  
  info->main_filename = copy;
  free(info->so_string);
  info->so_string = NULL;
  info->gcc_compiled = 0;
  info->n_opt_found = false;
  
  if (!info->sections)
    info->file_start_offset = info->so_value;
  
  info->files = 1;
  info->file_types = xrealloc(info->file_types, sizeof(*info->file_types));
  info->file_types[0] = NULL;
  
  return true;
}

bool
handle_lbrac(void *dhandle, struct stab_handle *info, int desc, bfd_vma value)
{
  if (info->n_opt_found && desc == 1)
    return true;
  
  if (!info->within_function)
  {
    fprintf(stderr, _("N_LBRAC not within function\n"));
    return false;
  }
  
  bfd_vma block_value = value + info->file_start_offset + info->function_start_offset;
  
  if (!debug_start_block(dhandle, block_value))
    return false;
  
  if (!stab_emit_pending_vars(dhandle, info))
    return false;
  
  ++info->block_depth;
  return true;
}

bool
handle_rbrac(void *dhandle, struct stab_handle *info, int desc, bfd_vma value)
{
  if (info->n_opt_found && desc == 1)
    return true;
  
  if (!stab_emit_pending_vars(dhandle, info))
    return false;
  
  bfd_vma block_value = value + info->file_start_offset + info->function_start_offset;
  
  if (!debug_end_block(dhandle, block_value))
    return false;
  
  --info->block_depth;
  
  if (info->block_depth < 0)
  {
    fprintf(stderr, _("Too many N_RBRACs\n"));
    return false;
  }
  
  return true;
}

bool
end_function(void *dhandle, struct stab_handle *info, bfd_vma value, const char *string)
{
  if (!info->within_function)
    return true;
  
  bfd_vma endval = value;
  
  if (*string != '\0' && info->function_end != (bfd_vma)-1 && info->function_end < endval)
    endval = info->function_end;
  
  if (!stab_emit_pending_vars(dhandle, info) || !debug_end_function(dhandle, endval))
    return false;
  
  info->within_function = false;
  info->function_end = (bfd_vma)-1;
  
  return true;
}

bool
handle_so(void *dhandle, struct stab_handle *info, bfd_vma value, const char *string)
{
  if (!end_function(dhandle, info, value, string))
    return false;
  
  if (*string == '\0')
    return true;
  
  if (info->so_string == NULL)
  {
    info->so_string = xstrdup(string);
  }
  else
  {
    char *f = info->so_string;
    
    if (IS_ABSOLUTE_PATH(string))
      info->so_string = xstrdup(string);
    else
      info->so_string = concat(info->so_string, string, (const char *)NULL);
    
    free(f);
  }
  
  info->so_value = value;
  return true;
}

char*
create_debug_copy(void *dhandle, const char *string)
{
  size_t len = strlen(string) + 1;
  char *copy = debug_xalloc(dhandle, len);
  memcpy(copy, string, len);
  return copy;
}

bool
handle_include_file(void *dhandle, const char *string)
{
  char *copy = create_debug_copy(dhandle, string);
  return debug_start_source(dhandle, copy);
}

bool
handle_bincl(void *dhandle, struct stab_handle *info, const char *string, bfd_vma value)
{
  char *copy = create_debug_copy(dhandle, string);
  push_bincl(dhandle, info, copy, value);
  return debug_start_source(dhandle, copy);
}

bool
handle_fun(void *dhandle, struct stab_handle *info, bfd_vma value, const char *string)
{
  if (*string == '\0')
  {
    if (!info->within_function)
      return true;
    
    if (info->sections)
      value += info->function_start_offset;
    
    if (!stab_emit_pending_vars(dhandle, info) || !debug_end_function(dhandle, value))
      return false;
    
    info->within_function = false;
    info->function_end = (bfd_vma)-1;
    return true;
  }
  
  if (info->within_function && (info->function_end == (bfd_vma)-1 || value < info->function_end))
    info->function_end = value;
  
  return true;
}

bool
handle_function_start(void *dhandle, struct stab_handle *info, const char *string, bfd_vma value)
{
  const char *colon = strchr(string, ':');
  
  if (colon == NULL || (colon[1] != 'f' && colon[1] != 'F'))
    return true;
  
  if (info->within_function)
  {
    bfd_vma endval = value;
    
    if (info->function_end != (bfd_vma)-1 && info->function_end < endval)
      endval = info->function_end;
    
    if (!stab_emit_pending_vars(dhandle, info) || !debug_end_function(dhandle, endval))
      return false;
    
    info->function_end = (bfd_vma)-1;
  }
  
  if (info->sections)
    info->function_start_offset = value;
  
  info->within_function = true;
  return true;
}

bool
handle_opt(struct stab_handle *info, const char *string)
{
  if (string == NULL)
  {
    info->n_opt_found = true;
    return true;
  }
  
  if (strcmp(string, "gcc2_compiled.") == 0)
    info->gcc_compiled = 2;
  else if (strcmp(string, "gcc_compiled.") == 0)
    info->gcc_compiled = 1;
  else
    info->n_opt_found = true;
  
  return true;
}

bool
parse_stab(void *dhandle, void *handle, int type, int desc, bfd_vma value, const char *string)
{
  struct stab_handle *info = (struct stab_handle *)handle;
  const char *string_end = string + strlen(string);
  
  if (info->so_string != NULL && (type != N_SO || *string == '\0' || value != info->so_value))
  {
    if (!handle_so_string(dhandle, info))
      return false;
  }
  
  switch (type)
  {
    case N_FN:
    case N_FN_SEQ:
      break;
      
    case N_LBRAC:
      return handle_lbrac(dhandle, info, desc, value);
      
    case N_RBRAC:
      return handle_rbrac(dhandle, info, desc, value);
      
    case N_SO:
      return handle_so(dhandle, info, value, string);
      
    case N_SOL:
      return handle_include_file(dhandle, string);
      
    case N_BINCL:
      return handle_bincl(dhandle, info, string, value);
      
    case N_EINCL:
      return debug_start_source(dhandle, pop_bincl(info));
      
    case N_EXCL:
      return find_excl(info, string, value);
      
    case N_SLINE:
      return debug_record_line(dhandle, desc, 
                              value + (info->within_function ? info->function_start_offset : 0));
      
    case N_BCOMM:
      return debug_start_common_block(dhandle, string);
      
    case N_ECOMM:
      return debug_end_common_block(dhandle, string);
      
    case N_FUN:
      if (!handle_fun(dhandle, info, value, string))
        return false;
      
      if (*string == '\0')
        break;
      
    default:
      if (!handle_function_start(dhandle, info, string, value))
        return false;
      
      return parse_stab_string(dhandle, info, type, desc, value, string, string_end);
      
    case N_OPT:
      return handle_opt(info, string);
      
    case N_OBJ:
    case N_ENDM:
    case N_MAIN:
    case N_WARNING:
      break;
  }
  
  return true;
}

/* Parse the stabs string.  */

static bool
parse_type_and_record_variable(void *dhandle, struct stab_handle *info,
                               const char *name, const char **p,
                               int variable_kind, bfd_vma value,
                               const char *string_end)
{
  debug_type dtype = parse_stab_type(dhandle, info, NULL, p, NULL, string_end);
  if (dtype == DEBUG_TYPE_NULL)
    return false;
  return stab_record_variable(dhandle, info, name, dtype, variable_kind, value);
}

static bool
parse_type_and_record_parameter(void *dhandle, struct stab_handle *info,
                                const char *name, const char **p,
                                int param_kind, bfd_vma value,
                                const char *string_end)
{
  debug_type dtype = parse_stab_type(dhandle, info, NULL, p, NULL, string_end);
  if (dtype == DEBUG_TYPE_NULL)
    return false;
  return debug_record_parameter(dhandle, name, dtype, param_kind, value);
}

static bool
skip_function_arguments(void *dhandle, struct stab_handle *info,
                       const char **p, const char *string_end)
{
  while (**p == ';')
  {
    ++(*p);
    if (parse_stab_type(dhandle, info, NULL, p, NULL, string_end) == DEBUG_TYPE_NULL)
      return false;
  }
  return true;
}

static const char*
find_type_separator(const char *string)
{
  const char *p = strchr(string, ':');
  if (p == NULL)
    return NULL;
  
  while (p[1] == ':')
  {
    p += 2;
    p = strchr(p, ':');
    if (p == NULL)
      return NULL;
  }
  return p;
}

static char*
extract_name(void *dhandle, const char *string, const char *p)
{
  if (p == string || (string[0] == ' ' && p == string + 1))
    return NULL;
  return savestring(dhandle, string, p - string);
}

static char*
decode_special_name(const char *string)
{
  if (string[0] != '$')
    return NULL;
    
  switch (string[1])
  {
  case 't':
    return "this";
  case 'e':
    return "eh_throw";
  case 'v':
  case '_':
  case 'X':
    break;
  default:
    warn_stab(string, _("unknown C++ encoded name"));
    break;
  }
  return NULL;
}

static int
determine_type_code(const char *p, const char *string)
{
  if (ISDIGIT(*p) || *p == '(' || *p == '-')
    return 'l';
  if (*p == 0)
  {
    bad_stab(string);
    return 0;
  }
  return *p;
}

static bool
handle_constant(void *dhandle, struct stab_handle *info, const char *name,
               const char **p, const char *string, const char *string_end)
{
  if (**p != '=')
  {
    bad_stab(string);
    return false;
  }
  ++(*p);
  
  switch (*(*p)++)
  {
  case 'r':
    return debug_record_float_const(dhandle, name, atof(*p));
  case 'i':
    return debug_record_int_const(dhandle, name, atoi(*p));
  case 'e':
    {
      debug_type dtype = parse_stab_type(dhandle, info, NULL, p, NULL, string_end);
      if (dtype == DEBUG_TYPE_NULL)
        return false;
      if (**p != ',')
      {
        bad_stab(string);
        return false;
      }
      return debug_record_typed_const(dhandle, name, dtype, atoi(*p));
    }
  default:
    bad_stab(string);
    return false;
  }
}

static bool
handle_function(void *dhandle, struct stab_handle *info, const char *name,
               const char **p, int type, bfd_vma value, const char *string_end)
{
  debug_type dtype = parse_stab_type(dhandle, info, NULL, p, NULL, string_end);
  if (dtype == DEBUG_TYPE_NULL)
    return false;
  if (!debug_record_function(dhandle, name, dtype, type == 'F', value))
    return false;
  return skip_function_arguments(dhandle, info, p, string_end);
}

static bool
handle_global_symbol(void *dhandle, struct stab_handle *info, const char *name,
                    const char **p, bfd_vma value, const char *string_end)
{
  debug_type dtype = parse_stab_type(dhandle, info, NULL, p, NULL, string_end);
  if (dtype == DEBUG_TYPE_NULL)
    return false;
    
  if (name != NULL)
  {
    asymbol **ps;
    char leading = bfd_get_symbol_leading_char(info->abfd);
    long c;
    
    for (c = info->symcount, ps = info->syms; c > 0; --c, ++ps)
    {
      const char *n = bfd_asymbol_name(*ps);
      if (leading != '\0' && *n == leading)
        ++n;
      if (*n == *name && strcmp(n, name) == 0)
      {
        value = bfd_asymbol_value(*ps);
        break;
      }
    }
  }
  
  return stab_record_variable(dhandle, info, name, dtype, DEBUG_GLOBAL, value);
}

static bool
handle_fortran_parameter(void *dhandle, struct stab_handle *info, const char *name,
                        const char **p, bfd_vma value, const char *string_end)
{
  ++(*p);
  debug_type dtype = parse_stab_type(dhandle, info, NULL, p, NULL, string_end);
  if (dtype == DEBUG_TYPE_NULL)
    return false;
    
  debug_type ftype = debug_make_function_type(dhandle, dtype, NULL, false);
  dtype = debug_make_pointer_type(dhandle, ftype);
  return debug_record_parameter(dhandle, name, dtype, DEBUG_PARM_STACK, value);
}

static bool
handle_typedef(void *dhandle, struct stab_handle *info, char *name,
              const char **p, const char *string_end)
{
  debug_type *slot;
  debug_type dtype = parse_stab_type(dhandle, info, name, p, &slot, string_end);
  if (dtype == DEBUG_TYPE_NULL)
    return false;
  if (name == NULL)
    return true;
    
  dtype = debug_name_type(dhandle, name, dtype);
  if (dtype == DEBUG_TYPE_NULL)
    return false;
  if (slot != NULL)
    *slot = dtype;
  return true;
}

static bool
update_cross_references(struct stab_handle *info, const char *name, debug_type dtype)
{
  struct stab_tag **pst;
  for (pst = &info->tags; *pst != NULL; pst = &(*pst)->next)
  {
    if ((*pst)->name[0] == name[0] && strcmp((*pst)->name, name) == 0)
    {
      (*pst)->slot = dtype;
      *pst = (*pst)->next;
      break;
    }
  }
  return true;
}

static bool
handle_struct_tag(void *dhandle, struct stab_handle *info, char *name,
                 const char **p, const char *string_end)
{
  bool synonym = false;
  if (**p == 't')
  {
    synonym = true;
    ++(*p);
  }
  
  debug_type *slot;
  debug_type dtype = parse_stab_type(dhandle, info, name, p, &slot, string_end);
  if (dtype == DEBUG_TYPE_NULL)
    return false;
  if (name == NULL)
    return true;
    
  bool self_crossref = info->self_crossref;
  dtype = debug_tag_type(dhandle, name, dtype);
  if (dtype == DEBUG_TYPE_NULL)
    return false;
  if (slot != NULL)
    *slot = dtype;
    
  if (!self_crossref)
    update_cross_references(info, name, dtype);
    
  if (synonym)
  {
    dtype = debug_name_type(dhandle, name, dtype);
    if (dtype == DEBUG_TYPE_NULL)
      return false;
    if (slot != NULL)
      *slot = dtype;
  }
  return true;
}

static bool
handle_namespace_mapping(const char **p)
{
  if (*(*p)++ != 0 && *(*p)++ == 'n' && *(*p)++ == '0')
  {
    while (**p && **p != ';')
      ++(*p);
    if (**p)
      return true;
  }
  return false;
}

static bool
parse_stab_string(void *dhandle, struct stab_handle *info, int stabtype,
                 int desc ATTRIBUTE_UNUSED, bfd_vma value,
                 const char *string, const char *string_end)
{
  const char *p = find_type_separator(string);
  if (p == NULL)
  {
    if (strchr(string, ':') == NULL)
      return true;
    bad_stab(string);
    return false;
  }
  
  char *name = decode_special_name(string);
  if (name == NULL)
    name = extract_name(dhandle, string, p);
    
  ++p;
  int type = determine_type_code(p, string);
  if (type == 0)
    return false;
  if (type != 'l')
    ++p;
    
  switch (type)
  {
  case 'c':
    return handle_constant(dhandle, info, name, &p, string, string_end);
    
  case 'C':
    {
      debug_type dtype = parse_stab_type(dhandle, info, NULL, &p, NULL, string_end);
      if (dtype == DEBUG_TYPE_NULL)
        return false;
      return debug_record_label(dhandle, name, dtype, value);
    }
    
  case 'f':
  case 'F':
    return handle_function(dhandle, info, name, &p, type, value, string_end);
    
  case 'G':
    return handle_global_symbol(dhandle, info, name, &p, value, string_end);
    
  case 'l':
  case 's':
    return parse_type_and_record_variable(dhandle, info, name, &p, DEBUG_LOCAL, value, string_end);
    
  case 'p':
    if (*p == 'F')
      return handle_fortran_parameter(dhandle, info, name, &p, value, string_end);
    return parse_type_and_record_parameter(dhandle, info, name, &p, DEBUG_PARM_STACK, value, string_end);
    
  case 'P':
    if (stabtype == N_FUN)
      return skip_function_arguments(dhandle, info, &p, string_end);
  case 'R':
    return parse_type_and_record_parameter(dhandle, info, name, &p, DEBUG_PARM_REG, value, string_end);
    
  case 'r':
    return parse_type_and_record_variable(dhandle, info, name, &p, DEBUG_REGISTER, value, string_end);
    
  case 'S':
    return parse_type_and_record_variable(dhandle, info, name, &p, DEBUG_STATIC, value, string_end);
    
  case 't':
    return handle_typedef(dhandle, info, name, &p, string_end);
    
  case 'T':
    return handle_struct_tag(dhandle, info, name, &p, string_end);
    
  case 'V':
    return parse_type_and_record_variable(dhandle, info, name, &p, DEBUG_LOCAL_STATIC, value, string_end);
    
  case 'v':
    return parse_type_and_record_parameter(dhandle, info, name, &p, DEBUG_PARM_REFERENCE, value, string_end);
    
  case 'a':
    return parse_type_and_record_parameter(dhandle, info, name, &p, DEBUG_PARM_REF_REG, value, string_end);
    
  case 'X':
    return parse_type_and_record_variable(dhandle, info, name, &p, DEBUG_LOCAL, value, string_end);
    
  case 'Y':
    if (handle_namespace_mapping(&p))
      return true;
    
  default:
    bad_stab(string);
    return false;
  }
}

/* Parse a stabs type.  The typename argument is non-NULL if this is a
   typedef or a tag definition.  The pp argument points to the stab
   string, and is updated.  The slotp argument points to a place to
   store the slot used if the type is being defined.  */

static debug_type parse_stab_subtype(void *dhandle, struct stab_handle *info, const char **pp, const char *p_end)
{
    return parse_stab_type(dhandle, info, (const char *)NULL, pp, (debug_type **)NULL, p_end);
}

static bool validate_and_skip_comma(const char **pp, const char *orig)
{
    if (**pp != ',')
    {
        bad_stab(orig);
        return false;
    }
    ++*pp;
    return true;
}

static bool validate_and_skip_semicolon(const char **pp, const char *orig)
{
    if (**pp != ';')
    {
        bad_stab(orig);
        return false;
    }
    ++*pp;
    return true;
}

static bool parse_type_attributes(const char **pp, const char *orig, int *size, bool *stringp)
{
    while (**pp == '@')
    {
        const char *p = *pp + 1;
        const char *attr;

        if (ISDIGIT(*p) || *p == '(' || *p == '-')
            break;

        attr = p;
        for (; *p != ';'; ++p)
        {
            if (*p == '\0')
            {
                bad_stab(orig);
                return false;
            }
        }
        *pp = p + 1;

        switch (*attr)
        {
        case 's':
            *size = atoi(attr + 1) / 8;
            if (*size <= 0)
                *size = -1;
            break;
        case 'S':
            *stringp = true;
            break;
        case 0:
            bad_stab(orig);
            return false;
        default:
            break;
        }
    }
    return true;
}

static enum debug_type_kind get_cross_reference_code(char c, const char *orig)
{
    switch (c)
    {
    case 's':
        return DEBUG_KIND_STRUCT;
    case 'u':
        return DEBUG_KIND_UNION;
    case 'e':
        return DEBUG_KIND_ENUM;
    case 0:
        bad_stab(orig);
        return DEBUG_KIND_STRUCT;
    default:
        warn_stab(orig, _("unrecognized cross reference type"));
        return DEBUG_KIND_STRUCT;
    }
}

static const char *find_cross_reference_end(const char *pp)
{
    const char *q1 = strchr(pp, '<');
    const char *p = strchr(pp, ':');

    if (p == NULL)
        return NULL;

    if (q1 != NULL && p > q1 && p[1] == ':')
    {
        int nest = 0;
        const char *q2;

        for (q2 = q1; *q2 != '\0'; ++q2)
        {
            if (*q2 == '<')
                ++nest;
            else if (*q2 == '>')
                --nest;
            else if (*q2 == ':' && nest == 0)
                break;
        }
        return (*q2 == ':') ? q2 : NULL;
    }
    return p;
}

static debug_type handle_cross_reference(void *dhandle, struct stab_handle *info, const char **pp, const char *orig, const char *type_name)
{
    enum debug_type_kind code = get_cross_reference_code(**pp, orig);
    if (**pp == 0)
        return DEBUG_TYPE_NULL;
    
    ++*pp;

    const char *p = find_cross_reference_end(*pp);
    if (p == NULL)
    {
        bad_stab(orig);
        return DEBUG_TYPE_NULL;
    }

    if (type_name != NULL && strncmp(type_name, *pp, p - *pp) == 0 && type_name[p - *pp] == '\0')
        info->self_crossref = true;

    debug_type dtype = stab_find_tagged_type(dhandle, info, *pp, p - *pp, code);
    *pp = p + 1;
    return dtype;
}

static debug_type handle_type_reference(void *dhandle, struct stab_handle *info, const char **pp, int *typenums, const char *p_end)
{
    const char *hold;
    int xtypenums[2];

    (*pp)--;
    hold = *pp;

    if (!parse_stab_type_number(pp, xtypenums, p_end))
        return DEBUG_TYPE_NULL;

    if (typenums[0] == xtypenums[0] && typenums[1] == xtypenums[1])
        return debug_make_void_type(dhandle);

    *pp = hold;
    return parse_stab_subtype(dhandle, info, pp, p_end);
}

static debug_type handle_offset_type(void *dhandle, struct stab_handle *info, const char **pp, const char *orig, const char *p_end)
{
    debug_type domain = parse_stab_subtype(dhandle, info, pp, p_end);
    if (domain == DEBUG_TYPE_NULL)
        return DEBUG_TYPE_NULL;

    if (!validate_and_skip_comma(pp, orig))
        return DEBUG_TYPE_NULL;

    debug_type memtype = parse_stab_subtype(dhandle, info, pp, p_end);
    if (memtype == DEBUG_TYPE_NULL)
        return DEBUG_TYPE_NULL;

    return debug_make_offset_type(dhandle, domain, memtype);
}

static debug_type handle_method_type_simple(void *dhandle, struct stab_handle *info, const char **pp, const char *orig, const char *p_end)
{
    ++*pp;
    debug_type return_type = parse_stab_subtype(dhandle, info, pp, p_end);
    if (return_type == DEBUG_TYPE_NULL)
        return DEBUG_TYPE_NULL;

    if (!validate_and_skip_semicolon(pp, orig))
        return DEBUG_TYPE_NULL;

    return debug_make_method_type(dhandle, return_type, DEBUG_TYPE_NULL, (debug_type *)NULL, false);
}

#define INITIAL_ARG_ALLOC 10
#define ARG_ALLOC_INCREMENT 10

static debug_type *parse_method_args(void *dhandle, struct stab_handle *info, const char **pp, const char *orig, unsigned int *n_out, const char *p_end)
{
    unsigned int alloc = INITIAL_ARG_ALLOC;
    debug_type *args = xmalloc(alloc * sizeof(*args));
    unsigned int n = 0;

    while (**pp != ';')
    {
        if (!validate_and_skip_comma(pp, orig))
        {
            free(args);
            return NULL;
        }

        if (n + 1 >= alloc)
        {
            alloc += ARG_ALLOC_INCREMENT;
            args = xrealloc(args, alloc * sizeof(*args));
        }

        args[n] = parse_stab_subtype(dhandle, info, pp, p_end);
        if (args[n] == DEBUG_TYPE_NULL)
        {
            free(args);
            return NULL;
        }
        ++n;
    }
    ++*pp;
    
    *n_out = n;
    return args;
}

static debug_type handle_method_type_complex(void *dhandle, struct stab_handle *info, const char **pp, const char *orig, const char *p_end)
{
    debug_type domain = parse_stab_subtype(dhandle, info, pp, p_end);
    if (domain == DEBUG_TYPE_NULL)
        return DEBUG_TYPE_NULL;

    if (!validate_and_skip_comma(pp, orig))
        return DEBUG_TYPE_NULL;

    debug_type return_type = parse_stab_subtype(dhandle, info, pp, p_end);
    if (return_type == DEBUG_TYPE_NULL)
        return DEBUG_TYPE_NULL;

    unsigned int n;
    debug_type *args = parse_method_args(dhandle, info, pp, orig, &n, p_end);
    if (args == NULL)
        return DEBUG_TYPE_NULL;

    bool varargs = (n == 0 || debug_get_type_kind(dhandle, args[n - 1]) != DEBUG_KIND_VOID);
    if (!varargs && n > 0)
        --n;

    args[n] = DEBUG_TYPE_NULL;
    debug_type *xargs = debug_xalloc(dhandle, (n + 1) * sizeof(*args));
    memcpy(xargs, args, (n + 1) * sizeof(*args));
    free(args);

    return debug_make_method_type(dhandle, return_type, domain, xargs, varargs);
}

static debug_type handle_method_type(void *dhandle, struct stab_handle *info, const char **pp, const char *orig, const char *p_end)
{
    if (**pp == '#')
        return handle_method_type_simple(dhandle, info, pp, orig, p_end);
    return handle_method_type_complex(dhandle, info, pp, orig, p_end);
}

static bool should_parse_type_number(const char *p)
{
    return ISDIGIT(*p) || *p == '(' || *p == '-';
}

static debug_type
parse_stab_type(void *dhandle, struct stab_handle *info, const char *type_name, const char **pp, debug_type **slotp, const char *p_end)
{
    const char *orig;
    int typenums[2];
    int size = -1;
    bool stringp = false;
    int descriptor;
    debug_type dtype;

    if (slotp != NULL)
        *slotp = NULL;

    orig = *pp;
    if (orig >= p_end)
        return DEBUG_TYPE_NULL;

    info->self_crossref = false;

    if (!should_parse_type_number(**pp))
    {
        typenums[0] = typenums[1] = -1;
    }
    else
    {
        if (!parse_stab_type_number(pp, typenums, p_end))
            return DEBUG_TYPE_NULL;

        if (**pp != '=')
            return stab_find_type(dhandle, info, typenums);

        if (slotp != NULL && typenums[0] >= 0 && typenums[1] >= 0)
            *slotp = stab_find_slot(dhandle, info, typenums);

        ++*pp;

        if (!parse_type_attributes(pp, orig, &size, &stringp))
            return DEBUG_TYPE_NULL;
    }

    descriptor = **pp;
    ++*pp;

    switch (descriptor)
    {
    case 'x':
        dtype = handle_cross_reference(dhandle, info, pp, orig, type_name);
        break;

    case '-':
    case '0':
    case '1':
    case '2':
    case '3':
    case '4':
    case '5':
    case '6':
    case '7':
    case '8':
    case '9':
    case '(':
        dtype = handle_type_reference(dhandle, info, pp, typenums, p_end);
        if (dtype == DEBUG_TYPE_NULL)
            return DEBUG_TYPE_NULL;
        if (typenums[0] != -1)
        {
            if (!stab_record_type(dhandle, info, typenums, dtype))
                return DEBUG_TYPE_NULL;
        }
        break;

    case '*':
        dtype = debug_make_pointer_type(dhandle, parse_stab_subtype(dhandle, info, pp, p_end));
        break;

    case '&':
        dtype = debug_make_reference_type(dhandle, parse_stab_subtype(dhandle, info, pp, p_end));
        break;

    case 'f':
        dtype = debug_make_function_type(dhandle, parse_stab_subtype(dhandle, info, pp, p_end), (debug_type *)NULL, false);
        break;

    case 'k':
        dtype = debug_make_const_type(dhandle, parse_stab_subtype(dhandle, info, pp, p_end));
        break;

    case 'B':
        dtype = debug_make_volatile_type(dhandle, parse_stab_subtype(dhandle, info, pp, p_end));
        break;

    case '@':
        dtype = handle_offset_type(dhandle, info, pp, orig, p_end);
        break;

    case '#':
        dtype = handle_method_type(dhandle, info, pp, orig, p_end);
        break;

    case 'r':
        dtype = parse_stab_range_type(dhandle, info, type_name, pp, typenums, p_end);
        break;

    case 'b':
        dtype = parse_stab_sun_builtin_type(dhandle, pp, p_end);
        break;

    case 'R':
        dtype = parse_stab_sun_floating_type(dhandle, pp, p_end);
        break;

    case 'e':
        dtype = parse_stab_enum_type(dhandle, pp, p_end);
        break;

    case 's':
    case 'u':
        dtype = parse_stab_struct_type(dhandle, info, type_name, pp, descriptor == 's', typenums, p_end);
        break;

    case 'a':
        if (**pp != 'r')
        {
            bad_stab(orig);
            return DEBUG_TYPE_NULL;
        }
        ++*pp;
        dtype = parse_stab_array_type(dhandle, info, pp, stringp, p_end);
        break;

    case 'S':
        dtype = debug_make_set_type(dhandle, parse_stab_subtype(dhandle, info, pp, p_end), stringp);
        break;

    default:
        bad_stab(orig);
        return DEBUG_TYPE_NULL;
    }

    if (dtype == DEBUG_TYPE_NULL)
        return DEBUG_TYPE_NULL;

    if (typenums[0] != -1)
    {
        if (!stab_record_type(dhandle, info, typenums, dtype))
            return DEBUG_TYPE_NULL;
    }

    if (size != -1)
    {
        if (!debug_record_type_size(dhandle, dtype, (unsigned int)size))
            return DEBUG_TYPE_NULL;
    }

    return dtype;
}

/* Read a number by which a type is referred to in dbx data, or
   perhaps read a pair (FILENUM, TYPENUM) in parentheses.  Just a
   single number N is equivalent to (0,N).  Return the two numbers by
   storing them in the vector TYPENUMS.  */

static bool parse_simple_type_number(const char **pp, int *typenums, const char *p_end)
{
    typenums[0] = 0;
    typenums[1] = (int) parse_number(pp, (bool *) NULL, p_end);
    return true;
}

static bool parse_complex_type_number(const char **pp, int *typenums, const char *p_end, const char *orig)
{
    ++*pp;
    typenums[0] = (int) parse_number(pp, (bool *) NULL, p_end);
    
    if (**pp != ',')
    {
        bad_stab(orig);
        return false;
    }
    
    ++*pp;
    typenums[1] = (int) parse_number(pp, (bool *) NULL, p_end);
    
    if (**pp != ')')
    {
        bad_stab(orig);
        return false;
    }
    
    ++*pp;
    return true;
}

static bool parse_stab_type_number(const char **pp, int *typenums, const char *p_end)
{
    const char *orig = *pp;
    
    if (**pp != '(')
    {
        return parse_simple_type_number(pp, typenums, p_end);
    }
    
    return parse_complex_type_number(pp, typenums, p_end, orig);
}

/* Parse a range type.  */

#define LLLOW   "01000000000000000000000;"
#define LLHIGH   "0777777777777777777777;"
#define ULLHIGH "01777777777777777777777;"
#define CHAR_MAX 127
#define BYTE_MAX 0xff
#define WORD_MAX 0xffff
#define DWORD_MAX 0xffffffff
#define SBYTE_MAX 0x7f
#define SWORD_MAX 0x7fff
#define SDWORD_MAX 0x7fffffff

static bool parse_and_validate_bounds(const char **pp, const char *orig, 
                                      const char **s2_out, bfd_signed_vma *n2_out, bool *ov2_out,
                                      const char **s3_out, bfd_signed_vma *n3_out, bool *ov3_out,
                                      const char *p_end)
{
    *s2_out = *pp;
    *n2_out = parse_number(pp, ov2_out, p_end);
    if (**pp != ';')
    {
        bad_stab(orig);
        return false;
    }
    ++*pp;

    *s3_out = *pp;
    *n3_out = parse_number(pp, ov3_out, p_end);
    if (**pp != ';')
    {
        bad_stab(orig);
        return false;
    }
    ++*pp;
    
    return true;
}

static debug_type handle_overflow_cases(void *dhandle, debug_type index_type, 
                                       const char *s2, bfd_signed_vma n2, bool ov2,
                                       const char *s3, const char *orig)
{
    if (index_type == DEBUG_TYPE_NULL)
    {
        if (startswith(s2, LLLOW) && startswith(s3, LLHIGH))
            return debug_make_int_type(dhandle, 8, false);
        if (!ov2 && n2 == 0 && startswith(s3, ULLHIGH))
            return debug_make_int_type(dhandle, 8, true);
    }
    warn_stab(orig, _("numeric overflow"));
    return DEBUG_TYPE_NULL;
}

static debug_type handle_self_subrange_special_cases(void *dhandle, bfd_signed_vma n2, bfd_signed_vma n3)
{
    if (n2 == 0 && n3 == 0)
        return debug_make_void_type(dhandle);
    if (n3 == 0 && n2 > 0)
        return debug_make_complex_type(dhandle, n2);
    if (n2 == 0 && n3 == CHAR_MAX)
        return debug_make_int_type(dhandle, 1, false);
    return DEBUG_TYPE_NULL;
}

static debug_type handle_long_long_hack(void *dhandle, const char *type_name)
{
    if (type_name != NULL)
    {
        if (strcmp(type_name, "long long int") == 0)
            return debug_make_int_type(dhandle, 8, false);
        if (strcmp(type_name, "long long unsigned int") == 0)
            return debug_make_int_type(dhandle, 8, true);
    }
    return debug_make_int_type(dhandle, 4, true);
}

static debug_type handle_unsigned_int_by_max(void *dhandle, bfd_signed_vma n3)
{
    if (n3 < 0)
        return debug_make_int_type(dhandle, -n3, true);
    if (n3 == BYTE_MAX)
        return debug_make_int_type(dhandle, 1, true);
    if (n3 == WORD_MAX)
        return debug_make_int_type(dhandle, 2, true);
    if (n3 == (bfd_signed_vma)DWORD_MAX)
        return debug_make_int_type(dhandle, 4, true);
#ifdef BFD64
    if (n3 == (bfd_signed_vma)0xffffffffffffffffLL)
        return debug_make_int_type(dhandle, 8, true);
#endif
    return DEBUG_TYPE_NULL;
}

static debug_type handle_signed_int_by_range(void *dhandle, bfd_signed_vma n3)
{
    if (n3 == SBYTE_MAX)
        return debug_make_int_type(dhandle, 1, false);
    if (n3 == SWORD_MAX)
        return debug_make_int_type(dhandle, 2, false);
    if (n3 == SDWORD_MAX)
        return debug_make_int_type(dhandle, 4, false);
#ifdef BFD64
    if (n3 == ((((bfd_vma)0x7fffffff) << 32) | 0xffffffff))
        return debug_make_int_type(dhandle, 8, false);
#endif
    return DEBUG_TYPE_NULL;
}

static debug_type determine_numeric_type(void *dhandle, bool self_subrange, 
                                        bfd_signed_vma n2, bfd_signed_vma n3,
                                        const char *type_name)
{
    debug_type result;
    
    if (self_subrange)
    {
        result = handle_self_subrange_special_cases(dhandle, n2, n3);
        if (result != DEBUG_TYPE_NULL)
            return result;
    }
    
    if (n3 == 0 && n2 > 0)
        return debug_make_float_type(dhandle, n2);
    
    if (n2 == 0 && n3 == -1)
        return handle_long_long_hack(dhandle, type_name);
    
    if (n2 == 0)
    {
        result = handle_unsigned_int_by_max(dhandle, n3);
        if (result != DEBUG_TYPE_NULL)
            return result;
    }
    else if (n3 == 0 && n2 < 0 && (self_subrange || n2 == -8))
        return debug_make_int_type(dhandle, -n2, true);
    else if (n2 == -n3 - 1 || n2 == n3 + 1)
    {
        result = handle_signed_int_by_range(dhandle, n3);
        if (result != DEBUG_TYPE_NULL)
            return result;
    }
    
    return DEBUG_TYPE_NULL;
}

static debug_type
parse_stab_range_type(void *dhandle,
                     struct stab_handle *info,
                     const char *type_name,
                     const char **pp,
                     const int *typenums,
                     const char *p_end)
{
    const char *orig;
    int rangenums[2];
    bool self_subrange;
    debug_type index_type;
    const char *s2, *s3;
    bfd_signed_vma n2, n3;
    bool ov2, ov3;

    orig = *pp;
    if (orig >= p_end)
        return DEBUG_TYPE_NULL;

    index_type = DEBUG_TYPE_NULL;

    if (!parse_stab_type_number(pp, rangenums, p_end))
        return DEBUG_TYPE_NULL;

    self_subrange = (rangenums[0] == typenums[0] && rangenums[1] == typenums[1]);

    if (**pp == '=')
    {
        *pp = orig;
        index_type = parse_stab_type(dhandle, info, (const char *)NULL,
                                    pp, (debug_type **)NULL, p_end);
        if (index_type == DEBUG_TYPE_NULL)
            return DEBUG_TYPE_NULL;
    }

    if (**pp == ';')
        ++*pp;

    if (!parse_and_validate_bounds(pp, orig, &s2, &n2, &ov2, &s3, &n3, &ov3, p_end))
        return DEBUG_TYPE_NULL;

    if (ov2 || ov3)
    {
        debug_type result = handle_overflow_cases(dhandle, index_type, s2, n2, ov2, s3, orig);
        if (result != DEBUG_TYPE_NULL)
            return result;
    }

    if (index_type == DEBUG_TYPE_NULL)
    {
        debug_type result = determine_numeric_type(dhandle, self_subrange, n2, n3, type_name);
        if (result != DEBUG_TYPE_NULL)
            return result;
    }

    if (self_subrange)
    {
        bad_stab(orig);
        return DEBUG_TYPE_NULL;
    }

    index_type = stab_find_type(dhandle, info, rangenums);
    if (index_type == DEBUG_TYPE_NULL)
    {
        warn_stab(orig, _("missing index type"));
        index_type = debug_make_int_type(dhandle, 4, false);
    }

    return debug_make_range_type(dhandle, index_type, n2, n3);
}

/* Sun's ACC uses a somewhat saner method for specifying the builtin
   typedefs in every file (for int, long, etc):

	type = b <signed> <width>; <offset>; <nbits>
	signed = u or s.  Possible c in addition to u or s (for char?).
	offset = offset from high order bit to start bit of type.
	width is # bytes in object of this type, nbits is # bits in type.

   The width/offset stuff appears to be for small objects stored in
   larger ones (e.g. `shorts' in `int' registers).  We ignore it for now,
   FIXME.  */

static bool parse_signedness(const char **pp, const char *orig)
{
  switch (**pp)
    {
    case 's':
      ++*pp;
      return false;
    case 'u':
      ++*pp;
      return true;
    default:
      bad_stab (orig);
      return false;
    }
}

static void skip_format_encoding(const char **pp)
{
  if (**pp == 'c' || **pp == 'b' || **pp == 'v')
    ++*pp;
}

static bool parse_and_skip_number_with_semicolon(const char **pp, const char *p_end, const char *orig)
{
  (void) parse_number (pp, (bool *) NULL, p_end);
  if (**pp != ';')
    {
      bad_stab (orig);
      return false;
    }
  ++*pp;
  return true;
}

static void skip_optional_semicolon(const char **pp)
{
  if (**pp == ';')
    ++*pp;
}

static debug_type
parse_stab_sun_builtin_type (void *dhandle, const char **pp, const char * p_end)
{
  const char *orig;
  bool unsignedp;
  bfd_vma bits;

  orig = *pp;
  if (orig >= p_end)
    return DEBUG_TYPE_NULL;

  unsignedp = parse_signedness(pp, orig);
  if (**pp != 's' && **pp != 'u')
    return DEBUG_TYPE_NULL;

  skip_format_encoding(pp);

  if (!parse_and_skip_number_with_semicolon(pp, p_end, orig))
    return DEBUG_TYPE_NULL;

  if (!parse_and_skip_number_with_semicolon(pp, p_end, orig))
    return DEBUG_TYPE_NULL;

  bits = parse_number (pp, (bool *) NULL, p_end);

  skip_optional_semicolon(pp);

  if (bits == 0)
    return debug_make_void_type (dhandle);

  return debug_make_int_type (dhandle, bits / 8, unsignedp);
}

/* Parse a builtin floating type generated by the Sun compiler.  */

static bool validate_and_advance(const char **pp, const char *orig)
{
  if (**pp != ';')
    {
      bad_stab (orig);
      return false;
    }
  return true;
}

static debug_type
parse_stab_sun_floating_type (void *dhandle, const char **pp, const char *p_end)
{
  const char *orig;
  bfd_vma details;
  bfd_vma bytes;

  orig = *pp;
  if (orig >= p_end)
    return DEBUG_TYPE_NULL;

  details = parse_number (pp, (bool *) NULL, p_end);
  if (!validate_and_advance(pp, orig))
    return DEBUG_TYPE_NULL;

  bytes = parse_number (pp, (bool *) NULL, p_end);
  if (!validate_and_advance(pp, orig))
    return DEBUG_TYPE_NULL;

  if (details == NF_COMPLEX || details == NF_COMPLEX16 || details == NF_COMPLEX32)
    return debug_make_complex_type (dhandle, bytes);

  return debug_make_float_type (dhandle, bytes);
}

/* Handle an enum type.  */

static void skip_to_colon(const char **pp)
{
    while (**pp != ':' && **pp != '\0')
        ++*pp;
}

static void skip_aix_compiler_field(const char **pp)
{
    if (**pp != '-')
        return;
    
    skip_to_colon(pp);
    
    if (**pp == '\0')
        return;
    
    ++*pp;
}

static void free_resources(const char **names, bfd_signed_vma *values)
{
    free(names);
    free(values);
}

static debug_type handle_parse_error(const char *orig, const char **names, bfd_signed_vma *values)
{
    bad_stab(orig);
    free_resources(names, values);
    return DEBUG_TYPE_NULL;
}

static const char* extract_enum_name(void *dhandle, const char **pp, const char *orig, 
                                     const char **names, bfd_signed_vma *values)
{
    const char *p = *pp;
    skip_to_colon(&p);
    
    if (*p == '\0')
    {
        handle_parse_error(orig, names, values);
        return NULL;
    }
    
    char *name = savestring(dhandle, *pp, p - *pp);
    *pp = p + 1;
    return name;
}

static bool parse_enum_value(const char **pp, bfd_signed_vma *val, const char *p_end, 
                             const char *orig, const char **names, bfd_signed_vma *values)
{
    *val = (bfd_signed_vma) parse_number(pp, (bool *) NULL, p_end);
    
    if (**pp != ',')
    {
        handle_parse_error(orig, names, values);
        return false;
    }
    
    ++*pp;
    return true;
}

#define INITIAL_ALLOC 10
#define ALLOC_INCREMENT 10

static void expand_arrays_if_needed(unsigned int n, unsigned int *alloc, 
                                    const char ***names, bfd_signed_vma **values)
{
    if (n + 1 < *alloc)
        return;
    
    *alloc += ALLOC_INCREMENT;
    *names = xrealloc(*names, *alloc * sizeof(**names));
    *values = xrealloc(*values, *alloc * sizeof(**values));
}

static bool parse_single_enum_member(void *dhandle, const char **pp, const char *p_end,
                                     const char *orig, const char **names, 
                                     bfd_signed_vma *values, unsigned int n)
{
    const char *name = extract_enum_name(dhandle, pp, orig, names, values);
    if (!name)
        return false;
    
    bfd_signed_vma val;
    if (!parse_enum_value(pp, &val, p_end, orig, names, values))
        return false;
    
    names[n] = name;
    values[n] = val;
    return true;
}

static void* allocate_and_copy_array(void *dhandle, const void *source, 
                                     size_t element_size, unsigned int count)
{
    void *dest = debug_xalloc(dhandle, count * element_size);
    memcpy(dest, source, count * element_size);
    return dest;
}

static debug_type parse_stab_enum_type(void *dhandle, const char **pp, const char *p_end)
{
    const char *orig = *pp;
    if (orig >= p_end)
        return DEBUG_TYPE_NULL;
    
    skip_aix_compiler_field(pp);
    
    if (**pp == '\0')
    {
        bad_stab(orig);
        return DEBUG_TYPE_NULL;
    }
    
    unsigned int alloc = INITIAL_ALLOC;
    const char **names = xmalloc(alloc * sizeof(*names));
    bfd_signed_vma *values = xmalloc(alloc * sizeof(*values));
    unsigned int n = 0;
    
    while (**pp != '\0' && **pp != ';' && **pp != ',')
    {
        expand_arrays_if_needed(n, &alloc, &names, &values);
        
        if (!parse_single_enum_member(dhandle, pp, p_end, orig, names, values, n))
            return DEBUG_TYPE_NULL;
        
        ++n;
    }
    
    names[n] = NULL;
    values[n] = 0;
    
    const char **xnames = allocate_and_copy_array(dhandle, names, 
                                                  sizeof(*names), n + 1);
    bfd_signed_vma *xvalues = allocate_and_copy_array(dhandle, values, 
                                                      sizeof(*names), n + 1);
    
    free_resources(names, values);
    
    if (**pp == ';')
        ++*pp;
    
    return debug_make_enum_type(dhandle, xnames, xvalues);
}

/* Read the description of a structure (or union type) and return an object
   describing the type.

   PP points to a character pointer that points to the next unconsumed token
   in the stabs string.  For example, given stabs "A:T4=s4a:1,0,32;;",
   *PP will point to "4a:1,0,32;;".  */

static bool parse_struct_components(void *dhandle,
                                   struct stab_handle *info,
                                   const char *tagname,
                                   const char **pp,
                                   const int *typenums,
                                   const char *p_end,
                                   debug_baseclass **baseclasses,
                                   debug_field **fields,
                                   bool *statics,
                                   debug_method **methods,
                                   debug_type *vptrbase,
                                   bool *ownvptr)
{
  if (!parse_stab_baseclasses(dhandle, info, pp, baseclasses, p_end))
    return false;
    
  if (!parse_stab_struct_fields(dhandle, info, pp, fields, statics, p_end))
    return false;
    
  if (!parse_stab_members(dhandle, info, tagname, pp, typenums, methods, p_end))
    return false;
    
  if (!parse_stab_tilde_field(dhandle, info, pp, typenums, vptrbase, ownvptr, p_end))
    return false;
    
  return true;
}

static bool is_simple_struct(bool statics,
                            debug_baseclass *baseclasses,
                            debug_method *methods,
                            debug_type vptrbase,
                            bool ownvptr)
{
  return !statics && 
         baseclasses == NULL && 
         methods == NULL && 
         vptrbase == DEBUG_TYPE_NULL && 
         !ownvptr;
}

static debug_type
parse_stab_struct_type(void *dhandle,
                       struct stab_handle *info,
                       const char *tagname,
                       const char **pp,
                       bool structp,
                       const int *typenums,
                       const char *p_end)
{
  bfd_vma size;
  debug_baseclass *baseclasses;
  debug_field *fields = NULL;
  bool statics;
  debug_method *methods;
  debug_type vptrbase;
  bool ownvptr;

  size = parse_number(pp, (bool *)NULL, p_end);

  if (!parse_struct_components(dhandle, info, tagname, pp, typenums, p_end,
                               &baseclasses, &fields, &statics, &methods,
                               &vptrbase, &ownvptr))
    return DEBUG_TYPE_NULL;

  if (is_simple_struct(statics, baseclasses, methods, vptrbase, ownvptr))
    return debug_make_struct_type(dhandle, structp, size, fields);

  return debug_make_object_type(dhandle, structp, size, fields, baseclasses,
                               methods, vptrbase, ownvptr);
}

/* The stabs for C++ derived classes contain baseclass information which
   is marked by a '!' character after the total size.  This function is
   called when we encounter the baseclass marker, and slurps up all the
   baseclass information.

   Immediately following the '!' marker is the number of base classes that
   the class is derived from, followed by information for each base class.
   For each base class, there are two visibility specifiers, a bit offset
   to the base class information within the derived class, a reference to
   the type for the base class, and a terminating semicolon.

   A typical example, with two base classes, would be "!2,020,19;0264,21;".
						       ^^ ^ ^ ^  ^ ^  ^
	Baseclass information marker __________________|| | | |  | |  |
	Number of baseclasses __________________________| | | |  | |  |
	Visibility specifiers (2) ________________________| | |  | |  |
	Offset in bits from start of class _________________| |  | |  |
	Type number for base class ___________________________|  | |  |
	Visibility specifiers (2) _______________________________| |  |
	Offset in bits from start of class ________________________|  |
	Type number of base class ____________________________________|

  Return TRUE for success, FALSE for failure.  */

static bool parse_virtual_flag(const char **pp, const char *orig)
{
    switch (**pp)
    {
    case '0':
        ++*pp;
        return false;
    case '1':
        ++*pp;
        return true;
    case 0:
        bad_stab(orig);
        return false;
    default:
        warn_stab(orig, _("unknown virtual character for baseclass"));
        ++*pp;
        return false;
    }
}

static enum debug_visibility parse_visibility_flag(const char **pp, const char *orig)
{
    enum debug_visibility visibility;
    
    switch (**pp)
    {
    case '0':
        visibility = DEBUG_VISIBILITY_PRIVATE;
        break;
    case '1':
        visibility = DEBUG_VISIBILITY_PROTECTED;
        break;
    case '2':
        visibility = DEBUG_VISIBILITY_PUBLIC;
        break;
    case 0:
        bad_stab(orig);
        return DEBUG_VISIBILITY_PUBLIC;
    default:
        warn_stab(orig, _("unknown visibility character for baseclass"));
        visibility = DEBUG_VISIBILITY_PUBLIC;
        break;
    }
    ++*pp;
    return visibility;
}

static bool expect_comma(const char **pp, const char *orig)
{
    if (**pp != ',')
    {
        bad_stab(orig);
        return false;
    }
    ++*pp;
    return true;
}

static bool parse_single_baseclass(void *dhandle,
                                   struct stab_handle *info,
                                   const char **pp,
                                   const char *orig,
                                   const char *p_end,
                                   debug_baseclass *class_out)
{
    bool is_virtual = parse_virtual_flag(pp, orig);
    if (**pp == 0)
        return false;
        
    enum debug_visibility visibility = parse_visibility_flag(pp, orig);
    if (**pp == 0)
        return false;
        
    bfd_vma bitpos = parse_number(pp, (bool *)NULL, p_end);
    if (!expect_comma(pp, orig))
        return false;
        
    debug_type type = parse_stab_type(dhandle, info, (const char *)NULL, pp,
                                      (debug_type **)NULL, p_end);
    if (type == DEBUG_TYPE_NULL)
        return false;
        
    *class_out = debug_make_baseclass(dhandle, type, bitpos, is_virtual, visibility);
    if (*class_out == DEBUG_BASECLASS_NULL)
        return false;
        
    if (**pp != ';')
        return false;
    ++*pp;
    
    return true;
}

static bool
parse_stab_baseclasses(void *dhandle,
                      struct stab_handle *info,
                      const char **pp,
                      debug_baseclass **retp,
                      const char *p_end)
{
    const char *orig;
    unsigned int c, i;
    debug_baseclass *classes;
    
    *retp = NULL;
    
    orig = *pp;
    if (orig >= p_end)
        return false;
        
    if (**pp != '!')
        return true;
    ++*pp;
    
    c = (unsigned int)parse_number(pp, (bool *)NULL, p_end);
    if (!expect_comma(pp, orig))
        return false;
        
    classes = debug_xalloc(dhandle, (c + 1) * sizeof(*classes));
    
    for (i = 0; i < c; i++)
    {
        if (!parse_single_baseclass(dhandle, info, pp, orig, p_end, &classes[i]))
            return false;
    }
    
    classes[i] = DEBUG_BASECLASS_NULL;
    *retp = classes;
    
    return true;
}

/* Read struct or class data fields.  They have the form:

	NAME : [VISIBILITY] TYPENUM , BITPOS , BITSIZE ;

   At the end, we see a semicolon instead of a field.

   In C++, this may wind up being NAME:?TYPENUM:PHYSNAME; for
   a static field.

   The optional VISIBILITY is one of:

	'/0'	(VISIBILITY_PRIVATE)
	'/1'	(VISIBILITY_PROTECTED)
	'/2'	(VISIBILITY_PUBLIC)
	'/9'	(VISIBILITY_IGNORE)

   or nothing, for C style fields with public visibility.

   Returns 1 for success, 0 for failure.  */

static bool
is_cplus_marker(char ch)
{
  return ch == '$' || ch == '.';
}

static bool
is_special_abbreviation(const char *p)
{
  return is_cplus_marker(*p) && p[1] != '_';
}

static debug_field *
allocate_fields(unsigned int size)
{
  return xmalloc(size * sizeof(debug_field));
}

static debug_field *
reallocate_fields(debug_field *fields, unsigned int new_size)
{
  return xrealloc(fields, new_size * sizeof(debug_field));
}

static bool
needs_reallocation(unsigned int current, unsigned int allocated)
{
  return current + 1 >= allocated;
}

static const char *
find_field_separator(const char *p)
{
  return strchr(p, ':');
}

static bool
is_member_function_delimiter(const char *p)
{
  return p[1] == ':';
}

static bool
process_special_abbreviation(void *dhandle, struct stab_handle *info,
                            const char **pp, debug_field *field,
                            const char *p_end)
{
  ++*pp;
  return parse_stab_cpp_abbrev(dhandle, info, pp, field, p_end);
}

static bool
process_regular_field(void *dhandle, struct stab_handle *info,
                     const char **pp, const char *separator,
                     debug_field *field, bool *staticsp,
                     const char *p_end)
{
  return parse_stab_one_struct_field(dhandle, info, pp, separator,
                                    field, staticsp, p_end);
}

static debug_field *
finalize_fields(void *dhandle, debug_field *fields, unsigned int count)
{
  fields[count] = DEBUG_FIELD_NULL;
  debug_field *xfields = debug_xalloc(dhandle, (count + 1) * sizeof(*fields));
  memcpy(xfields, fields, (count + 1) * sizeof(*fields));
  free(fields);
  return xfields;
}

static bool
parse_stab_struct_fields(void *dhandle,
                        struct stab_handle *info,
                        const char **pp,
                        debug_field **retp,
                        bool *staticsp,
                        const char *p_end)
{
  const unsigned int INITIAL_ALLOC = 10;
  const unsigned int ALLOC_INCREMENT = 10;
  
  const char *orig;
  const char *p;
  debug_field *fields;
  unsigned int c;
  unsigned int alloc;

  *retp = NULL;
  *staticsp = false;

  orig = *pp;
  if (orig >= p_end)
    return false;

  c = 0;
  alloc = INITIAL_ALLOC;
  fields = allocate_fields(alloc);

  while (**pp != ';')
    {
      p = *pp;

      if (needs_reallocation(c, alloc))
        {
          alloc += ALLOC_INCREMENT;
          fields = reallocate_fields(fields, alloc);
        }

      if (is_special_abbreviation(p))
        {
          if (!process_special_abbreviation(dhandle, info, pp, 
                                           fields + c, p_end))
            {
              free(fields);
              return false;
            }
          ++c;
          continue;
        }

      p = find_field_separator(p);
      if (p == NULL)
        {
          bad_stab(orig);
          free(fields);
          return false;
        }

      if (is_member_function_delimiter(p))
        break;

      if (!process_regular_field(dhandle, info, pp, p,
                                fields + c, staticsp, p_end))
        {
          free(fields);
          return false;
        }

      ++c;
    }

  *retp = finalize_fields(dhandle, fields, c);
  return true;
}

/* Special GNU C++ name.  */

static bool validate_and_advance(const char **pp, char expected, const char *orig)
{
  if (**pp != expected)
    {
      bad_stab (orig);
      return false;
    }
  ++*pp;
  return true;
}

static const char* get_virtual_function_name(void)
{
  return "_vptr$";
}

static const char* get_virtual_base_name(void *dhandle, debug_type context, const char *orig)
{
  const char *type_name = debug_get_type_name (dhandle, context);
  if (type_name == NULL)
    {
      warn_stab (orig, _("unnamed $vb type"));
      type_name = "FOO";
    }
  
  size_t len = strlen (type_name);
  char *name = debug_xalloc (dhandle, len + sizeof ("_vb$"));
  memcpy (name, "_vb$", sizeof ("_vb$") - 1);
  memcpy (name + sizeof ("_vb$") - 1, type_name, len + 1);
  return name;
}

static const char* get_field_name(int cpp_abbrev, void *dhandle, debug_type context, const char *orig)
{
  switch (cpp_abbrev)
    {
    case 'f':
      return get_virtual_function_name();
    case 'b':
      return get_virtual_base_name(dhandle, context, orig);
    default:
      warn_stab (orig, _("unrecognized C++ abbreviation"));
      return "INVALID_CPLUSPLUS_ABBREV";
    }
}

static bool
parse_stab_cpp_abbrev (void *                dhandle,
		       struct stab_handle *  info,
		       const char **         pp,
		       debug_field *         retp,
		       const char *          p_end)
{
  *retp = DEBUG_FIELD_NULL;

  const char *orig = *pp;
  if (orig >= p_end)
    return false;

  if (!validate_and_advance(pp, 'v', orig))
    return false;

  int cpp_abbrev = **pp;
  if (cpp_abbrev == 0)
    {
      bad_stab (orig);
      return false;
    }
  ++*pp;

  debug_type context = parse_stab_type (dhandle, info, (const char *) NULL, pp,
			     (debug_type **) NULL, p_end);
  if (context == DEBUG_TYPE_NULL)
    return false;

  const char *name = get_field_name(cpp_abbrev, dhandle, context, orig);

  if (!validate_and_advance(pp, ':', orig))
    return false;

  debug_type type = parse_stab_type (dhandle, info, (const char *) NULL, pp,
			  (debug_type **) NULL, p_end);
  
  if (!validate_and_advance(pp, ',', orig))
    return false;

  bfd_vma bitpos = parse_number (pp, (bool *) NULL, p_end);
  
  if (!validate_and_advance(pp, ';', orig))
    return false;

  *retp = debug_make_field (dhandle, name, type, bitpos, 0,
			    DEBUG_VISIBILITY_PRIVATE);
  if (*retp == DEBUG_FIELD_NULL)
    return false;

  return true;
}

/* Parse a single field in a struct or union.  */

static bool validate_position(const char **pp, const char *p_end)
{
  if (*pp >= p_end)
    return false;
  return true;
}

static bool expect_character(const char **pp, char expected, const char *orig)
{
  if (**pp != expected)
    {
      bad_stab(orig);
      return false;
    }
  ++*pp;
  return true;
}

static enum debug_visibility parse_visibility(const char **pp, const char *orig)
{
  enum debug_visibility visibility;
  
  if (**pp != '/')
    return DEBUG_VISIBILITY_PUBLIC;
    
  ++*pp;
  switch (**pp)
    {
    case '0':
      visibility = DEBUG_VISIBILITY_PRIVATE;
      break;
    case '1':
      visibility = DEBUG_VISIBILITY_PROTECTED;
      break;
    case '2':
      visibility = DEBUG_VISIBILITY_PUBLIC;
      break;
    case 0:
      bad_stab(orig);
      return DEBUG_VISIBILITY_PUBLIC;
    default:
      warn_stab(orig, _("unknown visibility character for field"));
      visibility = DEBUG_VISIBILITY_PUBLIC;
      break;
    }
  ++*pp;
  return visibility;
}

static bool parse_static_member(void *dhandle,
                                const char **pp,
                                const char *orig,
                                char *name,
                                debug_type type,
                                enum debug_visibility visibility,
                                debug_field *retp,
                                bool *staticsp)
{
  char *varname;
  const char *p;
  
  ++*pp;
  p = strchr(*pp, ';');
  if (p == NULL)
    {
      bad_stab(orig);
      return false;
    }
    
  varname = savestring(dhandle, *pp, p - *pp);
  *pp = p + 1;
  
  *retp = debug_make_static_member(dhandle, name, type, varname, visibility);
  *staticsp = true;
  
  return true;
}

static bool parse_regular_field(void *dhandle,
                                const char **pp,
                                const char *orig,
                                const char *p_end,
                                char *name,
                                debug_type type,
                                enum debug_visibility visibility,
                                debug_field *retp)
{
  bfd_vma bitpos;
  bfd_vma bitsize;
  
  if (!expect_character(pp, ',', orig))
    return false;
    
  bitpos = parse_number(pp, (bool *) NULL, p_end);
  
  if (!expect_character(pp, ',', orig))
    return false;
    
  bitsize = parse_number(pp, (bool *) NULL, p_end);
  
  if (!expect_character(pp, ';', orig))
    return false;
    
  if (bitpos == 0 && bitsize == 0)
    visibility = DEBUG_VISIBILITY_IGNORE;
    
  *retp = debug_make_field(dhandle, name, type, bitpos, bitsize, visibility);
  
  return true;
}

static bool
parse_stab_one_struct_field(void *dhandle,
                           struct stab_handle *info,
                           const char **pp,
                           const char *p,
                           debug_field *retp,
                           bool *staticsp,
                           const char *p_end)
{
  const char *orig;
  char *name;
  enum debug_visibility visibility;
  debug_type type;
  
  orig = *pp;
  if (!validate_position(&orig, p_end))
    return false;
    
  name = savestring(dhandle, *pp, p - *pp);
  *pp = p + 1;
  
  visibility = parse_visibility(pp, orig);
  
  type = parse_stab_type(dhandle, info, (const char *) NULL, pp,
                         (debug_type **) NULL, p_end);
  if (type == DEBUG_TYPE_NULL)
    return false;
    
  if (**pp == ':')
    return parse_static_member(dhandle, pp, orig, name, type, 
                              visibility, retp, staticsp);
    
  return parse_regular_field(dhandle, pp, orig, p_end, name, type, 
                            visibility, retp);
}

/* Read member function stabs info for C++ classes.  The form of each member
   function data is:

	NAME :: TYPENUM[=type definition] ARGS : PHYSNAME ;

   An example with two member functions is:

	afunc1::20=##15;:i;2A.;afunc2::20:i;2A.;

   For the case of overloaded operators, the format is op$::*.funcs, where
   $ is the CPLUS_MARKER (usually '$'), `*' holds the place for an operator
   name (such as `+=') and `.' marks the end of the operator name.  */

static bool
parse_stab_members (void *                dhandle,
		    struct stab_handle *  info,
		    const char *          tagname,
		    const char **         pp,
		    const int *           typenums,
		    debug_method **       retp,
		    const char *          p_end)
{
  const char *orig;
  debug_method *methods, *xmethods;
  unsigned int c;
  unsigned int alloc;

  *retp = NULL;

  orig = *pp;
  if (orig >= p_end)
    return false;

  alloc = 0;
  methods = NULL;
  c = 0;

  while (**pp != ';')
    {
      if (!parse_single_method(dhandle, info, tagname, pp, typenums, 
                               &methods, &c, &alloc, orig, p_end))
        {
          free(methods);
          return false;
        }
    }

  xmethods = finalize_methods(dhandle, methods, c);
  *retp = xmethods;

  return true;
}

static bool
parse_single_method(void *dhandle, struct stab_handle *info, 
                    const char *tagname, const char **pp,
                    const int *typenums, debug_method **methods,
                    unsigned int *c, unsigned int *alloc,
                    const char *orig, const char *p_end)
{
  char *name = NULL;
  debug_method_variant *variants = NULL;
  unsigned int cvars;
  unsigned int allocvars;
  debug_type look_ahead_type;

  if (!extract_method_name(dhandle, pp, &name, orig))
    return false;

  allocvars = 10;
  variants = xmalloc(allocvars * sizeof(*variants));
  cvars = 0;
  look_ahead_type = DEBUG_TYPE_NULL;

  if (!parse_method_variants(dhandle, info, tagname, pp, typenums,
                             name, &variants, &cvars, &allocvars,
                             &look_ahead_type, orig, p_end))
    {
      free(variants);
      return false;
    }

  if (!add_method_to_list(dhandle, methods, c, alloc, name, variants, cvars))
    {
      free(variants);
      return false;
    }

  if (**pp != '\0')
    ++*pp;

  return true;
}

static bool
extract_method_name(void *dhandle, const char **pp, char **name, const char *orig)
{
  const char *p = strchr(*pp, ':');
  
  if (p == NULL || p[1] != ':')
    return false;

  if ((*pp)[0] != 'o' || (*pp)[1] != 'p' || (*pp)[2] != '$')
    {
      *name = savestring(dhandle, *pp, p - *pp);
      *pp = p + 2;
    }
  else
    {
      *pp = p + 2;
      for (p = *pp; *p != '.' && *p != '\0'; p++)
        ;
      if (*p != '.')
        {
          bad_stab(orig);
          return false;
        }
      *name = savestring(dhandle, *pp, p - *pp);
      *pp = p + 1;
    }
  
  return true;
}

static bool
parse_method_variants(void *dhandle, struct stab_handle *info,
                      const char *tagname, const char **pp,
                      const int *typenums, char *name,
                      debug_method_variant **variants,
                      unsigned int *cvars, unsigned int *allocvars,
                      debug_type *look_ahead_type,
                      const char *orig, const char *p_end)
{
  do
    {
      debug_method_variant variant;
      
      if (!parse_single_variant(dhandle, info, tagname, pp, typenums,
                                name, look_ahead_type, &variant,
                                orig, p_end))
        return false;

      if (*cvars + 1 >= *allocvars)
        {
          *allocvars += 10;
          *variants = xrealloc(*variants, *allocvars * sizeof(**variants));
        }

      (*variants)[*cvars] = variant;
      ++(*cvars);
    }
  while (**pp != ';' && **pp != '\0');

  (*variants)[*cvars] = DEBUG_METHOD_VARIANT_NULL;
  
  return true;
}

static bool
parse_single_variant(void *dhandle, struct stab_handle *info,
                     const char *tagname, const char **pp,
                     const int *typenums, char *name,
                     debug_type *look_ahead_type,
                     debug_method_variant *variant,
                     const char *orig, const char *p_end)
{
  debug_type type;
  bool stub;
  enum debug_visibility visibility;
  bool constp, volatilep, staticp;
  bfd_vma voffset;
  debug_type context;
  const char *physname;
  char *argtypes;

  type = get_variant_type(dhandle, info, pp, look_ahead_type, orig, p_end);
  if (type == DEBUG_TYPE_NULL)
    return false;

  argtypes = extract_argtypes(dhandle, pp, orig);
  if (argtypes == NULL)
    return false;

  stub = is_stub_method(dhandle, type);
  visibility = parse_visibility(pp, orig);
  parse_const_volatile(pp, &constp, &volatilep, orig);
  
  if (!parse_variant_details(dhandle, info, pp, name, argtypes,
                             &staticp, &voffset, &context,
                             look_ahead_type, &stub, orig, p_end))
    return false;

  physname = argtypes;
  if (stub)
    {
      type = resolve_stub_type(dhandle, info, typenums, type, name,
                               tagname, argtypes, constp, volatilep,
                               &physname, orig);
      if (type == DEBUG_TYPE_NULL)
        return false;
    }

  *variant = create_method_variant(dhandle, physname, type, visibility,
                                   constp, volatilep, staticp, voffset, context);
  
  return (*variant != DEBUG_METHOD_VARIANT_NULL);
}

static debug_type
get_variant_type(void *dhandle, struct stab_handle *info,
                 const char **pp, debug_type *look_ahead_type,
                 const char *orig, const char *p_end)
{
  debug_type type;
  
  if (*look_ahead_type != DEBUG_TYPE_NULL)
    {
      type = *look_ahead_type;
      *look_ahead_type = DEBUG_TYPE_NULL;
    }
  else
    {
      type = parse_stab_type(dhandle, info, NULL, pp, NULL, p_end);
      if (type == DEBUG_TYPE_NULL)
        return DEBUG_TYPE_NULL;

      if (**pp != ':')
        {
          bad_stab(orig);
          return DEBUG_TYPE_NULL;
        }
    }

  ++*pp;
  return type;
}

static char *
extract_argtypes(void *dhandle, const char **pp, const char *orig)
{
  const char *p = strchr(*pp, ';');
  if (p == NULL)
    {
      bad_stab(orig);
      return NULL;
    }

  char *argtypes = savestring(dhandle, *pp, p - *pp);
  *pp = p + 1;
  return argtypes;
}

static bool
is_stub_method(void *dhandle, debug_type type)
{
  bool varargs;
  return (debug_get_type_kind(dhandle, type) == DEBUG_KIND_METHOD
          && debug_get_parameter_types(dhandle, type, &varargs) == NULL);
}

static enum debug_visibility
parse_visibility(const char **pp, const char *orig)
{
  enum debug_visibility visibility;
  
  switch (**pp)
    {
    case '0':
      visibility = DEBUG_VISIBILITY_PRIVATE;
      break;
    case '1':
      visibility = DEBUG_VISIBILITY_PROTECTED;
      break;
    case 0:
      bad_stab(orig);
      return DEBUG_VISIBILITY_PUBLIC;
    default:
      visibility = DEBUG_VISIBILITY_PUBLIC;
      break;
    }
  ++*pp;
  return visibility;
}

static void
parse_const_volatile(const char **pp, bool *constp, bool *volatilep, const char *orig)
{
  *constp = false;
  *volatilep = false;
  
  switch (**pp)
    {
    case 'A':
      ++*pp;
      break;
    case 'B':
      *constp = true;
      ++*pp;
      break;
    case 'C':
      *volatilep = true;
      ++*pp;
      break;
    case 'D':
      *constp = true;
      *volatilep = true;
      ++*pp;
      break;
    case '*':
    case '?':
    case '.':
      break;
    default:
      warn_stab(orig, _("const/volatile indicator missing"));
      break;
    }
}

static bool
parse_variant_details(void *dhandle, struct stab_handle *info,
                      const char **pp, char *name, char *argtypes,
                      bool *staticp, bfd_vma *voffset,
                      debug_type *context, debug_type *look_ahead_type,
                      bool *stub, const char *orig, const char *p_end)
{
  *staticp = false;
  
  switch (**pp)
    {
    case '*':
      return parse_virtual_method(dhandle, info, pp, voffset, context,
                                   look_ahead_type, orig, p_end);
    case '?':
      ++*pp;
      *staticp = true;
      *voffset = 0;
      *context = DEBUG_TYPE_NULL;
      if (strncmp(argtypes, name, strlen(name)) != 0)
        *stub = true;
      break;
    case '.':
      ++*pp;
      *voffset = 0;
      *context = DEBUG_TYPE_NULL;
      break;
    default:
      warn_stab(orig, "member function type missing");
      *voffset = 0;
      *context = DEBUG_TYPE_NULL;
      break;
    }
  
  return true;
}

static bool
parse_virtual_method(void *dhandle, struct stab_handle *info,
                     const char **pp, bfd_vma *voffset,
                     debug_type *context, debug_type *look_ahead_type,
                     const char *orig, const char *p_end)
{
  ++*pp;
  *voffset = parse_number(pp, NULL, p_end);
  if (**pp != ';')
    {
      bad_stab(orig);
      return false;
    }
  ++*pp;
  *voffset &= 0x7fffffff;

  if (**pp == ';' || **pp == '\0')
    {
      *context = DEBUG_TYPE_NULL;
    }
  else
    {
      *look_ahead_type = parse_stab_type(dhandle, info, NULL, pp, NULL, p_end);
      if (**pp == ':')
        {
          *context = DEBUG_TYPE_NULL;
        }
      else
        {
          *context = *look_ahead_type;
          *look_ahead_type = DEBUG_TYPE_NULL;
          if (**pp != ';')
            {
              bad_stab(orig);
              return false;
            }
          ++*pp;
        }
    }
  
  return true;
}

static debug_type
resolve_stub_type(void *dhandle, struct stab_handle *info,
                  const int *typenums, debug_type type,
                  char *name, const char *tagname,
                  char *argtypes, bool constp, bool volatilep,
                  const char **physname, const char *orig)
{
  debug_type class_type, return_type;

  class_type = stab_find_type(dhandle, info, typenums);
  if (class_type == DEBUG_TYPE_NULL)
    return DEBUG_TYPE_NULL;
    
  return_type = debug_get_return_type(dhandle, type);
  if (return_type == DEBUG_TYPE_NULL)
    {
      bad_stab(orig);
      return DEBUG_TYPE_NULL;
    }
    
  return parse_stab_argtypes(dhandle, info, class_type, name,
                             tagname, return_type, argtypes,
                             constp, volatilep, physname);
}

static debug_method_variant
create_method_variant(void *dhandle, const char *physname,
                      debug_type type, enum debug_visibility visibility,
                      bool constp, bool volatilep, bool staticp,
                      bfd_vma voffset, debug_type context)
{
  if (!staticp)
    return debug_make_method_variant(dhandle, physname, type, visibility,
                                     constp, volatilep, voffset, context);
  else
    return debug_make_static_method_variant(dhandle, physname, type,
                                            visibility, constp, volatilep);
}

static bool
add_method_to_list(void *dhandle, debug_method **methods,
                   unsigned int *c, unsigned int *alloc,
                   char *name, debug_method_variant *variants,
                   unsigned int cvars)
{
  debug_method_variant *xvariants;
  
  xvariants = debug_xalloc(dhandle, (cvars + 1) * sizeof(*variants));
  memcpy(xvariants, variants, (cvars + 1) * sizeof(*variants));
  free(variants);

  if (*c + 1 >= *alloc)
    {
      *alloc += 10;
      *methods = xrealloc(*methods, *alloc * sizeof(**methods));
    }

  (*methods)[*c] = debug_make_method(dhandle, name, xvariants);
  ++(*c);
  
  return true;
}

static debug_method *
finalize_methods(void *dhandle, debug_method *methods, unsigned int c)
{
  debug_method *xmethods = methods;
  
  if (methods != NULL)
    {
      methods[c] = DEBUG_METHOD_NULL;
      xmethods = debug_xalloc(dhandle, (c + 1) * sizeof(*methods));
      memcpy(xmethods, methods, (c + 1) * sizeof(*methods));
      free(methods);
    }
  
  return xmethods;
}

/* Parse a string representing argument types for a method.  Stabs
   tries to save space by packing argument types into a mangled
   string.  This string should give us enough information to extract
   both argument types and the physical name of the function, given
   the tag name.  */

static bool is_full_physname_constructor_check(const char *argtypes)
{
  return (argtypes[0] == '_' && argtypes[1] == '_' &&
          (ISDIGIT(argtypes[2]) || argtypes[2] == 'Q' || argtypes[2] == 't')) ||
         startswith(argtypes, "__ct");
}

static bool is_destructor_check(const char *argtypes)
{
  return (argtypes[0] == '_' &&
          (argtypes[1] == '$' || argtypes[1] == '.') &&
          argtypes[2] == '_') ||
         startswith(argtypes, "__dt");
}

static bool is_v3_check(const char *argtypes)
{
  return argtypes[0] == '_' && argtypes[1] == 'Z';
}

static bool is_constructor_check(bool is_full_physname, const char *fieldname,
                                 const char *tagname)
{
  return is_full_physname ||
         (tagname != NULL && strcmp(fieldname, tagname) == 0);
}

static bool is_operator_overload(const char *fieldname)
{
  return fieldname[0] == 'o' && fieldname[1] == 'p' &&
         (fieldname[2] == '$' || fieldname[2] == '.');
}

static unsigned int calculate_buf_len(const char *tagname, bool constp,
                                      bool volatilep, char *buf)
{
  const char *const_prefix = constp ? "C" : "";
  const char *volatile_prefix = volatilep ? "V" : "";
  unsigned int len = tagname == NULL ? 0 : strlen(tagname);
  
  if (len == 0)
    return sprintf(buf, "__%s%s", const_prefix, volatile_prefix);
  
  if (tagname != NULL && strchr(tagname, '<') != NULL)
    return sprintf(buf, "__%s%s", const_prefix, volatile_prefix);
  
  return sprintf(buf, "__%s%s%d", const_prefix, volatile_prefix, len);
}

static char *build_physname(void *dhandle, const char *fieldname,
                           const char *tagname, const char *argtypes,
                           bool constp, bool volatilep, bool is_constructor)
{
  char buf[20];
  unsigned int buf_len;
  unsigned int mangled_name_len;
  char *physname;
  unsigned int len = tagname == NULL ? 0 : strlen(tagname);
  
  buf_len = calculate_buf_len(tagname, constp, volatilep, buf);
  
  if (tagname != NULL && strchr(tagname, '<') != NULL)
  {
    tagname = NULL;
    len = 0;
  }
  
  mangled_name_len = (is_constructor ? 0 : strlen(fieldname)) +
                     buf_len + len + strlen(argtypes) + 1;
  
  physname = debug_xalloc(dhandle, mangled_name_len);
  
  if (is_constructor)
    physname[0] = '\0';
  else
    strcpy(physname, fieldname);
  
  strcat(physname, buf);
  if (tagname != NULL)
    strcat(physname, tagname);
  strcat(physname, argtypes);
  
  return physname;
}

static debug_type
parse_stab_argtypes(void *dhandle, struct stab_handle *info,
                   debug_type class_type, const char *fieldname,
                   const char *tagname, debug_type return_type,
                   const char *argtypes, bool constp,
                   bool volatilep, const char **pphysname)
{
  bool is_full_physname_constructor = is_full_physname_constructor_check(argtypes);
  bool is_constructor = is_constructor_check(is_full_physname_constructor,
                                             fieldname, tagname);
  bool is_destructor = is_destructor_check(argtypes);
  bool is_v3 = is_v3_check(argtypes);
  debug_type *args;
  bool varargs;
  unsigned int physname_len = 0;
  
  if (!(is_destructor || is_full_physname_constructor || is_v3))
  {
    if (is_operator_overload(fieldname))
      return DEBUG_TYPE_NULL;
    
    char *physname = build_physname(dhandle, fieldname, tagname, argtypes,
                                   constp, volatilep, is_constructor);
    physname_len = strlen(physname);
    *pphysname = physname;
  }
  
  if (*argtypes == '\0' || is_destructor)
  {
    args = debug_xalloc(dhandle, sizeof(*args));
    *args = NULL;
    return debug_make_method_type(dhandle, return_type, class_type, args, false);
  }
  
  args = stab_demangle_argtypes(dhandle, info, *pphysname, &varargs, physname_len);
  if (args == NULL)
    return DEBUG_TYPE_NULL;
  
  return debug_make_method_type(dhandle, return_type, class_type, args, varargs);
}

/* The tail end of stabs for C++ classes that contain a virtual function
   pointer contains a tilde, a %, and a type number.
   The type number refers to the base class (possibly this class itself) which
   contains the vtable pointer for the current class.

   This function is called when we have parsed all the method declarations,
   so we can look for the vptr base class info.  */

static bool skip_optional_semicolon(const char **pp, const char *p_end)
{
  if (*pp >= p_end)
    return false;
  
  if (**pp == ';')
    ++*pp;
  
  return true;
}

static bool skip_obsolete_flags(const char **pp)
{
  if (**pp == '=' || **pp == '+' || **pp == '-')
    ++*pp;
  
  return true;
}

static bool check_and_skip_tilde(const char **pp)
{
  if (**pp != '~')
    return false;
  
  ++*pp;
  return true;
}

static bool check_and_skip_percent(const char **pp)
{
  if (**pp != '%')
    return false;
  
  ++*pp;
  return true;
}

static bool is_same_type(const int *vtypenums, const int *typenums)
{
  return vtypenums[0] == typenums[0] && vtypenums[1] == typenums[1];
}

static const char* find_semicolon(const char *p)
{
  while (*p != ';' && *p != '\0')
    p++;
  return p;
}

static bool parse_vptr_base(void *dhandle,
                            struct stab_handle *info,
                            const char **pp,
                            const char *hold,
                            const char *orig,
                            debug_type *retvptrbase,
                            const char *p_end)
{
  debug_type vtype;
  const char *p;
  
  *pp = hold;
  
  vtype = parse_stab_type(dhandle, info, (const char *) NULL, pp,
                          (debug_type **) NULL, p_end);
  
  p = find_semicolon(*pp);
  
  if (*p != ';')
    {
      bad_stab(orig);
      return false;
    }
  
  *retvptrbase = vtype;
  *pp = p + 1;
  
  return true;
}

static bool
parse_stab_tilde_field (void *dhandle,
			struct stab_handle *info,
			const char **pp,
			const int *typenums,
			debug_type *retvptrbase,
			bool *retownvptr,
			const char *p_end)
{
  const char *orig;
  const char *hold;
  int vtypenums[2];

  *retvptrbase = DEBUG_TYPE_NULL;
  *retownvptr = false;

  orig = *pp;
  
  if (!skip_optional_semicolon(pp, p_end))
    return false;

  if (!check_and_skip_tilde(pp))
    return true;

  skip_obsolete_flags(pp);

  if (!check_and_skip_percent(pp))
    return true;

  hold = *pp;

  if (!parse_stab_type_number(pp, vtypenums, p_end))
    return false;

  if (is_same_type(vtypenums, typenums))
    {
      *retownvptr = true;
    }
  else
    {
      if (!parse_vptr_base(dhandle, info, pp, hold, orig, retvptrbase, p_end))
        return false;
    }

  return true;
}

/* Read a definition of an array type.  */

static debug_type get_default_int_type(void *dhandle)
{
  debug_type index_type = debug_find_named_type(dhandle, "int");
  if (index_type == DEBUG_TYPE_NULL)
    {
      index_type = debug_make_int_type(dhandle, 4, false);
    }
  return index_type;
}

static bool parse_index_type(void *dhandle, struct stab_handle *info,
                             const char **pp, const char *p_end,
                             debug_type *index_type)
{
  const char *p = *pp;
  int typenums[2];
  
  if (!parse_stab_type_number(&p, typenums, p_end))
    return false;
    
  if (typenums[0] == 0 && typenums[1] == 0 && **pp != '=')
    {
      *index_type = get_default_int_type(dhandle);
      if (*index_type == DEBUG_TYPE_NULL)
        return false;
      *pp = p;
    }
  else
    {
      *index_type = parse_stab_type(dhandle, info, (const char *)NULL, pp,
                                   (debug_type **)NULL, p_end);
    }
  return true;
}

static bool check_semicolon(const char **pp, const char *orig)
{
  if (**pp != ';')
    {
      bad_stab(orig);
      return false;
    }
  ++*pp;
  return true;
}

static bool is_adjustable_bound(const char **pp)
{
  if (!ISDIGIT(**pp) && **pp != '-' && **pp != 0)
    {
      ++*pp;
      return true;
    }
  return false;
}

static bool parse_array_bound(const char **pp, const char *p_end,
                              const char *orig, bfd_signed_vma *bound,
                              bool *adjustable)
{
  if (is_adjustable_bound(pp))
    *adjustable = true;
    
  *bound = (bfd_signed_vma)parse_number(pp, (bool *)NULL, p_end);
  return check_semicolon(pp, orig);
}

static debug_type
parse_stab_array_type(void *dhandle,
                      struct stab_handle *info,
                      const char **pp,
                      bool stringp,
                      const char *p_end)
{
  const char *orig;
  debug_type index_type;
  bool adjustable;
  bfd_signed_vma lower, upper;
  debug_type element_type;

  orig = *pp;
  if (orig >= p_end)
    return DEBUG_TYPE_NULL;

  if (!parse_index_type(dhandle, info, pp, p_end, &index_type))
    return DEBUG_TYPE_NULL;

  if (!check_semicolon(pp, orig))
    return DEBUG_TYPE_NULL;

  adjustable = false;

  if (!parse_array_bound(pp, p_end, orig, &lower, &adjustable))
    return DEBUG_TYPE_NULL;

  if (!parse_array_bound(pp, p_end, orig, &upper, &adjustable))
    return DEBUG_TYPE_NULL;

  element_type = parse_stab_type(dhandle, info, (const char *)NULL, pp,
                                 (debug_type **)NULL, p_end);
  if (element_type == DEBUG_TYPE_NULL)
    return DEBUG_TYPE_NULL;

  if (adjustable)
    {
      lower = 0;
      upper = -1;
    }

  return debug_make_array_type(dhandle, element_type, index_type, lower,
                              upper, stringp);
}

/* This struct holds information about files we have seen using
   N_BINCL.  */

struct bincl_file
{
  /* The next N_BINCL file.  */
  struct bincl_file *next;
  /* The next N_BINCL on the stack.  */
  struct bincl_file *next_stack;
  /* The file name.  */
  const char *name;
  /* The hash value.  */
  bfd_vma hash;
  /* The file index.  */
  unsigned int file;
  /* The list of types defined in this file.  */
  struct stab_types *file_types;
};

/* Start a new N_BINCL file, pushing it onto the stack.  */

static void
push_bincl (void *dhandle, struct stab_handle *info, const char *name,
	    bfd_vma hash)
{
  struct bincl_file *n;

  n = debug_xalloc (dhandle, sizeof *n);
  n->next = info->bincl_list;
  n->next_stack = info->bincl_stack;
  n->name = name;
  n->hash = hash;
  n->file = info->files;
  n->file_types = NULL;
  info->bincl_list = n;
  info->bincl_stack = n;

  ++info->files;
  info->file_types = xrealloc (info->file_types,
			       info->files * sizeof (*info->file_types));
  info->file_types[n->file] = NULL;
}

/* Finish an N_BINCL file, at an N_EINCL, popping the name off the
   stack.  */

static const char *
pop_bincl (struct stab_handle *info)
{
  struct bincl_file *o;

  o = info->bincl_stack;
  if (o == NULL)
    return info->main_filename;
  
  info->bincl_stack = o->next_stack;

  if (o->file < info->files)
    o->file_types = info->file_types[o->file];

  if (info->bincl_stack == NULL)
    return info->main_filename;
  
  return info->bincl_stack->name;
}

/* Handle an N_EXCL: get the types from the corresponding N_BINCL.  */

static bool
find_excl (struct stab_handle *info, const char *name, bfd_vma hash)
{
  struct bincl_file *l;

  ++info->files;
  info->file_types = xrealloc (info->file_types,
                               info->files * sizeof (*info->file_types));

  l = find_matching_bincl_file (info, name, hash);
  
  if (l == NULL)
    {
      warn_stab (name, _("Undefined N_EXCL"));
      info->file_types[info->files - 1] = NULL;
      return true;
    }

  info->file_types[info->files - 1] = l->file_types;
  return true;
}

static struct bincl_file *
find_matching_bincl_file (struct stab_handle *info, const char *name, bfd_vma hash)
{
  struct bincl_file *l;
  
  for (l = info->bincl_list; l != NULL; l = l->next)
    {
      if (l->hash == hash && strcmp (l->name, name) == 0)
        return l;
    }
  
  return NULL;
}

/* Handle a variable definition.  gcc emits variable definitions for a
   block before the N_LBRAC, so we must hold onto them until we see
   it.  The SunPRO compiler emits variable definitions after the
   N_LBRAC, so we can call debug_record_variable immediately.  */

static bool should_record_variable_directly(struct stab_handle *info, enum debug_var_kind kind)
{
  return (kind == DEBUG_GLOBAL || kind == DEBUG_STATIC) ||
         !info->within_function ||
         (info->gcc_compiled == 0 && info->n_opt_found);
}

static struct stab_pending_var* create_pending_variable(void *dhandle, const char *name,
                                                        debug_type type, enum debug_var_kind kind,
                                                        bfd_vma val)
{
  struct stab_pending_var *v = debug_xzalloc(dhandle, sizeof(*v));
  v->name = name;
  v->type = type;
  v->kind = kind;
  v->val = val;
  return v;
}

static bool
stab_record_variable(void *dhandle, struct stab_handle *info,
                     const char *name, debug_type type,
                     enum debug_var_kind kind, bfd_vma val)
{
  if (should_record_variable_directly(info, kind))
    return debug_record_variable(dhandle, name, type, kind, val);

  struct stab_pending_var *v = create_pending_variable(dhandle, name, type, kind, val);
  v->next = info->pending;
  info->pending = v;

  return true;
}

/* Emit pending variable definitions.  This is called after we see the
   N_LBRAC that starts the block.  */

static bool
stab_emit_pending_vars (void *dhandle, struct stab_handle *info)
{
  struct stab_pending_var *v = info->pending;
  
  while (v != NULL)
    {
      if (!debug_record_variable(dhandle, v->name, v->type, v->kind, v->val))
        return false;
      v = v->next;
    }

  info->pending = NULL;
  return true;
}

/* Find the slot for a type in the database.  */

static debug_type *
stab_find_slot (void *dhandle, struct stab_handle *info, const int *typenums)
{
  unsigned int filenum;
  unsigned int tindex;
  unsigned int base_index;
  struct stab_types **ps;

  filenum = typenums[0];
  tindex = typenums[1];

  if (filenum >= info->files)
    {
      fprintf (stderr, _("Type file number %d out of range\n"), filenum);
      return NULL;
    }

  ps = info->file_types + filenum;
  base_index = tindex / STAB_TYPES_SLOTS * STAB_TYPES_SLOTS;
  tindex -= base_index;
  
  ps = find_base_index_position(ps, base_index);
  ensure_base_index_exists(dhandle, ps, base_index);

  return (*ps)->types + tindex;
}

static struct stab_types **
find_base_index_position(struct stab_types **ps, unsigned int base_index)
{
  while (*ps && (*ps)->base_index < base_index)
    ps = &(*ps)->next;
  return ps;
}

static void
ensure_base_index_exists(void *dhandle, struct stab_types **ps, unsigned int base_index)
{
  if (*ps == NULL || (*ps)->base_index != base_index)
    {
      struct stab_types *n = debug_xzalloc (dhandle, sizeof (*n));
      n->next = *ps;
      n->base_index = base_index;
      *ps = n;
    }
}

/* Find a type given a type number.  If the type has not been
   allocated yet, create an indirect type.  */

static debug_type
stab_find_type (void *dhandle, struct stab_handle *info, const int *typenums)
{
  debug_type *slot;

  if (typenums[0] == 0 && typenums[1] < 0)
    {
      return stab_xcoff_builtin_type (dhandle, info, typenums[1]);
    }

  slot = stab_find_slot (dhandle, info, typenums);
  if (slot == NULL)
    return DEBUG_TYPE_NULL;

  if (*slot == DEBUG_TYPE_NULL)
    return debug_make_indirect_type (dhandle, slot, (const char *) NULL);

  return *slot;
}

/* Record that a given type number refers to a given type.  */

static bool
stab_record_type (void *dhandle, struct stab_handle *info,
		  const int *typenums, debug_type type)
{
  debug_type *slot;

  slot = stab_find_slot (dhandle, info, typenums);
  if (slot == NULL)
    return false;

  *slot = type;

  return true;
}

/* Return an XCOFF builtin type.  */

#define SIZE_CHAR 1
#define SIZE_SHORT 2
#define SIZE_INT 4
#define SIZE_LONG 4
#define SIZE_LONGLONG 8
#define SIZE_FLOAT 4
#define SIZE_DOUBLE 8
#define SIZE_COMPLEX 8
#define SIZE_DOUBLE_COMPLEX 16

static debug_type create_int_type(void *dhandle, const char **name, int size, bool is_unsigned)
{
    return debug_make_int_type(dhandle, size, is_unsigned);
}

static debug_type create_float_type(void *dhandle, const char **name, int size)
{
    return debug_make_float_type(dhandle, size);
}

static debug_type create_bool_type(void *dhandle, const char **name, int size)
{
    return debug_make_bool_type(dhandle, size);
}

static debug_type create_complex_type(void *dhandle, const char **name, int size)
{
    return debug_make_complex_type(dhandle, size);
}

static debug_type create_void_type(void *dhandle, const char **name)
{
    return debug_make_void_type(dhandle);
}

static debug_type create_xcoff_type(void *dhandle, unsigned int typenum, const char **name)
{
    switch (typenum)
    {
    case 0: *name = "int"; return create_int_type(dhandle, name, SIZE_INT, false);
    case 1: *name = "char"; return create_int_type(dhandle, name, SIZE_CHAR, false);
    case 2: *name = "short"; return create_int_type(dhandle, name, SIZE_SHORT, false);
    case 3: *name = "long"; return create_int_type(dhandle, name, SIZE_LONG, false);
    case 4: *name = "unsigned char"; return create_int_type(dhandle, name, SIZE_CHAR, true);
    case 5: *name = "signed char"; return create_int_type(dhandle, name, SIZE_CHAR, false);
    case 6: *name = "unsigned short"; return create_int_type(dhandle, name, SIZE_SHORT, true);
    case 7: *name = "unsigned int"; return create_int_type(dhandle, name, SIZE_INT, true);
    case 8: *name = "unsigned"; return create_int_type(dhandle, name, SIZE_INT, true);
    case 9: *name = "unsigned long"; return create_int_type(dhandle, name, SIZE_LONG, true);
    case 10: *name = "void"; return create_void_type(dhandle, name);
    case 11: *name = "float"; return create_float_type(dhandle, name, SIZE_FLOAT);
    case 12: *name = "double"; return create_float_type(dhandle, name, SIZE_DOUBLE);
    case 13: *name = "long double"; return create_float_type(dhandle, name, SIZE_DOUBLE);
    case 14: *name = "integer"; return create_int_type(dhandle, name, SIZE_INT, false);
    case 15: *name = "boolean"; return create_bool_type(dhandle, name, SIZE_INT);
    case 16: *name = "short real"; return create_float_type(dhandle, name, SIZE_FLOAT);
    case 17: *name = "real"; return create_float_type(dhandle, name, SIZE_DOUBLE);
    case 18: *name = "stringptr"; return NULL;
    case 19: *name = "character"; return create_int_type(dhandle, name, SIZE_CHAR, true);
    case 20: *name = "logical*1"; return create_bool_type(dhandle, name, SIZE_CHAR);
    case 21: *name = "logical*2"; return create_bool_type(dhandle, name, SIZE_SHORT);
    case 22: *name = "logical*4"; return create_bool_type(dhandle, name, SIZE_INT);
    case 23: *name = "logical"; return create_bool_type(dhandle, name, SIZE_INT);
    case 24: *name = "complex"; return create_complex_type(dhandle, name, SIZE_COMPLEX);
    case 25: *name = "double complex"; return create_complex_type(dhandle, name, SIZE_DOUBLE_COMPLEX);
    case 26: *name = "integer*1"; return create_int_type(dhandle, name, SIZE_CHAR, false);
    case 27: *name = "integer*2"; return create_int_type(dhandle, name, SIZE_SHORT, false);
    case 28: *name = "integer*4"; return create_int_type(dhandle, name, SIZE_INT, false);
    case 29: *name = "wchar"; return create_int_type(dhandle, name, SIZE_SHORT, false);
    case 30: *name = "long long"; return create_int_type(dhandle, name, SIZE_LONGLONG, false);
    case 31: *name = "unsigned long long"; return create_int_type(dhandle, name, SIZE_LONGLONG, true);
    case 32: *name = "logical*8"; return create_bool_type(dhandle, name, SIZE_LONGLONG);
    case 33: *name = "integer*8"; return create_int_type(dhandle, name, SIZE_LONGLONG, false);
    default: abort();
    }
}

static debug_type stab_xcoff_builtin_type(void *dhandle, struct stab_handle *info, unsigned int typenum)
{
    debug_type rettype;
    const char *name;

    typenum = -typenum - 1;
    
    if (typenum >= XCOFF_TYPE_COUNT)
    {
        fprintf(stderr, _("Unrecognized XCOFF type %d\n"), -typenum - 1);
        return DEBUG_TYPE_NULL;
    }
    
    if (info->xcoff_types[typenum] != NULL)
        return info->xcoff_types[typenum];

    rettype = create_xcoff_type(dhandle, typenum, &name);
    rettype = debug_name_type(dhandle, name, rettype);
    info->xcoff_types[typenum] = rettype;
    
    return rettype;
}

/* Find or create a tagged type.  */

static struct stab_tag *
find_existing_tag(struct stab_handle *info, const char *name)
{
    for (struct stab_tag *st = info->tags; st != NULL; st = st->next)
    {
        if (st->name[0] == name[0] && strcmp(st->name, name) == 0)
            return st;
    }
    return NULL;
}

static struct stab_tag *
create_new_tag(void *dhandle, struct stab_handle *info, const char *name, enum debug_type_kind kind)
{
    struct stab_tag *st = debug_xzalloc(dhandle, sizeof(*st));
    st->next = info->tags;
    st->name = name;
    st->kind = kind;
    st->slot = DEBUG_TYPE_NULL;
    st->type = debug_make_indirect_type(dhandle, &st->slot, name);
    info->tags = st;
    return st;
}

static debug_type
stab_find_tagged_type(void *dhandle, struct stab_handle *info,
                     const char *p, int len, enum debug_type_kind kind)
{
    char *name = savestring(dhandle, p, len);
    
    debug_type dtype = debug_find_tagged_type(dhandle, name, DEBUG_KIND_ILLEGAL);
    if (dtype != DEBUG_TYPE_NULL)
        return dtype;
    
    struct stab_tag *st = find_existing_tag(info, name);
    if (st != NULL)
    {
        if (st->kind == DEBUG_KIND_ILLEGAL)
            st->kind = kind;
    }
    else
    {
        st = create_new_tag(dhandle, info, name, kind);
    }
    
    return st->type;
}

/* In order to get the correct argument types for a stubbed method, we
   need to extract the argument types from a C++ mangled string.
   Since the argument types can refer back to the return type, this
   means that we must demangle the entire physical name.  In gdb this
   is done by calling cplus_demangle and running the results back
   through the C++ expression parser.  Since we have no expression
   parser, we must duplicate much of the work of cplus_demangle here.

   We assume that GNU style demangling is used, since this is only
   done for method stubs, and only g++ should output that form of
   debugging information.  */

/* This structure is used to hold a pointer to type information which
   demangling a string.  */

struct stab_demangle_typestring
{
  /* The start of the type.  This is not null terminated.  */
  const char *typestring;
  /* The length of the type.  */
  unsigned int len;
};

/* This structure is used to hold information while demangling a
   string.  */

struct stab_demangle_info
{
  /* The debugging information handle.  */
  void *dhandle;
  /* The stab information handle.  */
  struct stab_handle *info;
  /* The array of arguments we are building.  */
  debug_type *args;
  /* Whether the method takes a variable number of arguments.  */
  bool varargs;
  /* The array of types we have remembered.  */
  struct stab_demangle_typestring *typestrings;
  /* The number of typestrings.  */
  unsigned int typestring_count;
  /* The number of typestring slots we have allocated.  */
  unsigned int typestring_alloc;
};

static void stab_bad_demangle (const char *);
static unsigned int stab_demangle_count (const char **);
static bool stab_demangle_get_count (const char **, unsigned int *);
static bool stab_demangle_prefix
  (struct stab_demangle_info *, const char **, unsigned int);
static bool stab_demangle_function_name
  (struct stab_demangle_info *, const char **, const char *);
static bool stab_demangle_signature
  (struct stab_demangle_info *, const char **);
static bool stab_demangle_qualified
  (struct stab_demangle_info *, const char **, debug_type *);
static bool stab_demangle_template
  (struct stab_demangle_info *, const char **, char **);
static bool stab_demangle_class
  (struct stab_demangle_info *, const char **, const char **);
static bool stab_demangle_args
  (struct stab_demangle_info *, const char **, debug_type **, bool *);
static bool stab_demangle_arg
  (struct stab_demangle_info *, const char **, debug_type **,
   unsigned int *, unsigned int *);
static bool stab_demangle_type
  (struct stab_demangle_info *, const char **, debug_type *);
static bool stab_demangle_fund_type
  (struct stab_demangle_info *, const char **, debug_type *);
static bool stab_demangle_remember_type
  (struct stab_demangle_info *, const char *, int);

/* Warn about a bad demangling.  */

static void stab_bad_demangle(const char *s)
{
    fprintf(stderr, _("bad mangled name `%s'\n"), s);
}

/* Get a count from a stab string.  */

static unsigned int
stab_demangle_count (const char **pp)
{
  unsigned int count = 0;
  const unsigned int DECIMAL_BASE = 10;
  const char DIGIT_ZERO = '0';
  
  while (ISDIGIT (**pp))
    {
      count = count * DECIMAL_BASE + (**pp - DIGIT_ZERO);
      ++*pp;
    }
  return count;
}

/* Require a count in a string.  The count may be multiple digits, in
   which case it must end in an underscore.  */

static bool is_valid_digit(char c)
{
    return ISDIGIT(c);
}

static unsigned int char_to_digit(char c)
{
    return c - '0';
}

static unsigned int accumulate_digits(const char **p)
{
    unsigned int count = 0;
    
    while (is_valid_digit(**p))
    {
        count *= 10;
        count += char_to_digit(**p);
        ++(*p);
    }
    
    return count;
}

static bool parse_multi_digit_count(const char **pp, unsigned int *pi)
{
    const char *p = *pp;
    unsigned int count = *pi;
    
    count = count * 10 + accumulate_digits(&p);
    
    if (*p == '_')
    {
        *pp = p + 1;
        *pi = count;
        return true;
    }
    
    return false;
}

static bool stab_demangle_get_count(const char **pp, unsigned int *pi)
{
    if (!is_valid_digit(**pp))
        return false;
    
    *pi = char_to_digit(**pp);
    ++*pp;
    
    if (is_valid_digit(**pp))
        parse_multi_digit_count(pp, pi);
    
    return true;
}

/* This function demangles a physical name, returning a NULL
   terminated array of argument types.  */

static debug_type *
stab_demangle_argtypes (void *dhandle, struct stab_handle *info,
			const char *physname, bool *pvarargs,
			unsigned int physname_len)
{
  struct stab_demangle_info minfo;

  if (physname[0] == '_' && physname[1] == 'Z')
    return stab_demangle_v3_argtypes (dhandle, info, physname, pvarargs);

  minfo.dhandle = dhandle;
  minfo.info = info;
  minfo.args = NULL;
  minfo.varargs = false;
  minfo.typestring_alloc = 10;
  minfo.typestrings
    = xmalloc (minfo.typestring_alloc * sizeof (*minfo.typestrings));
  minfo.typestring_count = 0;

  if (! stab_demangle_prefix (&minfo, &physname, physname_len))
    {
      free (minfo.typestrings);
      return NULL;
    }

  if (*physname != '\0')
    {
      if (! stab_demangle_signature (&minfo, &physname))
        {
          free (minfo.typestrings);
          return NULL;
        }
    }

  free (minfo.typestrings);

  if (minfo.args == NULL)
    fprintf (stderr, _("no argument types in mangled string\n"));

  *pvarargs = minfo.varargs;
  return minfo.args;
}

/* Demangle the prefix of the mangled name.  */

static const char* find_double_underscore(const char* scan)
{
    do {
        scan = strchr(scan, '_');
    } while (scan != NULL && *++scan != '_');
    
    return scan;
}

static const char* adjust_scan_position(const char* scan)
{
    unsigned int underscore_count = strspn(scan, "_");
    if (underscore_count > 2)
        return scan + underscore_count - 2;
    return scan;
}

static bool is_gnu_constructor(const char* scan)
{
    return ISDIGIT(scan[2]) || scan[2] == 'Q' || scan[2] == 't';
}

static const char* find_separator_underscores(const char* scan)
{
    while (*scan == '_')
        ++scan;
    return strstr(scan, "__");
}

static bool handle_no_physname(struct stab_demangle_info *minfo, const char **pp, const char** scan_ptr)
{
    *scan_ptr = find_double_underscore(*pp);
    
    if (*scan_ptr == NULL)
    {
        stab_bad_demangle(*pp);
        return false;
    }
    
    --(*scan_ptr);
    *scan_ptr = adjust_scan_position(*scan_ptr);
    return true;
}

static bool handle_gnu_constructor(const char **pp, const char* scan)
{
    *pp = scan + 2;
    return true;
}

static bool handle_prefix_with_separator(struct stab_demangle_info *minfo, const char **pp, const char* scan)
{
    const char* separator = find_separator_underscores(scan);
    
    if (separator == NULL || separator[2] == '\0')
    {
        stab_bad_demangle(*pp);
        return false;
    }
    
    return stab_demangle_function_name(minfo, pp, separator);
}

static bool handle_name_with_double_underscore(struct stab_demangle_info *minfo, const char **pp, const char* scan)
{
    if (scan[2] != '\0')
        return stab_demangle_function_name(minfo, pp, scan);
    
    stab_bad_demangle(*pp);
    return false;
}

static bool stab_demangle_prefix(struct stab_demangle_info *minfo, const char **pp, unsigned int physname_len)
{
    const char *scan;
    
    if (physname_len)
    {
        scan = *pp + physname_len;
    }
    else
    {
        if (!handle_no_physname(minfo, pp, &scan))
            return false;
    }
    
    if (scan == *pp)
    {
        if (is_gnu_constructor(scan))
            return handle_gnu_constructor(pp, scan);
        
        if (!ISDIGIT(scan[2]) && scan[2] != 't')
            return handle_prefix_with_separator(minfo, pp, scan);
    }
    
    return handle_name_with_double_underscore(minfo, pp, scan);
}

/* Demangle a function name prefix.  The scan argument points to the
   double underscore which separates the function name from the
   signature.  */

static bool
is_type_conversion_operator(const char *name, size_t length)
{
  if (length >= 5 && startswith(name, "type") && (name[4] == '$' || name[4] == '.'))
    return true;
  
  if (name[0] == '_' && name[1] == '_' && name[2] == 'o' && name[3] == 'p')
    return true;
  
  return false;
}

static int
get_operator_type_offset(const char *name)
{
  if (startswith(name, "type"))
    return 5;
  return 4;
}

static bool
process_type_conversion_operator(struct stab_demangle_info *minfo, const char *name, int offset)
{
  const char *tem = name + offset;
  return stab_demangle_type(minfo, &tem, (debug_type *) NULL);
}

static bool
stab_demangle_function_name (struct stab_demangle_info *minfo,
			     const char **pp, const char *scan)
{
  const char *name = *pp;
  size_t name_length = scan + 2 - name;
  
  *pp = scan + 2;

  if (!is_type_conversion_operator(name, name_length))
    return true;

  int offset = get_operator_type_offset(name);
  return process_type_conversion_operator(minfo, name, offset);
}

/* Demangle the signature.  This is where the argument types are
   found.  */

static bool
process_qualified_type(struct stab_demangle_info *minfo, const char **pp, const char **hold)
{
  *hold = *pp;
  if (!stab_demangle_qualified(minfo, pp, (debug_type *) NULL) ||
      !stab_demangle_remember_type(minfo, *hold, *pp - *hold))
    return false;
  *hold = NULL;
  return true;
}

static bool
process_class_type(struct stab_demangle_info *minfo, const char **pp, const char **hold)
{
  if (*hold == NULL)
    *hold = *pp;
  if (!stab_demangle_class(minfo, pp, (const char **) NULL) ||
      !stab_demangle_remember_type(minfo, *hold, *pp - *hold))
    return false;
  *hold = NULL;
  return true;
}

static bool
process_template_type(struct stab_demangle_info *minfo, const char **pp, const char **hold)
{
  if (*hold == NULL)
    *hold = *pp;
  if (!stab_demangle_template(minfo, pp, (char **) NULL) ||
      !stab_demangle_remember_type(minfo, *hold, *pp - *hold))
    return false;
  *hold = NULL;
  return true;
}

static bool
process_function_args(struct stab_demangle_info *minfo, const char **pp)
{
  return stab_demangle_args(minfo, pp, &minfo->args, &minfo->varargs);
}

static bool
handle_signature_char(struct stab_demangle_info *minfo, const char **pp, 
                      const char *orig, const char **hold, 
                      bool *expect_func, bool *func_done)
{
  switch (**pp)
    {
    case 'Q':
      if (!process_qualified_type(minfo, pp, hold))
        return false;
      *expect_func = true;
      break;

    case 'S':
    case 'C':
      if (*hold == NULL)
        *hold = *pp;
      ++*pp;
      break;

    case '0': case '1': case '2': case '3': case '4':
    case '5': case '6': case '7': case '8': case '9':
      if (!process_class_type(minfo, pp, hold))
        return false;
      *expect_func = true;
      break;

    case 'F':
      *hold = NULL;
      *func_done = true;
      ++*pp;
      if (!process_function_args(minfo, pp))
        return false;
      break;

    case 't':
      if (!process_template_type(minfo, pp, hold))
        return false;
      *expect_func = true;
      break;

    case '_':
      stab_bad_demangle(orig);
      return false;

    default:
      *func_done = true;
      if (!process_function_args(minfo, pp))
        return false;
      break;
    }
  
  return true;
}

static bool
stab_demangle_signature(struct stab_demangle_info *minfo, const char **pp)
{
  const char *orig;
  bool expect_func, func_done;
  const char *hold;

  orig = *pp;
  expect_func = false;
  func_done = false;
  hold = NULL;

  while (**pp != '\0')
    {
      if (!handle_signature_char(minfo, pp, orig, &hold, &expect_func, &func_done))
        return false;

      if (expect_func)
        {
          func_done = true;
          if (!process_function_args(minfo, pp))
            return false;
        }
    }

  if (!func_done)
    {
      if (!process_function_args(minfo, pp))
        return false;
    }

  return true;
}

/* Demangle a qualified name, such as "Q25Outer5Inner" which is the
   mangled form of "Outer::Inner".  */

static bool
parse_qualifier_count(const char **pp, unsigned int *qualifiers)
{
    const char *p;
    
    if ((*pp)[1] == '_')
    {
        p = *pp + 2;
        if (!ISDIGIT(*p) || *p == '0')
            return false;
        
        *qualifiers = atoi(p);
        while (ISDIGIT(*p))
            ++p;
        
        if (*p != '_')
            return false;
        
        *pp = p + 1;
        return true;
    }
    
    if ((*pp)[1] >= '1' && (*pp)[1] <= '9')
    {
        *qualifiers = (*pp)[1] - '0';
        if ((*pp)[2] == '_')
            ++*pp;
        *pp += 2;
        return true;
    }
    
    return false;
}

static debug_type
process_template_qualifier(struct stab_demangle_info *minfo, const char **pp,
                          bool need_type)
{
    char *name = NULL;
    
    if (!stab_demangle_template(minfo, pp, need_type ? &name : NULL))
        return DEBUG_TYPE_NULL;
    
    if (!need_type)
        return DEBUG_TYPE_NULL;
    
    return stab_find_tagged_type(minfo->dhandle, minfo->info,
                                name, strlen(name), DEBUG_KIND_CLASS);
}

static debug_type
find_field_by_name(struct stab_demangle_info *minfo, debug_type context,
                  const char *name, unsigned int len)
{
    const debug_field *fields;
    char *saved_name;
    
    if (context == DEBUG_TYPE_NULL)
        return DEBUG_TYPE_NULL;
    
    fields = debug_get_fields(minfo->dhandle, context);
    if (fields == NULL)
        return DEBUG_TYPE_NULL;
    
    saved_name = savestring(minfo->dhandle, name, len);
    
    for (; *fields != DEBUG_FIELD_NULL; fields++)
    {
        debug_type ft = debug_get_field_type(minfo->dhandle, *fields);
        const char *dn;
        
        if (ft == NULL)
            continue;
        
        dn = debug_get_type_name(minfo->dhandle, ft);
        if (dn != NULL && strcmp(dn, saved_name) == 0)
            return ft;
    }
    
    return DEBUG_TYPE_NULL;
}

static debug_type
find_type_by_name(struct stab_demangle_info *minfo, const char *name,
                 unsigned int len, unsigned int remaining_qualifiers)
{
    debug_type result;
    char *saved_name;
    
    if (remaining_qualifiers == 0)
    {
        saved_name = savestring(minfo->dhandle, name, len);
        result = debug_find_named_type(minfo->dhandle, saved_name);
        if (result != DEBUG_TYPE_NULL)
            return result;
    }
    
    return stab_find_tagged_type(minfo->dhandle, minfo->info, name, len,
                                remaining_qualifiers == 0 
                                ? DEBUG_KIND_ILLEGAL 
                                : DEBUG_KIND_CLASS);
}

static bool
process_regular_qualifier(struct stab_demangle_info *minfo, const char **pp,
                         debug_type *context, unsigned int remaining_qualifiers,
                         const char *orig)
{
    unsigned int len;
    
    len = stab_demangle_count(pp);
    if (strlen(*pp) < len)
    {
        stab_bad_demangle(orig);
        return false;
    }
    
    if (*context != DEBUG_TYPE_NULL)
    {
        debug_type found = find_field_by_name(minfo, *context, *pp, len);
        if (found != DEBUG_TYPE_NULL)
        {
            *context = found;
            *pp += len;
            return true;
        }
    }
    
    *context = find_type_by_name(minfo, *pp, len, remaining_qualifiers);
    if (*context == DEBUG_TYPE_NULL)
        return false;
    
    *pp += len;
    return true;
}

static bool
stab_demangle_qualified(struct stab_demangle_info *minfo, const char **pp,
                       debug_type *ptype)
{
    const char *orig = *pp;
    unsigned int qualifiers;
    debug_type context = DEBUG_TYPE_NULL;
    unsigned int i;
    
    if (!parse_qualifier_count(pp, &qualifiers))
    {
        stab_bad_demangle(orig);
        return false;
    }
    
    for (i = 0; i < qualifiers; i++)
    {
        if (**pp == '_')
            ++*pp;
        
        if (**pp == 't')
        {
            context = process_template_qualifier(minfo, pp, ptype != NULL);
            if (ptype != NULL && context == DEBUG_TYPE_NULL)
                return false;
        }
        else
        {
            if (ptype != NULL)
            {
                if (!process_regular_qualifier(minfo, pp, &context, 
                                              qualifiers - i - 1, orig))
                    return false;
            }
            else
            {
                unsigned int len = stab_demangle_count(pp);
                if (strlen(*pp) < len)
                {
                    stab_bad_demangle(orig);
                    return false;
                }
                *pp += len;
            }
        }
    }
    
    if (ptype != NULL)
        *ptype = context;
    
    return true;
}

/* Demangle a template.  If PNAME is not NULL, this sets *PNAME to a
   string representation of the template.  */

static bool
skip_template_name(const char **pp)
{
  unsigned int r = stab_demangle_count(pp);
  if (r == 0 || strlen(*pp) < r)
    return false;
  *pp += r;
  return true;
}

static bool
get_parameter_count(const char **pp, unsigned int *count)
{
  return stab_demangle_get_count(pp, count) != 0;
}

static bool
process_type_parameter(struct stab_demangle_info *minfo, const char **pp)
{
  ++*pp;
  return stab_demangle_type(minfo, pp, (debug_type *) NULL);
}

static void
classify_type_char(char c, bool *pointerp, bool *realp, bool *integralp, 
                   bool *charp, bool *boolp, bool *done)
{
  switch (c)
    {
    case 'P':
    case 'p':
    case 'R':
      *pointerp = true;
      *done = true;
      break;
    case 'Q':
      *integralp = true;
      *done = true;
      break;
    case 'x':
    case 'l':
    case 'i':
    case 's':
    case 'w':
      *integralp = true;
      *done = true;
      break;
    case 'b':
      *boolp = true;
      *done = true;
      break;
    case 'c':
      *charp = true;
      *done = true;
      break;
    case 'r':
    case 'd':
    case 'f':
      *realp = true;
      *done = true;
      break;
    case 'T':
    case 'v':
      abort();
    case 'C':
    case 'S':
    case 'U':
    case 'V':
    case 'F':
    case 'M':
    case 'O':
      break;
    default:
      *integralp = true;
      *done = true;
      break;
    }
}

static void
skip_digits(const char **pp)
{
  while (ISDIGIT(**pp))
    ++*pp;
}

static bool
process_integral_value(const char **pp)
{
  if (**pp == 'm')
    ++*pp;
  skip_digits(pp);
  return true;
}

static bool
process_char_value(const char **pp, const char *orig)
{
  if (**pp == 'm')
    ++*pp;
  unsigned int val = stab_demangle_count(pp);
  if (val == 0)
    {
      stab_bad_demangle(orig);
      return false;
    }
  return true;
}

static bool
process_bool_value(const char **pp, const char *orig)
{
  unsigned int val = stab_demangle_count(pp);
  if (val != 0 && val != 1)
    {
      stab_bad_demangle(orig);
      return false;
    }
  return true;
}

static bool
process_real_value(const char **pp)
{
  if (**pp == 'm')
    ++*pp;
  skip_digits(pp);
  if (**pp == '.')
    {
      ++*pp;
      skip_digits(pp);
    }
  if (**pp == 'e')
    {
      ++*pp;
      skip_digits(pp);
    }
  return true;
}

static bool
process_pointer_value(const char **pp, const char *orig)
{
  unsigned int len = stab_demangle_count(pp);
  if (len == 0)
    {
      stab_bad_demangle(orig);
      return false;
    }
  *pp += len;
  return true;
}

static bool
process_value_parameter(struct stab_demangle_info *minfo, const char **pp, 
                       const char *orig)
{
  const char *old_p = *pp;
  bool pointerp = false;
  bool realp = false;
  bool integralp = false;
  bool charp = false;
  bool boolp = false;
  bool done = false;

  if (!stab_demangle_type(minfo, pp, (debug_type *) NULL))
    return false;

  while (*old_p != '\0' && !done)
    {
      classify_type_char(*old_p, &pointerp, &realp, &integralp, 
                        &charp, &boolp, &done);
      if (!done)
        ++old_p;
    }

  if (integralp)
    return process_integral_value(pp);
  if (charp)
    return process_char_value(pp, orig);
  if (boolp)
    return process_bool_value(pp, orig);
  if (realp)
    return process_real_value(pp);
  if (pointerp)
    return process_pointer_value(pp, orig);

  return true;
}

static char *
create_demangled_string(struct stab_demangle_info *minfo, const char *orig, 
                       const char *end)
{
  char *s1 = savestring(minfo->dhandle, orig, end - orig);
  char *s2 = concat("NoSuchStrinG__", s1, (const char *) NULL);
  char *s3 = cplus_demangle(s2, demangle_flags);
  free(s2);
  return s3;
}

static char *
extract_template_name(char *s3, const char *marker)
{
  char *s4 = strstr(s3, marker);
  if (s3 == NULL || s4 == NULL)
    {
      free(s3);
      return NULL;
    }
  return s4;
}

static void
remove_extra_spaces(char *s3, char *s4, char *to)
{
  char *from;
  for (from = s3; from != s4; ++from)
    if (*from != ' ' || (from[1] == '>' && from > s3 && from[-1] == '>'))
      *to++ = *from;
}

static bool
generate_template_name(struct stab_demangle_info *minfo, const char *orig,
                      const char **pp, char **pname)
{
  if (pname == NULL)
    return true;

  char *s3 = create_demangled_string(minfo, orig, *pp);
  
  #define NOSUCH_MARKER "::NoSuchStrinG"
  char *s4 = extract_template_name(s3, NOSUCH_MARKER);
  if (s4 == NULL)
    {
      stab_bad_demangle(orig);
      return false;
    }

  char *to = s3;
  remove_extra_spaces(s3, s4, to);
  *pname = savestring(minfo->dhandle, s3, to - s3);
  free(s3);
  return true;
}

static bool
stab_demangle_template(struct stab_demangle_info *minfo, const char **pp,
                      char **pname)
{
  const char *orig = *pp;
  unsigned int r, i;

  ++*pp;

  if (!skip_template_name(pp))
    {
      stab_bad_demangle(orig);
      return false;
    }

  if (!get_parameter_count(pp, &r))
    {
      stab_bad_demangle(orig);
      return false;
    }

  for (i = 0; i < r; i++)
    {
      if (**pp == 'Z')
        {
          if (!process_type_parameter(minfo, pp))
            return false;
        }
      else
        {
          if (!process_value_parameter(minfo, pp, orig))
            return false;
        }
    }

  return generate_template_name(minfo, orig, pp, pname);
}

/* Demangle a class name.  */

static bool
stab_demangle_class (struct stab_demangle_info *minfo ATTRIBUTE_UNUSED,
		     const char **pp, const char **pstart)
{
  const char *orig = *pp;
  unsigned int n = stab_demangle_count (pp);
  
  if (strlen (*pp) < n)
    {
      stab_bad_demangle (orig);
      return false;
    }

  if (pstart != NULL)
    *pstart = *pp;

  *pp += n;
  return true;
}

/* Demangle function arguments.  If the pargs argument is not NULL, it
   is set to a NULL terminated array holding the arguments.  */

static bool
process_template_args(struct stab_demangle_info *minfo, const char **pp,
                      debug_type **pargs, unsigned int *count, unsigned int *alloc)
{
    char temptype;
    unsigned int r, t;

    temptype = **pp;
    ++*pp;

    if (temptype == 'T')
        r = 1;
    else
    {
        if (!stab_demangle_get_count(pp, &r))
            return false;
    }

    if (!stab_demangle_get_count(pp, &t) || t >= minfo->typestring_count)
        return false;

    while (r-- > 0)
    {
        const char *tem = minfo->typestrings[t].typestring;
        if (!stab_demangle_arg(minfo, &tem, pargs, count, alloc))
            return false;
    }

    return true;
}

static void
initialize_args(debug_type **pargs, bool *pvarargs, unsigned int *alloc)
{
    *alloc = 10;
    if (pargs != NULL)
        *pargs = xmalloc(*alloc * sizeof(**pargs));
    if (pvarargs != NULL)
        *pvarargs = false;
}

static void
finalize_args(struct stab_demangle_info *minfo, debug_type **pargs, unsigned int count)
{
    if (pargs != NULL)
    {
        debug_type *xargs;
        (*pargs)[count] = DEBUG_TYPE_NULL;
        xargs = debug_xalloc(minfo->dhandle, (count + 1) * sizeof(*xargs));
        memcpy(xargs, *pargs, (count + 1) * sizeof(*xargs));
        free(*pargs);
        *pargs = xargs;
    }
}

static void
cleanup_args(debug_type **pargs)
{
    if (pargs != NULL)
    {
        free(*pargs);
        *pargs = NULL;
    }
}

static bool
process_single_arg(struct stab_demangle_info *minfo, const char **pp,
                   debug_type **pargs, unsigned int *count, unsigned int *alloc)
{
    if (**pp == 'N' || **pp == 'T')
        return process_template_args(minfo, pp, pargs, count, alloc);
    
    return stab_demangle_arg(minfo, pp, pargs, count, alloc);
}

static bool
stab_demangle_args(struct stab_demangle_info *minfo, const char **pp,
                   debug_type **pargs, bool *pvarargs)
{
    const char *orig;
    unsigned int alloc, count;

    orig = *pp;
    count = 0;

    initialize_args(pargs, pvarargs, &alloc);

    while (**pp != '_' && **pp != '\0' && **pp != 'e')
    {
        if (!process_single_arg(minfo, pp, pargs, &count, &alloc))
        {
            stab_bad_demangle(orig);
            cleanup_args(pargs);
            return false;
        }
    }

    finalize_args(minfo, pargs, count);

    if (**pp == 'e')
    {
        if (pvarargs != NULL)
            *pvarargs = true;
        ++*pp;
    }

    return true;
}

/* Demangle a single argument.  */

static bool
stab_demangle_arg (struct stab_demangle_info *minfo, const char **pp,
		   debug_type **pargs, unsigned int *pcount,
		   unsigned int *palloc)
{
  const char *start;
  debug_type type;

  start = *pp;
  if (! stab_demangle_type (minfo, pp,
			    pargs == NULL ? (debug_type *) NULL : &type)
      || ! stab_demangle_remember_type (minfo, start, *pp - start))
    return false;

  if (pargs == NULL)
    return true;

  if (type == DEBUG_TYPE_NULL)
    return false;

  if (*pcount + 1 >= *palloc)
    {
      #define ALLOC_INCREMENT 10
      *palloc += ALLOC_INCREMENT;
      *pargs = xrealloc (*pargs, *palloc * sizeof (**pargs));
    }
  (*pargs)[*pcount] = type;
  ++*pcount;

  return true;
}

/* Demangle a type.  If the ptype argument is not NULL, *ptype is set
   to the newly allocated type.  */

static bool
parse_array_dimension(const char **pp, unsigned long *high)
{
  *high = 0;
  while (**pp != '\0' && **pp != '_')
    {
      if (!ISDIGIT(**pp))
        return false;
      *high *= 10;
      *high += **pp - '0';
      ++*pp;
    }
  return **pp == '_';
}

static debug_type
get_or_create_int_type(struct stab_demangle_info *minfo)
{
  debug_type int_type = debug_find_named_type(minfo->dhandle, "int");
  if (int_type == NULL)
    int_type = debug_make_int_type(minfo->dhandle, 4, false);
  return int_type;
}

static bool
parse_back_reference(const char **pp, struct stab_demangle_info *minfo, 
                    const char *orig, debug_type *ptype)
{
  unsigned int i;
  const char *p;
  
  ++*pp;
  if (!stab_demangle_get_count(pp, &i))
    {
      stab_bad_demangle(orig);
      return false;
    }
  if (i >= minfo->typestring_count)
    {
      stab_bad_demangle(orig);
      return false;
    }
  p = minfo->typestrings[i].typestring;
  return stab_demangle_type(minfo, &p, ptype);
}

static bool
parse_function_type(const char **pp, struct stab_demangle_info *minfo,
                   const char *orig, debug_type *ptype)
{
  debug_type *args;
  bool varargs;
  
  ++*pp;
  if (!stab_demangle_args(minfo, pp,
                         ptype == NULL ? (debug_type **)NULL : &args,
                         ptype == NULL ? (bool *)NULL : &varargs))
    return false;
    
  if (**pp != '_')
    {
      stab_bad_demangle(orig);
      return false;
    }
  ++*pp;
  
  if (!stab_demangle_type(minfo, pp, ptype))
    return false;
    
  if (ptype != NULL)
    *ptype = debug_make_function_type(minfo->dhandle, *ptype, args, varargs);
    
  return true;
}

static bool
parse_class_name(const char **pp, struct stab_demangle_info *minfo,
                const char *orig, debug_type *class_type)
{
  unsigned int n = stab_demangle_count(pp);
  if (strlen(*pp) < n)
    {
      stab_bad_demangle(orig);
      return false;
    }
  const char *name = *pp;
  *pp += n;
  
  if (class_type != NULL)
    {
      *class_type = stab_find_tagged_type(minfo->dhandle, minfo->info,
                                         name, (int)n, DEBUG_KIND_CLASS);
      if (*class_type == DEBUG_TYPE_NULL)
        return false;
    }
  return true;
}

static bool
parse_member_modifiers(const char **pp)
{
  if (**pp == 'C' || **pp == 'V')
    ++*pp;
  return true;
}

static bool
parse_member_function(const char **pp, struct stab_demangle_info *minfo,
                     const char *orig, debug_type **args, bool *varargs,
                     debug_type *ptype)
{
  parse_member_modifiers(pp);
  
  if (**pp != 'F')
    {
      stab_bad_demangle(orig);
      return false;
    }
  ++*pp;
  
  return stab_demangle_args(minfo, pp,
                           ptype == NULL ? (debug_type **)NULL : args,
                           ptype == NULL ? (bool *)NULL : varargs);
}

static bool
parse_member_or_offset(const char **pp, struct stab_demangle_info *minfo,
                      const char *orig, debug_type *ptype)
{
  bool memberp = **pp == 'M';
  debug_type class_type = DEBUG_TYPE_NULL;
  debug_type *args = NULL;
  bool varargs = false;
  
  ++*pp;
  
  if (ISDIGIT(**pp))
    {
      if (!parse_class_name(pp, minfo, orig, ptype != NULL ? &class_type : NULL))
        return false;
    }
  else if (**pp == 'Q')
    {
      if (!stab_demangle_qualified(minfo, pp,
                                  ptype == NULL ? (debug_type *)NULL : &class_type))
        return false;
    }
  else
    {
      stab_bad_demangle(orig);
      return false;
    }
  
  if (memberp)
    {
      if (!parse_member_function(pp, minfo, orig, &args, &varargs, ptype))
        return false;
    }
  
  if (**pp != '_')
    {
      stab_bad_demangle(orig);
      return false;
    }
  ++*pp;
  
  if (!stab_demangle_type(minfo, pp, ptype))
    return false;
  
  if (ptype != NULL)
    {
      if (!memberp)
        *ptype = debug_make_offset_type(minfo->dhandle, class_type, *ptype);
      else
        *ptype = debug_make_method_type(minfo->dhandle, *ptype,
                                       class_type, args, varargs);
    }
  
  return true;
}

static bool
stab_demangle_type(struct stab_demangle_info *minfo, const char **pp,
                  debug_type *ptype)
{
  const char *orig = *pp;
  
  switch (**pp)
    {
    case 'P':
    case 'p':
      ++*pp;
      if (!stab_demangle_type(minfo, pp, ptype))
        return false;
      if (ptype != NULL)
        *ptype = debug_make_pointer_type(minfo->dhandle, *ptype);
      break;
      
    case 'R':
      ++*pp;
      if (!stab_demangle_type(minfo, pp, ptype))
        return false;
      if (ptype != NULL)
        *ptype = debug_make_reference_type(minfo->dhandle, *ptype);
      break;
      
    case 'A':
      {
        unsigned long high;
        ++*pp;
        
        if (!parse_array_dimension(pp, &high))
          {
            stab_bad_demangle(orig);
            return false;
          }
        ++*pp;
        
        if (!stab_demangle_type(minfo, pp, ptype))
          return false;
          
        if (ptype != NULL)
          {
            debug_type int_type = get_or_create_int_type(minfo);
            *ptype = debug_make_array_type(minfo->dhandle, *ptype, int_type,
                                          0, high, false);
          }
      }
      break;
      
    case 'T':
      return parse_back_reference(pp, minfo, orig, ptype);
      
    case 'F':
      return parse_function_type(pp, minfo, orig, ptype);
      
    case 'M':
    case 'O':
      return parse_member_or_offset(pp, minfo, orig, ptype);
      
    case 'G':
      ++*pp;
      if (!stab_demangle_type(minfo, pp, ptype))
        return false;
      break;
      
    case 'C':
      ++*pp;
      if (!stab_demangle_type(minfo, pp, ptype))
        return false;
      if (ptype != NULL)
        *ptype = debug_make_const_type(minfo->dhandle, *ptype);
      break;
      
    case 'Q':
      if (!stab_demangle_qualified(minfo, pp, ptype))
        return false;
      break;
      
    default:
      if (!stab_demangle_fund_type(minfo, pp, ptype))
        return false;
      break;
    }
  
  return true;
}

/* Demangle a fundamental type.  If the ptype argument is not NULL,
   *ptype is set to the newly allocated type.  */

static bool parse_type_modifiers(const char **pp, bool *constp, bool *volatilep, 
                                  bool *unsignedp, bool *signedp)
{
    bool done = false;
    while (!done)
    {
        switch (**pp)
        {
        case 'C':
            *constp = true;
            ++*pp;
            break;
        case 'U':
            *unsignedp = true;
            ++*pp;
            break;
        case 'S':
            *signedp = true;
            ++*pp;
            break;
        case 'V':
            *volatilep = true;
            ++*pp;
            break;
        default:
            done = true;
            break;
        }
    }
    return true;
}

static debug_type find_or_create_type(struct stab_demangle_info *minfo, 
                                      const char *type_name, 
                                      debug_type (*create_func)(void *, int, bool),
                                      int size, bool is_unsigned)
{
    debug_type type = debug_find_named_type(minfo->dhandle, type_name);
    if (type == DEBUG_TYPE_NULL)
        type = create_func(minfo->dhandle, size, is_unsigned);
    return type;
}

static debug_type find_or_create_named_type(struct stab_demangle_info *minfo,
                                            const char *type_name,
                                            debug_type (*create_func)(void *))
{
    debug_type type = debug_find_named_type(minfo->dhandle, type_name);
    if (type == DEBUG_TYPE_NULL)
        type = create_func(minfo->dhandle);
    return type;
}

static debug_type find_or_create_float(struct stab_demangle_info *minfo,
                                       const char *type_name, int size)
{
    debug_type type = debug_find_named_type(minfo->dhandle, type_name);
    if (type == DEBUG_TYPE_NULL)
        type = debug_make_float_type(minfo->dhandle, size);
    return type;
}

static debug_type find_or_create_bool(struct stab_demangle_info *minfo,
                                      const char *type_name, int size)
{
    debug_type type = debug_find_named_type(minfo->dhandle, type_name);
    if (type == DEBUG_TYPE_NULL)
        type = debug_make_bool_type(minfo->dhandle, size);
    return type;
}

static const char *get_int_type_name(bool unsignedp, bool signedp, 
                                     const char *base_unsigned,
                                     const char *base_signed,
                                     const char *base_default)
{
    if (unsignedp)
        return base_unsigned;
    if (signedp)
        return base_signed;
    return base_default;
}

static bool handle_void_type(struct stab_demangle_info *minfo, debug_type *ptype)
{
    if (ptype != NULL)
    {
        *ptype = debug_find_named_type(minfo->dhandle, "void");
        if (*ptype == DEBUG_TYPE_NULL)
            *ptype = debug_make_void_type(minfo->dhandle);
    }
    return true;
}

static bool handle_integer_type(struct stab_demangle_info *minfo, debug_type *ptype,
                                const char *unsigned_name, const char *signed_name,
                                int size, bool unsignedp)
{
    if (ptype != NULL)
    {
        const char *type_name = unsignedp ? unsigned_name : signed_name;
        *ptype = find_or_create_type(minfo, type_name, debug_make_int_type, size, unsignedp);
    }
    return true;
}

static bool handle_char_type(struct stab_demangle_info *minfo, debug_type *ptype,
                             bool unsignedp, bool signedp)
{
    if (ptype != NULL)
    {
        const char *type_name = get_int_type_name(unsignedp, signedp, 
                                                  "unsigned char", "signed char", "char");
        *ptype = find_or_create_type(minfo, type_name, debug_make_int_type, 1, unsignedp);
    }
    return true;
}

static bool handle_class_type(struct stab_demangle_info *minfo, const char **pp,
                              debug_type *ptype, const char *orig)
{
    const char *hold;
    if (!stab_demangle_class(minfo, pp, &hold))
        return false;
    
    if (ptype != NULL)
    {
        char *name = savestring(minfo->dhandle, hold, *pp - hold);
        *ptype = debug_find_named_type(minfo->dhandle, name);
        if (*ptype == DEBUG_TYPE_NULL)
        {
            *ptype = stab_find_tagged_type(minfo->dhandle, minfo->info,
                                          hold, *pp - hold,
                                          DEBUG_KIND_ILLEGAL);
            if (*ptype == DEBUG_TYPE_NULL)
                return false;
        }
    }
    return true;
}

static bool handle_template_type(struct stab_demangle_info *minfo, const char **pp,
                                 debug_type *ptype)
{
    char *name;
    if (!stab_demangle_template(minfo, pp, ptype != NULL ? &name : NULL))
        return false;
    
    if (ptype != NULL)
    {
        *ptype = stab_find_tagged_type(minfo->dhandle, minfo->info,
                                       name, strlen(name),
                                       DEBUG_KIND_CLASS);
        if (*ptype == DEBUG_TYPE_NULL)
            return false;
    }
    return true;
}

static void apply_type_qualifiers(struct stab_demangle_info *minfo, debug_type *ptype,
                                  bool constp, bool volatilep)
{
    if (ptype != NULL)
    {
        if (constp)
            *ptype = debug_make_const_type(minfo->dhandle, *ptype);
        if (volatilep)
            *ptype = debug_make_volatile_type(minfo->dhandle, *ptype);
    }
}

#define INT_SIZE_2 2
#define INT_SIZE_4 4
#define INT_SIZE_8 8
#define FLOAT_SIZE_4 4
#define FLOAT_SIZE_8 8
#define BOOL_SIZE_4 4

static bool
stab_demangle_fund_type(struct stab_demangle_info *minfo, const char **pp,
                       debug_type *ptype)
{
    const char *orig = *pp;
    bool constp = false;
    bool volatilep = false;
    bool unsignedp = false;
    bool signedp = false;

    parse_type_modifiers(pp, &constp, &volatilep, &unsignedp, &signedp);

    switch (**pp)
    {
    case '\0':
    case '_':
        stab_bad_demangle(orig);
        break;
    case 'v':
        handle_void_type(minfo, ptype);
        ++*pp;
        break;
    case 'x':
        handle_integer_type(minfo, ptype, "long long unsigned int", "long long int", 
                           INT_SIZE_8, unsignedp);
        ++*pp;
        break;
    case 'l':
        handle_integer_type(minfo, ptype, "long unsigned int", "long int", 
                           INT_SIZE_4, unsignedp);
        ++*pp;
        break;
    case 'i':
        handle_integer_type(minfo, ptype, "unsigned int", "int", 
                           INT_SIZE_4, unsignedp);
        ++*pp;
        break;
    case 's':
        handle_integer_type(minfo, ptype, "short unsigned int", "short int", 
                           INT_SIZE_2, unsignedp);
        ++*pp;
        break;
    case 'b':
        if (ptype != NULL)
            *ptype = find_or_create_bool(minfo, "bool", BOOL_SIZE_4);
        ++*pp;
        break;
    case 'c':
        handle_char_type(minfo, ptype, unsignedp, signedp);
        ++*pp;
        break;
    case 'w':
        if (ptype != NULL)
            *ptype = find_or_create_type(minfo, "__wchar_t", debug_make_int_type, 
                                        INT_SIZE_2, true);
        ++*pp;
        break;
    case 'r':
        if (ptype != NULL)
            *ptype = find_or_create_float(minfo, "long double", FLOAT_SIZE_8);
        ++*pp;
        break;
    case 'd':
        if (ptype != NULL)
            *ptype = find_or_create_float(minfo, "double", FLOAT_SIZE_8);
        ++*pp;
        break;
    case 'f':
        if (ptype != NULL)
            *ptype = find_or_create_float(minfo, "float", FLOAT_SIZE_4);
        ++*pp;
        break;
    case 'G':
        ++*pp;
        if (!ISDIGIT(**pp))
        {
            stab_bad_demangle(orig);
            return false;
        }
    case '0': case '1': case '2': case '3': case '4':
    case '5': case '6': case '7': case '8': case '9':
        if (!handle_class_type(minfo, pp, ptype, orig))
            return false;
        break;
    case 't':
        if (!handle_template_type(minfo, pp, ptype))
            return false;
        break;
    default:
        stab_bad_demangle(orig);
        return false;
    }

    apply_type_qualifiers(minfo, ptype, constp, volatilep);
    return true;
}

/* Remember a type string in a demangled string.  */

static bool
stab_demangle_remember_type (struct stab_demangle_info *minfo,
			     const char *p, int len)
{
  const int TYPESTRING_ALLOC_INCREMENT = 10;
  
  if (minfo->typestring_count >= minfo->typestring_alloc)
    {
      minfo->typestring_alloc += TYPESTRING_ALLOC_INCREMENT;
      minfo->typestrings
	= xrealloc (minfo->typestrings,
		    minfo->typestring_alloc * sizeof (*minfo->typestrings));
    }

  minfo->typestrings[minfo->typestring_count].typestring = p;
  minfo->typestrings[minfo->typestring_count].len = (unsigned int) len;
  ++minfo->typestring_count;

  return true;
}

/* Demangle names encoded using the g++ V3 ABI.  The newer versions of
   g++ which use this ABI do not encode ordinary method argument types
   in a mangled name; they simply output the argument types.  However,
   for a static method, g++ simply outputs the return type and the
   physical name.  So in that case we need to demangle the name here.
   Here PHYSNAME is the physical name of the function, and we set the
   variable pointed at by PVARARGS to indicate whether this function
   is varargs.  This returns NULL, or a NULL terminated array of
   argument types.  */

static debug_type *
stab_demangle_v3_argtypes (void *dhandle, struct stab_handle *info,
			   const char *physname, bool *pvarargs)
{
  struct demangle_component *dc;
  void *mem;
  debug_type *pargs;

  dc = cplus_demangle_v3_components (physname, DMGL_PARAMS | demangle_flags, &mem);
  if (dc == NULL)
    {
      stab_bad_demangle (physname);
      return NULL;
    }

  if (!is_valid_function_component(dc))
    {
      fprintf (stderr, _("Demangled name is not a function\n"));
      free (mem);
      return NULL;
    }

  pargs = stab_demangle_v3_arglist (dhandle, info,
				    dc->u.s_binary.right->u.s_binary.right,
				    pvarargs);

  free (mem);

  return pargs;
}

static bool
is_valid_function_component(const struct demangle_component *dc)
{
  return dc->type == DEMANGLE_COMPONENT_TYPED_NAME
      && dc->u.s_binary.right->type == DEMANGLE_COMPONENT_FUNCTION_TYPE;
}

/* Demangle an argument list in a struct demangle_component tree.
   Returns a DEBUG_TYPE_NULL terminated array of argument types, and
   sets *PVARARGS to indicate whether this is a varargs function.  */

static debug_type *
allocate_initial_args(void)
{
  const unsigned int INITIAL_ALLOC = 10;
  return xmalloc(INITIAL_ALLOC * sizeof(debug_type));
}

static debug_type *
grow_args_array(debug_type *pargs, unsigned int *alloc)
{
  const unsigned int GROWTH_SIZE = 10;
  *alloc += GROWTH_SIZE;
  return xrealloc(pargs, *alloc * sizeof(debug_type));
}

static bool
validate_component_type(struct demangle_component *dc, debug_type *pargs)
{
  if (dc->type != DEMANGLE_COMPONENT_ARGLIST)
    {
      fprintf(stderr, _("Unexpected type in v3 arglist demangling\n"));
      free(pargs);
      return false;
    }
  return true;
}

static bool
is_empty_context(struct demangle_component *dc)
{
  return dc->u.s_binary.left == NULL;
}

static bool
process_varargs(bool varargs, bool *pvarargs, debug_type *pargs)
{
  if (varargs)
    {
      *pvarargs = true;
      return true;
    }
  free(pargs);
  return false;
}

static debug_type *
finalize_args(void *dhandle, debug_type *pargs, unsigned int count)
{
  debug_type *xargs;
  pargs[count] = DEBUG_TYPE_NULL;
  xargs = debug_xalloc(dhandle, (count + 1) * sizeof(debug_type));
  memcpy(xargs, pargs, (count + 1) * sizeof(debug_type));
  free(pargs);
  return xargs;
}

static debug_type *
stab_demangle_v3_arglist(void *dhandle, struct stab_handle *info,
                        struct demangle_component *arglist,
                        bool *pvarargs)
{
  struct demangle_component *dc;
  unsigned int alloc = 10;
  unsigned int count = 0;
  debug_type *pargs;
  
  pargs = allocate_initial_args();
  *pvarargs = false;

  for (dc = arglist; dc != NULL; dc = dc->u.s_binary.right)
    {
      debug_type arg;
      bool varargs;

      if (!validate_component_type(dc, pargs))
        return NULL;

      if (is_empty_context(dc))
        break;

      arg = stab_demangle_v3_arg(dhandle, info, dc->u.s_binary.left,
                                 NULL, &varargs);
      if (arg == NULL)
        {
          if (!process_varargs(varargs, pvarargs, pargs))
            return NULL;
          continue;
        }

      if (count + 1 >= alloc)
        pargs = grow_args_array(pargs, &alloc);

      pargs[count] = arg;
      ++count;
    }

  return finalize_args(dhandle, pargs, count);
}

/* Convert a struct demangle_component tree describing an argument
   type into a debug_type.  */

static debug_type handle_unhandled_component(void *dhandle, struct demangle_component *dc)
{
    fprintf(stderr, _("Unrecognized demangle component %d\n"), (int)dc->type);
    return NULL;
}

static debug_type find_field_in_context(void *dhandle, debug_type context, 
                                       const char *name, int len)
{
    const debug_field *fields = debug_get_fields(dhandle, context);
    if (fields == NULL)
        return NULL;
    
    for (; *fields != DEBUG_FIELD_NULL; fields++)
    {
        debug_type ft = debug_get_field_type(dhandle, *fields);
        if (ft == NULL)
            return NULL;
        
        const char *dn = debug_get_type_name(dhandle, ft);
        if (dn != NULL && (int)strlen(dn) == len && strncmp(dn, name, len) == 0)
            return ft;
    }
    return NULL;
}

static debug_type handle_name_component(void *dhandle, struct stab_handle *info,
                                       struct demangle_component *dc, debug_type context)
{
    if (context != NULL)
    {
        debug_type ft = find_field_in_context(dhandle, context, 
                                             dc->u.s_name.s, dc->u.s_name.len);
        if (ft != NULL)
            return ft;
    }
    return stab_find_tagged_type(dhandle, info, dc->u.s_name.s,
                                dc->u.s_name.len, DEBUG_KIND_ILLEGAL);
}

static debug_type handle_template_component(void *dhandle, struct stab_handle *info,
                                           struct demangle_component *dc)
{
    size_t alc;
    char *p = cplus_demangle_print(DMGL_PARAMS | demangle_flags, dc, 20, &alc);
    if (p == NULL)
    {
        fprintf(stderr, _("Failed to print demangled template\n"));
        return NULL;
    }
    
    debug_type dt = stab_find_tagged_type(dhandle, info, p, strlen(p),
                                         DEBUG_KIND_CLASS);
    free(p);
    return dt;
}

static debug_type apply_type_modifier(void *dhandle, int type, debug_type dt)
{
    switch (type)
    {
    case DEMANGLE_COMPONENT_RESTRICT:
        return dt;
    case DEMANGLE_COMPONENT_VOLATILE:
        return debug_make_volatile_type(dhandle, dt);
    case DEMANGLE_COMPONENT_CONST:
        return debug_make_const_type(dhandle, dt);
    case DEMANGLE_COMPONENT_POINTER:
        return debug_make_pointer_type(dhandle, dt);
    case DEMANGLE_COMPONENT_REFERENCE:
        return debug_make_reference_type(dhandle, dt);
    default:
        abort();
    }
}

static debug_type handle_type_modifier(void *dhandle, struct stab_handle *info,
                                      struct demangle_component *dc)
{
    debug_type dt = stab_demangle_v3_arg(dhandle, info, dc->u.s_binary.left, 
                                        NULL, NULL);
    if (dt == NULL)
        return NULL;
    
    return apply_type_modifier(dhandle, dc->type, dt);
}

static debug_type handle_function_type(void *dhandle, struct stab_handle *info,
                                      struct demangle_component *dc)
{
    debug_type dt;
    if (dc->u.s_binary.left == NULL)
        dt = debug_make_void_type(dhandle);
    else
        dt = stab_demangle_v3_arg(dhandle, info, dc->u.s_binary.left, NULL, NULL);
    
    if (dt == NULL)
        return NULL;
    
    bool varargs;
    debug_type *pargs = stab_demangle_v3_arglist(dhandle, info,
                                                dc->u.s_binary.right, &varargs);
    if (pargs == NULL)
        return NULL;
    
    return debug_make_function_type(dhandle, dt, pargs, varargs);
}

static debug_type create_builtin_type(void *dhandle, const char *type_name, bool *pvarargs)
{
    #define TYPE_SIZE_1 1
    #define TYPE_SIZE_2 2
    #define TYPE_SIZE_4 4
    #define TYPE_SIZE_8 8
    #define TYPE_SIZE_16 16
    
    if (strcmp(type_name, "signed char") == 0)
        return debug_make_int_type(dhandle, TYPE_SIZE_1, false);
    else if (strcmp(type_name, "bool") == 0)
        return debug_make_bool_type(dhandle, TYPE_SIZE_1);
    else if (strcmp(type_name, "char") == 0)
        return debug_make_int_type(dhandle, TYPE_SIZE_1, false);
    else if (strcmp(type_name, "double") == 0)
        return debug_make_float_type(dhandle, TYPE_SIZE_8);
    else if (strcmp(type_name, "long double") == 0)
        return debug_make_float_type(dhandle, TYPE_SIZE_8);
    else if (strcmp(type_name, "float") == 0)
        return debug_make_float_type(dhandle, TYPE_SIZE_4);
    else if (strcmp(type_name, "__float128") == 0)
        return debug_make_float_type(dhandle, TYPE_SIZE_16);
    else if (strcmp(type_name, "unsigned char") == 0)
        return debug_make_int_type(dhandle, TYPE_SIZE_1, true);
    else if (strcmp(type_name, "int") == 0)
        return debug_make_int_type(dhandle, TYPE_SIZE_4, false);
    else if (strcmp(type_name, "unsigned int") == 0)
        return debug_make_int_type(dhandle, TYPE_SIZE_4, true);
    else if (strcmp(type_name, "long") == 0)
        return debug_make_int_type(dhandle, TYPE_SIZE_4, false);
    else if (strcmp(type_name, "unsigned long") == 0)
        return debug_make_int_type(dhandle, TYPE_SIZE_4, true);
    else if (strcmp(type_name, "__int128") == 0)
        return debug_make_int_type(dhandle, TYPE_SIZE_16, false);
    else if (strcmp(type_name, "unsigned __int128") == 0)
        return debug_make_int_type(dhandle, TYPE_SIZE_16, true);
    else if (strcmp(type_name, "short") == 0)
        return debug_make_int_type(dhandle, TYPE_SIZE_2, false);
    else if (strcmp(type_name, "unsigned short") == 0)
        return debug_make_int_type(dhandle, TYPE_SIZE_2, true);
    else if (strcmp(type_name, "void") == 0)
        return debug_make_void_type(dhandle);
    else if (strcmp(type_name, "wchar_t") == 0)
        return debug_make_int_type(dhandle, TYPE_SIZE_4, true);
    else if (strcmp(type_name, "long long") == 0)
        return debug_make_int_type(dhandle, TYPE_SIZE_8, false);
    else if (strcmp(type_name, "unsigned long long") == 0)
        return debug_make_int_type(dhandle, TYPE_SIZE_8, true);
    else if (strcmp(type_name, "...") == 0)
    {
        if (pvarargs == NULL)
            fprintf(stderr, _("Unexpected demangled varargs\n"));
        else
            *pvarargs = true;
        return NULL;
    }
    else
    {
        fprintf(stderr, _("Unrecognized demangled builtin type\n"));
        return NULL;
    }
}

static debug_type handle_builtin_type(void *dhandle, struct demangle_component *dc,
                                     bool *pvarargs)
{
    size_t alc;
    char *p = cplus_demangle_print(DMGL_PARAMS | demangle_flags, dc, 20, &alc);
    if (p == NULL)
    {
        fprintf(stderr, _("Couldn't get demangled builtin type\n"));
        return NULL;
    }
    
    debug_type ret = create_builtin_type(dhandle, p, pvarargs);
    free(p);
    return ret;
}

static debug_type
stab_demangle_v3_arg(void *dhandle, struct stab_handle *info,
                    struct demangle_component *dc, debug_type context,
                    bool *pvarargs)
{
    if (pvarargs != NULL)
        *pvarargs = false;
    
    switch (dc->type)
    {
    case DEMANGLE_COMPONENT_LOCAL_NAME:
    case DEMANGLE_COMPONENT_TYPED_NAME:
    case DEMANGLE_COMPONENT_TEMPLATE_PARAM:
    case DEMANGLE_COMPONENT_CTOR:
    case DEMANGLE_COMPONENT_DTOR:
    case DEMANGLE_COMPONENT_JAVA_CLASS:
    case DEMANGLE_COMPONENT_RESTRICT_THIS:
    case DEMANGLE_COMPONENT_VOLATILE_THIS:
    case DEMANGLE_COMPONENT_CONST_THIS:
    case DEMANGLE_COMPONENT_VENDOR_TYPE_QUAL:
    case DEMANGLE_COMPONENT_COMPLEX:
    case DEMANGLE_COMPONENT_IMAGINARY:
    case DEMANGLE_COMPONENT_VENDOR_TYPE:
    case DEMANGLE_COMPONENT_ARRAY_TYPE:
    case DEMANGLE_COMPONENT_PTRMEM_TYPE:
    case DEMANGLE_COMPONENT_ARGLIST:
    default:
        return handle_unhandled_component(dhandle, dc);
        
    case DEMANGLE_COMPONENT_NAME:
        return handle_name_component(dhandle, info, dc, context);
        
    case DEMANGLE_COMPONENT_QUAL_NAME:
        context = stab_demangle_v3_arg(dhandle, info, dc->u.s_binary.left,
                                      context, NULL);
        if (context == NULL)
            return NULL;
        return stab_demangle_v3_arg(dhandle, info, dc->u.s_binary.right,
                                   context, NULL);
        
    case DEMANGLE_COMPONENT_TEMPLATE:
        return handle_template_component(dhandle, info, dc);
        
    case DEMANGLE_COMPONENT_SUB_STD:
        return stab_find_tagged_type(dhandle, info, dc->u.s_string.string,
                                    dc->u.s_string.len, DEBUG_KIND_ILLEGAL);
        
    case DEMANGLE_COMPONENT_RESTRICT:
    case DEMANGLE_COMPONENT_VOLATILE:
    case DEMANGLE_COMPONENT_CONST:
    case DEMANGLE_COMPONENT_POINTER:
    case DEMANGLE_COMPONENT_REFERENCE:
        return handle_type_modifier(dhandle, info, dc);
        
    case DEMANGLE_COMPONENT_FUNCTION_TYPE:
        return handle_function_type(dhandle, info, dc);
        
    case DEMANGLE_COMPONENT_BUILTIN_TYPE:
        return handle_builtin_type(dhandle, dc, pvarargs);
    }
}
